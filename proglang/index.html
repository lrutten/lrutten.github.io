<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>lrutten - lrutten</title>
  <meta name="description" content="Introduction This text gives an overview for the following programming languages:
 C C&#43;&#43; Java Bash Python Ruby Javascript Dart Ocaml Go Rust Clojure Scheme Coloru Haskell XSL Prolog Erlang Elixir Crystal  C This is the famous first C example:
#include &lt;stdio.h&gt; int main(int argc, char **argv) { printf(&quot;hello world\n&quot;); } Variables and types Every variable must be declared.
This example shows the main() function as an entrypoint for the program."><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "lrutten",
    
    "url": "https:\/\/lrutten.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/lrutten.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/lrutten.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/lrutten.github.io\/proglang\/",
          "name": ""
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : ""
  },
  "headline": "",
  "description" : "Introduction This text gives an overview for the following programming languages:\n C C\u002b\u002b Java Bash Python Ruby Javascript Dart Ocaml Go Rust Clojure Scheme Coloru Haskell XSL Prolog Erlang Elixir Crystal  C This is the famous first C example:\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char **argv) { printf(\u0026quot;hello world\\n\u0026quot;); } Variables and types Every variable must be declared.\nThis example shows the main() function as an entrypoint for the program.",
  "inLanguage" : "en",
  "wordCount":  55510 ,
  "datePublished" : "0001-01-01T00:00:00",
  "dateModified" : "0001-01-01T00:00:00",
  "image" : "https:\/\/lrutten.github.io\/",
  "keywords" : [ "" ],
  "mainEntityOfPage" : "https:\/\/lrutten.github.io\/proglang\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/lrutten.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/lrutten.github.io\/",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="lrutten" />
<meta property="og:description" content="Introduction This text gives an overview for the following programming languages:
 C C&#43;&#43; Java Bash Python Ruby Javascript Dart Ocaml Go Rust Clojure Scheme Coloru Haskell XSL Prolog Erlang Elixir Crystal  C This is the famous first C example:
#include &lt;stdio.h&gt; int main(int argc, char **argv) { printf(&quot;hello world\n&quot;); } Variables and types Every variable must be declared.
This example shows the main() function as an entrypoint for the program.">
<meta property="og:url" content="https://lrutten.github.io/proglang/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="lrutten" />

  <meta name="twitter:title" content="lrutten" />
  <meta name="twitter:description" content="Introduction This text gives an overview for the following programming languages:
 C C&#43;&#43; Java Bash Python Ruby Javascript Dart Ocaml Go Rust Clojure Scheme Coloru Haskell XSL Prolog Erlang Elixir â€¦">
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.85.0" />
  <link rel="alternate" href="https://lrutten.github.io/index.xml" type="application/rss+xml" title="lrutten"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://lrutten.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" /><link rel="stylesheet" href="https://lrutten.github.io/css/syntax.css" /><link rel="stylesheet" href="https://lrutten.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://lrutten.github.io/">lrutten</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Start" href="/">Start</a>
            </li>
          
        
          
            <li>
              <a title="About" href="/about/">About</a>
            </li>
          
        
          
            <li>
              <a title="Programming languages" href="/proglang/">Programming languages</a>
            </li>
          
        

        

        
      </ul>
    </div>

    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  <div class="intro-header"></div>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <h1 id="introduction">Introduction</h1>
<p>This text gives an overview for the following programming languages:</p>
<ul>
<li><a href="#c">C</a></li>
<li><a href="#c-1">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#bash">Bash</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#ruby">Ruby</a></li>
<li><a href="#javascript">Javascript</a></li>
<li><a href="#dart">Dart</a></li>
<li><a href="#ocaml">Ocaml</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#rust">Rust</a></li>
<li><a href="#clojure">Clojure</a></li>
<li><a href="#scheme">Scheme</a></li>
<li><a href="#coloru">Coloru</a></li>
<li><a href="#haskell">Haskell</a></li>
<li><a href="#xsl">XSL</a></li>
<li><a href="#prolog">Prolog</a></li>
<li><a href="#erlang">Erlang</a></li>
<li><a href="#elixir">Elixir</a></li>
<li><a href="#crystal">Crystal</a></li>
</ul>
<h1 id="c">C</h1>
<p>This is the famous first C example:</p>
<pre><code class="language-{.C}" data-lang="{.C}">#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
   printf(&quot;hello world\n&quot;);
}
</code></pre><h2 id="variables-and-types">Variables and types</h2>
<p>Every variable must be declared.</p>
<p>This example shows the <code>main()</code> function as an entrypoint for the program.
It contains one local variable <code>num</code>.</p>
<pre><code class="language-{.C}" data-lang="{.C}">#include &lt;stdio.h&gt;

int main() /* a sample program */
{
   int num;

   num = 1;
   printf(&quot;%d is an integer number\n&quot;,  num );

   return 0;
}
</code></pre><p><code>help()</code> is a simple function.</p>
<pre><code class="language-{.C}" data-lang="{.C}">#include &lt;stdio.h&gt;

void help()
{
   printf(&quot;hier is hulp\n&quot;);
}

int main()
{
   printf(&quot;ik heb hulp nodig\n&quot;);
   help();
   printf(&quot;dank u&quot;);

   return 0;
}
</code></pre><p>Other types are <code>double</code>, <code>float</code> en <code>char</code>.</p>
<p>A declaration without initialization:</p>
<pre><code>int a,b,c;
</code></pre><h3 id="the-int-type">The <code>int</code> type</h3>
<p>This type is used for integer numbers.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td>4 bytes</td>
</tr>
<tr>
<td></td>
<td>range: -2147483648 tot +2147483647</td>
</tr>
</tbody>
</table>
<p>This size and range is valid in 32 bit Linux.</p>
<p>With initialization:</p>
<pre><code>int raindays = 25;
int hours,minutes = 3;
</code></pre><p>Only <code>minuten</code> is initialized with the value 3, <code>hours</code> is not initialized.</p>
<p>Integer constants can be written in base 10, 8 and 16.</p>
<table>
<thead>
<tr>
<th>Example</th>
<th>Base</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>123</code></td>
<td>decimal</td>
</tr>
<tr>
<td><code>0400</code></td>
<td>octal</td>
</tr>
<tr>
<td><code>0xF3ca</code></td>
<td>hexadecimal</td>
</tr>
</tbody>
</table>
<p>A number starting with <code>0</code> is octal, <code>0x</code> is hexadecimal.</p>
<p>Extra words to be added before the type are <code>short</code>, <code>long</code> en <code>unsigned</code>.</p>
<p>On a 32 bit Linux the <code>gcc</code> allows the following types:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Size, range</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>short int</code>, <code>short</code></td>
<td>size: 2 bytes, range: -32768 tot +32767</td>
</tr>
<tr>
<td><code>long int</code>, <code>int</code> or <code>long</code></td>
<td>size: 4 bytes, range: -2147483648 tot +2147483647</td>
</tr>
<tr>
<td><code>long long int</code> or <code>long long</code></td>
<td>size: 8 bytes, range: âˆ’9,223,372,036,854,775,808 to 9,223,372,036,854,775,807, from âˆ’2^63 to 2^63 âˆ’ 1</td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td>size: 2 bytes, range: 0 tot +65535</td>
</tr>
<tr>
<td><code>unsigned long</code> or <code>unsigned int</code></td>
<td>size: 4 bytes, range:0 tot +4294967295</td>
</tr>
<tr>
<td><code>unsigned long long int</code> or  <code>unsigned long long</code></td>
<td>size: 8 bytes, range: 0 to  18,446,744,073,709,551,615, to 2^64 âˆ’ 1</td>
</tr>
</tbody>
</table>
<p><code>long</code> constants have the de letter <code>L</code> at the end.</p>
<pre><code>123L 045L 0x1234L
</code></pre>
<p>These are the suffixes:</p>
<dl>
<dt>None</dt>
<dd>type: <code>int</code>, <code>long int</code> or <code>long long int</code></dd>
<dt><code>L</code></dt>
<dd>type: <code>long int</code> or <code>long long int</code></dd>
<dt><code>LL</code></dt>
<dd>type: <code>long long int</code></dd>
<dt><code>U</code></dt>
<dd>type: <code>unsigned int</code>, <code>unsigned long int</code> or
<code>unsigned long long int</code></dd>
<dt><code>UL</code></dt>
<dd>type: <code>unsigned long int</code> or <code>unsigned long long int</code></dd>
<dt><code>ULL</code></dt>
<dd>type: <code>unsigned long long int</code></dd>
</dl>
<p>When calling <code>printf()</code> the right % notation must be used.</p>
<pre><code class="language-{.C}" data-lang="{.C}">int main()
{
   unsigned un = 40000;
   long ln = 2000000000;
   unsigned long uln = 4000000000;

   printf(&quot;un: %u ln: %ld uln: %lu\n&quot;,un,ln,uln);

   return 0;
}
</code></pre><p>The following overview shows all the % notations:</p>
<table>
<thead>
<tr>
<th></th>
<th><code>char</code></th>
<th><code>short int</code></th>
<th><code>int</code></th>
<th><code>long int</code></th>
<th><code>long long int</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>with sign</td>
<td><code>%hhd</code></td>
<td><code>%hd</code></td>
<td><code>%d</code></td>
<td><code>%ld</code></td>
<td><code>%lld</code></td>
</tr>
<tr>
<td>without sign</td>
<td><code>%hhu</code></td>
<td><code>%hu</code></td>
<td><code>%u</code></td>
<td><code>%lu</code></td>
<td><code>%llu</code></td>
</tr>
</tbody>
</table>
<h4 id="het-char-type">Het <code>char</code> type</h4>
<p>This type takes 1 byte memory and the values are from -128 to 127.
Constants look like this:</p>
<pre><code>'A' 'c' '0'
</code></pre>
<p>Contstants with a special meaning are:</p>
<dl>
<dt><code>'\n'</code></dt>
<dd>
<p>new line</p>
</dd>
<dt><code>'\t'</code></dt>
<dd>
<p>tab</p>
</dd>
<dt><code>'\a'</code></dt>
<dd>
<p>bell signal</p>
</dd>
<dt><code>'\b'</code></dt>
<dd>
<p>backspace</p>
</dd>
<dt><code>'\f'</code></dt>
<dd>
<p>formfeed</p>
</dd>
<dt><code>'\r'</code></dt>
<dd>
<p>carriage return</p>
</dd>
<dt><code>'\t'</code></dt>
<dd>
<p>horizontal tab</p>
</dd>
<dt><code>'\v'</code></dt>
<dd>
<p>vertical tab</p>
</dd>
<dt><code>'\\'</code></dt>
<dd>
<p>backslash</p>
</dd>
<dt><code>'\?'</code></dt>
<dd>
<p>question mark</p>
</dd>
<dt><code>'\''</code></dt>
<dd>
<p>single quote</p>
</dd>
<dt><code>'\&quot;'</code></dt>
<dd>
<p>double quote</p>
</dd>
<dt><code>'\0'</code></dt>
<dd>
<p>null character</p>
</dd>
</dl>
<p>Code in octal:</p>
<pre><code>'\123'
</code></pre>
<p>code in hexadecimal:</p>
<pre><code>'\x1b'
</code></pre>
<h4 id="the-types-float-double-and-long-double">The types <code>float</code>, <code>double</code> and <code>long double</code></h4>
<p>For double numbers these types are available:</p>
<table>
<thead>
<tr>
<th></th>
<th>suffix</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float</code></td>
<td><code>f</code> or <code>F</code></td>
<td>size: 4 bytes, range: 3.4e-38 tot 3.4e+38</td>
</tr>
<tr>
<td><code>double</code>:</td>
<td>none</td>
<td>size: 8 bytes, range: 1.7e-308 tot 1.7e+308</td>
</tr>
<tr>
<td><code>long double</code></td>
<td><code>l</code> or <code>L</code></td>
<td>size: 12 bytes, mantisse 19 cijfers, exponent: âˆ’16382 tot 16383, precision: 80 bit</td>
</tr>
</tbody>
</table>
<p>These sizes and ranges are valid for the GNU C compiler on a 32 Linux platform.</p>
<p>Examples:</p>
<pre><code>123.45F
.556L
46.
12e-3F
15.5E20
</code></pre>
<p>When printing <code>double</code> and <code>float</code> variables these % notations are helpful:</p>
<ul>
<li><code>%f</code> normal notation</li>
<li><code>%e</code> exponent notation</li>
<li><code>%g</code> automatic choice between normal or exponent notation</li>
</ul>
<h4 id="the-enumeration-type">The enumeration type</h4>
<p>Use symbols ad values.</p>
<pre><code>enum days =
{
   sundag,monday,tuesday,wednesday,thursday,
   friday,saturday
} today, tomorrow;
</code></pre>
<p>The internal values start at 0.</p>
<pre><code>enum days yesterday;
yesterday = wednesday;
</code></pre>
<p>You can choose your own values.</p>
<pre><code>enum year
{
   America=1776, Bastille=1789, VanGogh=1890
} fact;
</code></pre>
<h4 id="the-sizeof-function">The <code>sizeof()</code> function</h4>
<p><code>int sizeof()</code> is a builtin function and returns the size in bytes of a type ar a variable.</p>
<pre><code class="language-{.C}" data-lang="{.C}">#include &lt;stdio.h&gt;

int main()
{
   printf(&quot;length char: %d\n&quot;,sizeof(char));
   printf(&quot;length short int: %d\n&quot;,sizeof(short int));
   printf(&quot;length int: %d\n&quot;,sizeof(int));
   printf(&quot;length long int: %d\n&quot;,sizeof(long int));
   printf(&quot;length long long int: %d\n&quot;,sizeof(long long int));
   printf(&quot;length float: %d\n&quot;,sizeof(float));
   printf(&quot;length double: %d\n&quot;,sizeof(double));
   printf(&quot;length long double: %d&quot;,sizeof(long double));

   return 0;
}
</code></pre><p>This is the output on a 32 bit Linux machine.</p>
<pre><code>length char: 1
length short int: 2
length int: 4
length long int: 4
length long long int: 8
length float: 4
length double: 8
length long double: 12
</code></pre>
<h2 id="character-strings-define-printfscanf">Character strings, <code>#define</code>, <code>printf()</code>,<code>scanf()</code></h2>
<h3 id="strings">Strings</h3>
<p>Stringconstants have a concluding zero at the end.</p>
<pre><code>printf(&quot;abcde&quot;);
</code></pre>
<p>In memory this sequence of bytes is saved.</p>
<pre><code>'a' 'b' 'c' 'd' 'e' '\0'
</code></pre>
<p>If you declare an array to save a string, the size must be big enough.</p>
<pre><code>char name[40];
</code></pre>
<p><code>sizeof(name)</code> will return 40 as the size of the array is 40 bytes.
If you use <code>strlen()</code>, you get the effective zero based length.</p>
<h3 id="tekstvervanging-met-define">Tekstvervanging met <code>#define</code></h3>
<p>Use <code>#define</code> sparingly to define constants. Don&rsquo;t use it as an alternate way of defining functions.
The preprocessor is doing the text replacement.</p>
<p>C source &mdash;&gt; preprocessor &mdash;&gt; compiler</p>
<p>Some examples:</p>
<pre><code>#define PI 3.14159
#define DOLLAR '$'
#define DEBUG  1
</code></pre>
<h3 id="conversion-notations-for-printf">Conversion notations for <code>printf()</code></h3>
<p>These are the percent notations tio be used in <code>printf()</code>:</p>
<dl>
<dt><code>%d</code> <code>%i</code></dt>
<dd>integer decimal number</dd>
<dt><code>%o</code></dt>
<dd>octal</dd>
</dl>
<p>There is no leading 0 in the output.</p>
<dl>
<dt><code>%x</code> <code>%X</code></dt>
<dd>hexadecimal</dd>
</dl>
<p>There is no leading <code>0x</code> or <code>0X</code>.</p>
<dl>
<dt><code>%u</code></dt>
<dd>decimal number without sign</dd>
<dt><code>%c</code></dt>
<dd>char</dd>
<dt><code>%s</code></dt>
<dd>string</dd>
</dl>
<p><code>\0</code> marks the end of the string.</p>
<dl>
<dt><code>%f</code></dt>
<dd>floating point without e notation</dd>
<dt><code>%e</code> <code>%E</code></dt>
<dd>floating point with e notatie</dd>
<dt><code>%g</code> <code>%G</code></dt>
<dd>automatic choice whether with or without e notation</dd>
<dt><code>%p</code></dt>
<dd>pointer</dd>
<dt><code>%%</code></dt>
<dd>percent character</dd>
</dl>
<p>Extra</p>
<dl>
<dt><code>-</code></dt>
<dd>align left instead of right
<p>printf(&quot;%-10d&quot;, 123);</p>
</dd>
<dt><code>+</code></dt>
<dd>always add the sign character.</dd>
<dt>space</dt>
<dd>Als het eerste teken geen plus- of minteken is, wordt een spatie
voor het getal gezet.</dd>
<dt><code>0</code></dt>
<dd>output leading zero&rsquo;s</dd>
<dt><code>#</code></dt>
<dd>alternative form</dd>
<dt>getal</dt>
<dd>minimal field width
<p>printf(&quot;%8d&quot;, 0x1234);</p>
</dd>
<dt>.getal</dt>
<dd>precision
<p>printf(&quot;%6.2f&quot;,10/3);</p>
</dd>
<dt><code>*</code></dt>
<dd>variable format
<p>printf(&quot;%*.*f&quot;, widht,precision, 1.0/3.0 );</p>
</dd>
</dl>
<p>Some other extra characters work as modifiers to determine the size.</p>
<dl>
<dt><code>h</code></dt>
<dd><code>short</code> instead of <code>int</code></dd>
<dt><code>l</code></dt>
<dd><code>long</code> instead of <code>int</code>
<p>printf(&quot;%ld&quot;, 0x1234L);</p>
</dd>
<dt><code>L</code></dt>
<dd><code>long double</code> in plaats van <code>double</code></dd>
</dl>
<h3 id="conversion-notations-for-scanf">Conversion notations for <code>scanf()</code></h3>
<pre><code>int num;
scanf(&quot;%d&quot;,&amp;num);
</code></pre>
<p>The formatstring contains one or more <code>%</code> notations.
Other characters are allowed:</p>
<ul>
<li>spaces or tabs: these will be ignored.</li>
<li>normal characters, must be in the input.</li>
</ul>
<p>Use <code>*</code> to ignore the input, for example in <code>%*s</code>.</p>
<p>These are the percent notations:</p>
<dl>
<dt><code>%d</code></dt>
<dd>decimal integer</dd>
<dt><code>%i</code></dt>
<dd>integer number, leading 0 for octal, 0x for hexadecimal</dd>
<dt><code>%o</code></dt>
<dd>octal integer</dd>
<dt><code>%x</code> <code>%X</code></dt>
<dd>hexadecimal</dd>
<dt><code>%u</code></dt>
<dd>decimal without sign</dd>
<dt><code>%c</code></dt>
<dd>character</dd>
<dt><code>%s</code></dt>
<dd>string of non-white</dd>
<dt><code>%f</code> <code>%e</code> <code>%</code></dt>
<dd>floating point number</dd>
<dt><code>%p</code></dt>
<dd>pointer</dd>
<dt><code>%n</code></dt>
<dd>read the number of input fields.</dd>
<dt><code>[â€¦]</code></dt>
<dd>pattern to be input</dd>
<dt><code>[^â€¦]</code></dt>
<dd>inverse pattern</dd>
<dt><code>%%</code></dt>
<dd>percent character</dd>
</dl>
<h2 id="assignment-operators-and-expression">Assignment, operators and expression</h2>
<h3 id="assignment">Assignment</h3>
<pre><code>a = 1;
</code></pre>
<p>Special form:</p>
<pre><code>a = b = c = 1;
</code></pre>
<p>The order is <code>c</code> gets 1, then <code>b</code> and at last <code>a</code>.</p>
<h3 id="arithmic-operators">Arithmic operators</h3>
<p>Arithmic operators are <code>+</code>, <code>-</code>, <code>*</code> en <code>/</code>.</p>
<p><code>39/5</code> yiekds <code>7</code></p>
<p><code>39.0/5</code> yields <code>7.8</code></p>
<p>Integer modulo operator:</p>
<p><code>39%5</code> yields <code>4</code></p>
<ul>
<li>binary: <code>+</code> <code>-</code> <code>*</code> <code>/</code></li>
<li>unary: <code>+</code> <code>-</code></li>
</ul>
<p>This is possible:</p>
<pre><code>a + +(b - c)
</code></pre>
<p>There is no power operator.</p>
<table>
<thead>
<tr>
<th>prioriteit</th>
<th>operator</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>hoog</td>
<td><code>()</code></td>
<td>van links naar rechts</td>
</tr>
<tr>
<td></td>
<td><code>-</code> <code>+</code> unair</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>\*</code> <code>/</code> <code>%</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>+</code> <code>-</code> binair</td>
<td>van links naar rechts</td>
</tr>
<tr>
<td>laag</td>
<td><code>=</code></td>
<td>van rechts naar links</td>
</tr>
</tbody>
</table>
<h3 id="increment-and-decrement--and---">Increment and decrement <code>++</code> and <code>--</code></h3>
<p>You can choose at which side the <code>++</code> or <code>--</code>:</p>
<pre><code>a++;
a--;
</code></pre>
<p>or</p>
<pre><code>++a;
--a;
</code></pre>
<p>Watch out:</p>
<pre><code>x*y++ is x\*(y++)
</code></pre>
<p>Use postfix of prefix notatie:</p>
<pre><code>m = 0;
n = ++m; // n gets 1
</code></pre>
<h3 id="bit-operators">Bit operators</h3>
<p>These bit operators can only be used with integers.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>bitwise and</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td><code>^</code></td>
<td>bitwise exclusieve or</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>shift left</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>shift right</td>
</tr>
<tr>
<td><code>~</code></td>
<td>one&rsquo;s complement (unary)</td>
</tr>
</tbody>
</table>
<p>The last operator is unary, the rest is binary; Shift operators have the number of bits to be shifted the second operand.</p>
<pre><code>x = x | 0x10;  // set bit 4
x = x &amp; ~0x10; // clear bit 4
</code></pre>
<h3 id="short-form-of-assignment-and-operator">Short form of assignment and operator</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x = x + a</code></td>
<td>becomes</td>
<td><code>x += a</code></td>
</tr>
<tr>
<td><code>x = x - a</code></td>
<td></td>
<td><code>x -= a</code></td>
</tr>
<tr>
<td><code>x = x * a</code></td>
<td></td>
<td><code>x *= a</code></td>
</tr>
<tr>
<td><code>x = x / a</code></td>
<td></td>
<td><code>x /= a</code></td>
</tr>
<tr>
<td><code>x = x % a</code></td>
<td></td>
<td><code>x %= a</code></td>
</tr>
<tr>
<td><code>x = x &lt;&lt; a</code></td>
<td></td>
<td><code>x &lt;&lt;= a</code></td>
</tr>
<tr>
<td><code>x = x &gt;&gt; a</code></td>
<td></td>
<td><code>x &gt;&gt;= a</code></td>
</tr>
<tr>
<td><code>x = x &amp; a</code></td>
<td></td>
<td><code>x &amp;= a</code></td>
</tr>
<tr>
<td><code>x = x ^ a</code></td>
<td></td>
<td><code>x ^= a</code></td>
</tr>
<tr>
<td>`x = x</td>
<td>a`</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="expressions">Expressions</h3>
<pre><code>5
-125
1+1
a = 3
b = ++b % 4
c &gt; 3.14
</code></pre>
<h3 id="actions">Actions</h3>
<p>This program calculates the sum of 1 to 20.</p>
<pre><code>int main()
{
   int teller, som; //declaration

   teller = 0;     // assignment
   som = 0;        // assignment
   while (teller++ &lt; 20)     // while
   {
      som = som + teller;    // assignment with expression
   }
   printf(&quot;som = %d\n&quot;,som); // function call

   return 0;
}
</code></pre>
<p>Every statement has an ending <code>;</code>.
The <code>while</code> statement has a single statement which means that the braces could be omitted
but nowaydays this is considered as bad practice.</p>
<h3 id="type-conversion">Type conversion</h3>
<h4 id="automatic-conversion">Automatic conversion</h4>
<p>The compiler will warn you when an automatic possibly faulty conversion occurs.</p>
<pre><code>In function â€˜mainâ€™:
warning: overflow in implicit constant conversion [-Woverflow]
    char c = 200 + 321;
</code></pre>
<h4 id="cast-statement">Cast statement</h4>
<p>Write a type between parntheses.</p>
<pre><code>int m;

m = 1.6 + 1.5;             // yields 3
m = (int) 1.6 + (int) 1.5; // yields 2
</code></pre>
<p>When casting to <code>int</code> the number will be truncated. No rounding is applied.</p>
<h2 id="making-choices">Making choices</h2>
<h3 id="the-if-statement">The <code>if</code> statement</h3>
<p>Since has no explicit boolean type the result of the conditional
expression is 0 or not zero.</p>
<ul>
<li>not 0 : execute the yes side</li>
<li>0 : execute the no side if it exists</li>
</ul>
<p>This is an <code>if</code> without <code>else</code>.</p>
<pre><code>if (a == b)
{
   printf(&quot;two equal numbers:\n&quot;);
   printf(&quot;%d en %d\n&quot;, a, b);
}
</code></pre>
<p>We kunnen ook een opdracht laten uitvoeren als de voorwaarde niet waar
is. Dit wordt aangegeven door het woord <code>else</code>.</p>
<pre><code>if (a == 0)
{
   printf(&quot;the number is 0\n&quot;);
}
else
{
   printf(&quot;the number is not 0\n&quot;);
}
</code></pre>
<p>More than one <code>if</code> is possible:</p>
<pre><code>if (a == 0)
{
   printf(&quot;null\n&quot;);
}
else
{
   if (a &gt; 0)
   {
      printf(&quot;positive\n&quot;);
   }
   else
   {
      printf(&quot;negative\n&quot;);
   }
}
</code></pre>
<h3 id="comparing-numbers">Comparing numbers</h3>
<p>Numbers can be compared:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>less than</td>
</tr>
<tr>
<td>&gt;</td>
<td>bigger than</td>
</tr>
<tr>
<td>&lt;=</td>
<td>less than or equal</td>
</tr>
<tr>
<td>&gt;=</td>
<td>bigger than or equal</td>
</tr>
<tr>
<td>==</td>
<td>equal</td>
</tr>
<tr>
<td>!=</td>
<td>not equal</td>
</tr>
</tbody>
</table>
<p>The assignment and comparison can be combined.</p>
<pre><code>if ((a = b) == 0)
</code></pre>
<p>The priority of relational operatoren is lower than that of the arithmic operators.
The expression <code>a + b == 0</code> can be read as <code>(a + b) == 0</code>.</p>
<h3 id="logical-operators">Logical operators</h3>
<pre><code>// count the lowercase letters in a line
int main()
{
   char t;
   int  n = 0;

   while ((t=getchar()) != '\n')
   {
      if (t &gt;= 'a' &amp;&amp; t &lt;= 'z')
      {
         n++;
      }
   }
   printf(&quot;The number is %d\n&quot;, n);

   return 0;
}
</code></pre>
<p>These are the logical operators:</p>
<ul>
<li><code>&amp;&amp;</code> logical and</li>
<li><code>||</code> logical or</li>
<li><code>!</code>  logical not</li>
</ul>
<p>The order of evaluation is from left to right.
If the result is already determined after the evaluation of the first expression, the second
one is not evaluated.</p>
<pre><code>0 &amp;&amp; expr2  // always yield  0
1 || expr2  // always yields 1
</code></pre>
<p>This short circuit mechanism is handy to guard against forbidden calculations.</p>
<pre><code>if ( n != 0 &amp;&amp; 12/n == 2)
{
   printf(&quot;n is 5 or 6\n&quot;);
}
</code></pre>
<p>The priority of the logical operators are:</p>
<ul>
<li><code>!</code> has a highr than <code>&amp;&amp;</code> and <code>||</code></li>
<li><code>&amp;&amp;</code> has a higher priority than <code>||</code> .</li>
</ul>
<p>The logical operators have a lower prioriteit than the relationele ones.</p>
<p>If you combine bit and relational operators, mind the fact that bit operators have a lower priority
than the relational ones. The next example needs parentheses.</p>
<pre><code>(x &amp; 0x8) == 0 // test whether bit is 0
</code></pre>
<h3 id="conditional-expression-">Conditional expression <code>?:</code></h3>
<p>This expression a choice between two values.</p>
<pre><code>a = (b &lt; 0) ? -b : b;
</code></pre>
<p>This can be written with <code>if</code>:</p>
<pre><code>if (b &lt; 0)
{
   a = -b;
}
else
{
   a = b;
}
</code></pre>
<h3 id="more-than-one-choice-with-switch">More than one choice with <code>switch</code></h3>
<pre><code>int main()
{
   char letter;

   printf(&quot;geef een letter en ik geef je een vogelnaam\n&quot;);
   while ( ( letter=getchar() ) != '#')
   {
      switch (letter)
      {
         case 'c' :
            printf(&quot;cormorant, phalacrocorax carbo\n&quot;);
            break;
         case 'r' :
            printf(&quot;ringed plover, charadrius hiaticula\n&quot;);
            break;
         case 'f' :
            printf(&quot;citril finch, serinus citrinella\n&quot;);
            break;
         case 'd' :
            printf(&quot;dune pipit, anthus campestris\n&quot;);
            break;
         case 'e' :
            printf(&quot;eider, somateria mollissima\n&quot;);
            break;
         default :
            printf(&quot;no other letters allowed\n&quot;);
            break;
      }
   }

   return 0;
}
</code></pre>
<p>Use only <code>int</code> or <code>char</code> expressions.
More than one <code>case</code> is allowed.</p>
<pre><code>case 'F' :
case 'f' :
   printf(&quot;fitis, phylloscopus trochilus\n&quot;);
   break;
</code></pre>
<h2 id="loops-and-other-control-expressions">Loops and other control expressions</h2>
<h3 id="while-loop"><code>while</code> loop</h3>
<p>This is the general form:</p>
<pre><code>while (conditional expression)
   action;

while (conditional expression)
{
   action1;
   action2;
}
</code></pre>
<p>As long as the conditional expression returns true, the <code>while</code> actions will be executed.</p>
<p>Here are some examples each of which shows a different way to increment <code>i</code>.</p>
<ul>
<li>no end:</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>i = 1;
while (i &lt; 10)
{
   printf(&quot;dit is i: %d\n&quot;, i);
}
</code></pre>
<ul>
<li>result: 2 - 9</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>i = 1;
while (++i &lt; 10)
{
   printf(&quot;dit is i: %d\n&quot;, i);
}
</code></pre>
<ul>
<li>result: 2 - 10</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>i = 1;
while (i++ &lt; 10)
{
   printf(&quot;dit is i: %d\n&quot;, i);
}
</code></pre>
<ul>
<li>result: 1 - 9</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>i = 1;
while (i &lt; 10)
{
   printf(&quot;dit is i: %d\n&quot;, i);
   i++;
}
</code></pre>
<h3 id="for-herhalingsopdracht"><code>for</code> herhalingsopdracht</h3>
<p>The <code>for</code> loop is handy when the number of iteration is known in advance.</p>
<pre><code>for (i = 1; i &lt; 10; i++)
{
   printf(&quot;dit is i: %d\n&quot;, i);
}
</code></pre>
<p>Some other examples:</p>
<ul>
<li>empty action</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>for (n = 1; n &lt;= 10000; n++)
{

}
</code></pre>
<ul>
<li>step is not 1</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>for (n = 2; n &lt; 100; n += 11)
{
   printf(&quot;%d\n&quot;, n);
}
</code></pre>
<ul>
<li>step change with <code>*</code></li>
</ul>
<!-- raw HTML omitted -->
<pre><code>for (bedrag = 100; bedrag &lt; 200; bedrag *= 1.08)
{
   printf(&quot;bedrag: %.2f\n&quot;, bedrag);
}
</code></pre>
<ul>
<li><code>char</code> als loop counter</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>for (t = 'a'; t &lt;= 'z'; t++)
{
   printf(&quot;%c&quot;, t);
}
</code></pre>
<ul>
<li>the last part of the <code>for</code> left out</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>for (u = 1; u &lt; 1000; )
{
   u *= 2;
}
</code></pre>
<ul>
<li>empty parts in <code>for</code></li>
</ul>
<!-- raw HTML omitted -->
<pre><code>for ( ; ; )
{
   printf(&quot;hallo\n&quot;);
}
</code></pre>
<p>De algemene vorm van de <code>for</code> opdracht is:</p>
<pre><code>for ( initialization ; test ; change )
   action
</code></pre>
<p>Use <code>,</code> if one of the paths between de brackets of the <code>for</code> needs an extra action.</p>
<pre><code>for (j=1, amount = 100; amount &lt; 200; j++, amount *= 1.08)
{
   printf(&quot;year: %d amount: %.2f\n&quot;, j, amount);
}
</code></pre>
<h3 id="do-while-loop"><code>do while</code> loop</h3>
<p>This type of loop has its conditional expression at the end.
This means that the actions will be executed at least once.</p>
<p>The general form is:</p>
<pre><code>do
   action
while ( conditional expression );
</code></pre>
<p>This example reads the characters of the input line.</p>
<pre><code>do
{
   scanf(&quot;%c&quot;, &amp;teken);
   printf(&quot;%c heeft als code %d\n&quot;, teken, teken);
} while (teken != '\n');
</code></pre>
<h3 id="break-en-continue-with-loopq"><code>break</code> en <code>continue</code> with loopq</h3>
<p><code>break</code> and <code>continue</code> infuence the way the actions within te loop are executed.</p>
<h4 id="break"><code>break</code></h4>
<p>In this example <code>break</code> is used twice to stop the loop.</p>
<pre><code>i = 0;
while (1 == 1)
{
   printf(&quot;geef een getal: &quot;);
   scanf(&quot;%d&quot;, &amp;getal);
   if (getal == 0)
   {
      break;
   }
   printf(&quot;kwadraat van %d is %d\n&quot;,
      getal, getal*getal);
   if (++i &gt; 20)
   {
      break;
   }
}
</code></pre>
<p>This is the same example rewritten without <code>break</code>.</p>
<pre><code>#define FALSE 0
#define TRUE 1

einde = FALSE;
i = 0;
while ( !einde )
{
   printf(&quot;geef een getal: &quot;);
   scanf(&quot;%d&quot;, &amp;getal);
   if (getal == 0)
   {
      einde = TRUE;
   }
   else
   {
      printf(&quot;kwadraat van %d is %d\n&quot;,
         getal, getal*getal);
      if (++i &gt; 20)
      {
         einde = TRUE;
      }
   }
}
</code></pre>
<h4 id="continue"><code>continue</code></h4>
<p>This keyword forces the loop to restart.
It is a way to jump over a number of actions.</p>
<pre><code>while( (ch = getchar() ) != EOF)
{
   if (ch == ' ')
   {
      continue;
   }
   putchar( ch );
   teller++;
}
</code></pre>
<p>And written without <code>continue</code>:</p>
<pre><code>while( (ch = getchar() ) != EOF)
{
   if (ch != ' ')
   {
      putchar( ch );
      teller++;
   }
}
</code></pre>
<h3 id="goto"><code>goto</code></h3>
<p>The <code>goto</code> keyword can be used to jump to a different point in the program.
It should be avoided. <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<h2 id="functies">Functies</h2>
<h3 id="kennismaking">Kennismaking</h3>
<p>Bij een van de eerste programmavoorbeelden hebben we al kennisgemaakt
met functies. Een functie groepeert meerdere opdrachten bij een naam.
Deze opdrachten kunnen uitgevoerd worden, als we de functienaam als een
gewone opdracht gebruiken.</p>
<p>In het volgende voorbeeld wordt de functie lijn gebruikt om tweemaal een
lijn van sterretjes op het scherm te schrijven.</p>
<pre><code>void lijn()
{
   int i;

   for (i=0; i&lt;18; i++)
   {
      printf(&quot;*&quot;);
   }
   printf(&quot;\n&quot;);
}

int main()
{
   lijn();
   printf(&quot;Dit is de cursus C\n&quot;);
   lijn();

   return 0;
}
</code></pre>
<p>Uit dit voorbeeld blijkt ook dat we variabelen kunnen declareren binnen
de functie. De variabele <code>i</code> mag alleen maar gebruikt worden binnen de
functie. De declaratie van de variabelen binnen de functie worden vlak
na de openingsaccolade vermeld. Deze vorm van lokale variabelen is
trouwens niet beperkt tot functies. De syntax is algemeen geldig: na
elke openingsaccolade die opdrachten groepeert, mogen we variabelen
declareren.</p>
<h3 id="parameters">Parameters</h3>
<p>We kunnen de flexibiliteit van een functie verhogen als we bij de oproep
een waarde doorgeven. Dit betekent dat we een gedeelte van de werking
verschuiven naar de oproep van de functie. In het voorbeeld wordt
vastgelegd dat de functie <code>spatie()</code> een waarde van het type <code>int</code>
ontvangt bij de oproep. De waarde komt terecht in de variabele <code>aantal</code>
en wordt door de functie gebruikt om het aantal spaties te bepalen. Bij
de oproep wordt de door te geven waarde tussen de functiehaken
geplaatst.</p>
<pre><code>void spatie(int aantal)
{
   int i;

   for (i=0; i &lt; aantal; i++)
   {
      printf(&quot; &quot;);
   }
}

int main()
{
   printf(&quot;Dit is de cursus C\n&quot;);
   spatie(16);
   printf(&quot;+++\n&quot;);

   return 0;
}
</code></pre>
<p>In verband met parameters kent men de volgende terminologie:</p>
<dl>
<dt>formele parameter</dt>
<dd>de variabele die de doorgegeven waarde ontvangt</dd>
<dt>actuele parameter</dt>
<dd>de werkelijke waarde die doorgegeven wordt.</dd>
</dl>
<p>We kunnen een functie met meerdere parameters voorzien. De formele en
actuele parameters worden gescheiden door kommaâ€™s.</p>
<pre><code>tlijn(char t, int n)
{
   int i;

   for (i=0; i &lt; n; i++)
   {
      printf(&quot;%c&quot;, t);
   }
}
</code></pre>
<p>De functie <code>tlijn()</code> kan zo opgeroepen worden:</p>
<pre><code>tlijn('+',20);
tlijn('=',45);
</code></pre>
<h3 id="return-en-functietype">Return en functietype</h3>
<p>Als we een resultaat van een functie willen bekomen, dan wordt dit
doorgegeven met de <code>return</code> opdracht. We moeten dan wel aangeven wat
voor soort waarde met de return doorgegeven wordt. Daarom plaatsen we
een type voor de functienaam. Dus niet alleen variabelen en constanten
zijn van een bepaald type, ook functies worden met een type verbonden.
Als we de functieoproep in een uitdrukking plaatsen, dan wordt de oproep
vervangen door het resultaat van de functie.</p>
<pre><code>int eigen_abs(int a) /* int : functietype */
{
   if (a &lt; 0)
      return( -a );
   else
      return( a );
}

int main()
{
   int x,y,z;

   printf(&quot;geef 2 getallen:&quot;);
   scanf(&quot;%d %d&quot;,&amp;x,&amp;y);
   z = eigen_abs(x) + eigen_abs(y);
   printf(&quot;%d\n&quot;, z);

   return 0;
}
</code></pre>
<p>Het functietype mag niet weggelaten worden. Als we helemaal geen
resultaat willen teruggeven, dan moet dit expliciet aangegeven worden
met het woord <code>void</code> (leeg). Hetzelfde kunnen we doen als een functie
geen parameters ontvangt. We plaatsen dan niets tussen de functiehaken.
Een functie die geen parameters ontvangt en geen resultaat geeft
schrijven we zo:</p>
<pre><code>void doe()
{

}
</code></pre>
<p>We geven nu nog een voorbeeld met een ander functietype.</p>
<pre><code>float gemiddelde(float a, float b, float c)
{
   return( (a + b + c)/3 );
}
</code></pre>
<p>We moeten hier toch nog zeggen dat het niet mogelijk is om een functie
een doorgegeven variabele te laten wijzigen.</p>
<pre><code>void verhoog(int a)
{
   a++;
}

void main()
{
   int b = 1;

   verhoog(b);
}
</code></pre>
<p>Omdat de functie <code>verhoog()</code> met een kopie van <code>b</code> werkt, wordt alleen
<code>a</code> verhoogd. De variabele <code>b</code> blijft hier ongewijzigd. Men spreekt in
dit geval van waardeparameter.</p>
<h3 id="de--operator">De <code>&amp;</code> operator</h3>
<p>De <code>&amp;</code> operator bij een variabelenaam geeft het adres van die variabele.
We kunnen nagaan waar een variabele zich in het geheugen bevindt.</p>
<pre><code>v = 12;
printf(&quot;het getal %d staat in adres %u\n&quot;,
                    v, &amp;amp;v);
</code></pre>
<p>Resultaat:</p>
<pre><code>het getal 12 staat in adres 65502
</code></pre>
<p>Met het volgende voorbeeld zien we dat twee variabelen met dezelfde naam
een verschillend adres hebben. Het zijn dus verschillende variabelen.</p>
<pre><code>void fu()
{
   int a = 7;

   printf(&quot;fu: a = %d &amp;a = %u\n&quot;, a, &amp;a);
}

int main()
{
   int a = 5;

   printf(&quot;main: a = %d &amp;a = %u\n&quot;, a, &amp;a);
   fu();

   return 0;
}
</code></pre>
<p>Resultaat:</p>
<pre><code>main: a = 5 &amp;a = 65502
fu: a = 7 &amp;a = 65496
</code></pre>
<h3 id="pointers-en-adresparameters">Pointers en adresparameters</h3>
<p>De volgende functie is bedoeld om de inhoud van twee variabelen te
verwisselen. Deze versie is niet correct omdat alleen de kopies van de
doorgegeven variabelen verwisseld worden en niet de originelen.</p>
<pre><code>void verwissel(int u, int v)
{
   int   help;

   help = u;
   u = v;
   v = help;
}

int main()
{
   int   x = 3, y = 4;

   printf(&quot;x: %d, y %d\n&quot;, x, y);
   verwissel(x,y);
   printf(&quot;x: %d, y %d\n&quot;, x, y);

   return 0;
}
</code></pre>
<p>De variabelen <code>x</code> en <code>y</code> blijven dus ongewijzigd. We kunnen hier ook
geen return gebruiken omdat deze slechts 1 waarde teruggeeft. De
oplossing is als volgt: we geven als actuele parameters niet de inhoud
van <code>x</code> en <code>y</code> door, maar wel de adressen van <code>x</code> en <code>y</code>. Dit kunnen we
doen met de adres operator. Dit betekent dan wel dat we als formele
parameters in de functie <code>verwissel()</code> variabelen moeten voorzien, die
in staat zijn om adressen op te slaan. Deze soort variabelen noemt men
pointers.</p>
<p>Vooraleer we pointers uitleggen, verklaren we eerst de declaratie van
een gewone variabele. Bij de declaratie</p>
<pre><code>int   getal = 123;
</code></pre>
<p>is getal van het type <code>int</code> en is <code>&amp;getal</code> het adres van deze variabele.</p>
<p>!&lt;&gt;</p>
<p>De inhoud van getal is 123 en het adres van getal is 1000. De
uitdrukking <code>&amp;getal</code> is van het pointertype en stelt een constante voor.
We kunnen deze constante toekennen aan een pointervariabele:</p>
<pre><code>ptr = &amp;getal;
</code></pre>
<p>Dit wil zeggen dat <code>ptr</code> moet gedeclareerd worden als een
pointervariabele.</p>
<pre><code>int *ptr;
</code></pre>
<p>Dit wordt zo gelezen: <code>ptr</code> is een pointer naar een <code>int</code>. De operator
<code>\*</code> betekent hier pointer. De variabele <code>ptr</code> kan als volgt gebruikt
worden:</p>
<pre><code>ptr = &amp;getal;
a = *ptr;
</code></pre>
<p>De eerste opdracht plaatst het adres van getal in <code>ptr</code>. De tweede
opdracht neemt de inhoud van de <code>int</code> variabele die aangewezen wordt
door <code>ptr</code> en plaatst deze waarde in <code>a</code>. De variabele <code>a</code> krijgt dus de
waarde van <code>getal</code>. De <code>\*</code> operator is hier de operator voor indirecte
verwijzing.</p>
<p>De situatie van deze variabelen kan zo weergegeven worden:</p>
<p>!&lt;&gt;</p>
<p>Bij de declaratie wordt vastgelegd dat <code>ptr</code> een pointer naar <code>int</code> is.
We kunnen dus wel het adres van een <code>int</code> variabele in <code>ptr</code> plaatsen
maar niet het adres van een char variabele.</p>
<p>De functie <code>verwissel()</code> is nu herschreven met pointers als formele
parameter:</p>
<pre><code>void verwissel(int *u, int *v)
{
   int   help;

   help = *u;
   *u = *v;
   *v = help;
}

int main()
{
   int   x = 3, y = 4;

   verwissel(&amp;x,&amp;y);
   printf(&quot;x: %d, y %d\n&quot;, x, y);

   return 0;
}
</code></pre>
<p>Wanneer <code>verwissel()</code> opgeroepen wordt, krijgt de variabele <code>u</code> als
inhoud het adres van <code>x</code> en <code>v</code> het adres van <code>y</code>. De inhoud van deze
twee aangewezen variabelen wordt dan verwisseld.</p>
<p>We kunnen parameters als volgt samenvatten. Als we informatie doorgeven,
kunnen we de inhoud van die variabele doorgeven:</p>
<pre><code>// waarde:
int x;

fun1( x );
</code></pre>
<p>Ofwel kunnen we het adres van die variabele doorgeven:</p>
<pre><code>// adres:
int x;

fun2( &amp;x );
</code></pre>
<p>In het eerste geval wordt de waarde van de variabele doorgegeven en is
er sprake van <em>call by value</em>. In het tweede geval wordt het adres van
de variabele doorgegeven en is er sprake van <em>call by reference</em>. Merk
op dat in het tweede geval (adres doorgeven) het mogelijk is om in de
functie de inhoud van de variabele, waarvan het adres is doorgegeven, te
wijzigen.</p>
<h2 id="geheugenklassen">Geheugenklassen</h2>
<p>Elke variabele in een C programma behoort tot een geheugenklasse. Deze
klasse bepaalt de levensduur en de bereikbaarheid van de variabele. Voor
elke variabele kiezen we een gepaste klasse.</p>
<p>De klasse waartoe een variabele behoort, kunnen we bepalen met een
sleutelwoord bij de declaratie. De volgende sleutelwoorden worden hier
besproken: <code>auto</code>, <code>extern</code>, <code>static</code> en <code>register</code>. Een van deze
woorden kan voor het type geplaatst worden bij een declaratie.</p>
<p>geheugenklasse + type + variabelenaam</p>
<h3 id="automatische-variabelen">Automatische variabelen</h3>
<p>Dit zijn alle variabelen binnen een functie. We kunnen deze variabelen
ook aanduiden met de term lokale variabelen. De ruimte voor deze
variabelen en ook voor de formele parameters wordt gereserveerd op de
stack. Vermits de stack een beperkte geheugenruimte omvat, moeten we de
hoeveelheid lokale variabelen beperken.</p>
<pre><code>void fu()
{
   int klad;

   klad = 1;
}
</code></pre>
<p>Deze variabelen bestaan alleen tijdens de uitvoering van de functie. Dit
betekent dat er bij de start van de functie geheugen wordt gereserveerd
voor de automatische variabelen. Dit geheugen wordt terug vrijgegeven
bij het verlaten van de functie. We zouden het woord auto kunnen
gebruiken, maar dit wordt altijd weggelaten. Variabelen binnen een
functie gedeclareerd zonder een geheugenklasse zijn altijd automatisch
of lokaal.</p>
<p>Het is duidelijk dat we geen lokale variabele kunnen gebruiken voor
gegevens op te slaan die tijdens de hele uitvoering van het programma
moeten blijven bestaan.</p>
<h3 id="externe-variabelen">Externe variabelen</h3>
<p>De term <code>extern</code> wordt bij gebruikt voor de globale variabelen. Hiermee
bedoelen we de variabelen die buiten de functies gedeclareerd worden.</p>
<p>Het woord <code>extern</code> kan bij een declaratie buiten een functie voorkomen.
We hebben hier te maken met een verwijzing en geen geheugenreservatie.</p>
<pre><code>extern int waarde;   /* geen geheugen allocatie */

void fu()
{
   waarde = 3;
}
</code></pre>
<p>Hier wordt aangegeven dat de variabele <code>waarde</code> in een ander bestand
gedeclareerd is. In C kunnen we met meerdere programmabestanden werken
die gemeenschappelijke variabelen hebben.</p>
<h3 id="static-variabele"><code>static</code> variabele</h3>
<p>Hiermee bedoelen we variabelen die altijd bestaan, ook al staat de
declaratie binnen een functie. De externe variabelen zijn statisch omdat
ze altijd bestaan tijdens de levensduur van het programma.</p>
<h4 id="gebruik-static-binnen-functie">Gebruik <code>static</code> binnen functie</h4>
<p>We geven een voorbeeld.</p>
<pre><code>void probeer()
{
   int  tijdelijk = 1;
   static int altijd = 1;

   printf(&quot;tijdelijk %d , altijd %d\n&quot;,
   tijdelijk++, altijd++);
}

int main()
{
   int i;

   for (i=1; i &lt; 10; i++)
   {
      printf(&quot;%d :&quot;, i);
      probeer();
   }

   return 0;
}
</code></pre>
<p>De functie <code>probeer()</code> heeft twee variabelen <code>tijdelijk</code> en <code>altijd</code>. De
variabele <code>tijdelijk</code> is automatisch, ze bestaat enkel tijdens de
uitvoering van <code>probeer()</code>. De variabele <code>altijd</code> is statisch en bestaat
tijdens de hele uitvoering van het programma. De variabele <code>tijdelijk</code>
krijgt de initialisatiewaarde bij elke oproep van <code>probeer()</code>. De
variabele altijd wordt slechts eenmaal geÃ¯nitialiseerd, namelijk bij de
start van het programma.</p>
<p>Het woord <code>static</code> maakt van een tijdelijke variabele een variabele die
altijd bestaat. Dit kan soms handig zijn, maar het kan ook ongewenste
zijeffecten leveren.</p>
<h4 id="gebruik-static-buiten-functie">Gebruik <code>static</code> buiten functie</h4>
<p>Hiermee creÃ«ren we een externe variabele die enkel bekend is binnen het
bestand. Het volgende voorbeeld maakt dit duidelijk.</p>
<pre><code>#include &lt;header.h&gt;

int   a;
static int b;

static void fu1()
{
   fu2();
}

int main()
{
   fu1();
   fu3();

   return 0;
}

#include &lt;header.h&gt;

void fu3()
{
   printf(&quot;%d\n&quot;,a);
}

void fu2()
{
   fu3();
}
</code></pre>
<p>Met behulp van de <code>#include</code> aanwijzing wordt het bestand <code>header.h</code>
ingelast in bestand 1 en bestand 2. Deze bevat de volgende tekst:</p>
<pre><code>void fu2();
void fu3();

extern int a;
</code></pre>
<p>Dit zijn aanwijzingen hoe de functies <code>fu2()</code>, <code>fu3()</code> en de variabele
<code>a</code> gebruikt moeten worden. De notatie voor de functies noemt men een
functieprototype. Hierdoor is het mogelijk dat de compiler een
foutmelding geeft als een functie uit een ander bestand, verkeerd
opgeroepen wordt. De prototypes worden ook ingelast in het bestand waar
de functies vastgelegd worden. Hierdoor wordt gegarandeerd dat de
prototypes precies overeenstemmen met de functies zelf. De twee
bestanden worden afzonderlijk gecompileerd en daarna samengevoegd in de
linkfase.</p>
<p>In het voorbeeld is de variabele <code>a</code> is bekend in <code>main()</code>, <code>fu1()</code>,
<code>fu2()</code> en <code>fu3()</code>. De variabele <code>b</code> is alleen bekend in <code>main()</code> en
<code>fu1()</code>.</p>
<p>Tot slot geven we nog een overzicht dat al de geheugenklassen weergeeft.</p>
<p>+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+
|                | soort klasse   | woord          | levensduur     | bereik         |
+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+
| binnen functie | automatisch    | <code>auto</code>         | tijdelijk      | lokaal         |
|                |                |                |                |                |
|                | register       | <code>register</code>     | tijdelijk      | lokaal         |
|                |                |                |                |                |
|                | statisch       | <code>static</code>       | altijd         | lokaal         |
+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+
| buiten functie | extern         | <code>extern</code>       | altijd         | in alle        |
|                |                |                |                | bestanden      |
|                | extern static  | <code>static</code>       | altijd         |                |
|                |                |                |                | in 1 bestand   |
+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+</p>
<h2 id="arrays-en-pointers">Arrays en pointers</h2>
<p>Arrays zijn variabelen die meerdere waarden van een zelfde soort kunnen
opslaan. Pointers zijn verwijzingen naar andere variabelen. We
behandelen eerst arrays en daarna het verband met pointers.</p>
<h3 id="array-voorbeelden">Array voorbeelden</h3>
<pre><code>int getal[10];
float r[100];
char t[20];
</code></pre>
<p>Elk van deze variabelen is een array. De array getallen bevat 10
elementen:</p>
<pre><code>getal[0], getal[1], ... , getal[9]
</code></pre>
<p>De index die gebruikt wordt om de elementen te bereiken, start bij 0 en
loopt tot het aantal elementen - 1. We kunnen dus niet zelf een bereik
voor de index kiezen zoals in Pascal. Het volgende voorbeeld toont hoe
arrays gebruikt kunnen worden.</p>
<pre><code>#define DIM 10

int main()
{
   int som, i, getallen[DIM];

   for (i=0; i&lt;DIM; i++)
   {
      scanf(&quot;%d&quot;,&amp;getallen[i]);
   }
   printf(&quot;dit zijn de getallen\n&quot;);
   for (i=0; i&lt;DIM; i++)
   {
      printf(&quot;%5d&quot;,getallen[i]);
   }
   printf(&quot;\n&quot;);
   for (i=0, som=0; i&lt;DIM; i++)
   {
      som += getallen[i];
   }
   printf(&quot;het gemiddelde is %d\n&quot;,som/DIM);
}
</code></pre>
<h3 id="initialisatie-van-arrays">Initialisatie van arrays</h3>
<p>Net zoals enkelvoudige variabelen kunnen ook arrays geÃ¯nitialiseerd
worden. Dit kan alleen bij externe en statische arrays.</p>
<pre><code>/* dagen per maand */
int dagen[12] = {31,28,31,30,31,30,31,31,30,31,30,31};

int main()
{
   int i;

   for (i=0; i&lt;12; i++)
   {
      printf(&quot;%d dagen in maand %d\n&quot;,dagen[i],i+1);
   }

   return 0;
}
</code></pre>
<p>De waarden waarmee de array gevuld wordt, worden tussen accolades
geplaatst. Indien er te weinig waarden zijn, dan worden de laatste
elementen van de array met 0 gevuld. In de extern verwijzing binnen
<code>main()</code> mag de afmeting van de array weggelaten worden.</p>
<p>Hier is een andere versie:</p>
<pre><code>/* dagen per maand */
int dagen[] = {31,28,31,30,31,30,31,31,30,31,30,31};

int main()
{
   int i;

   for (i=0; i&lt;sizeof(dagen)/sizeof(int); i++)
   {
      printf(&quot;%d dagen in maand %d\n&quot;,dagen[i],i+1);
   }
   return 0;
}
</code></pre>
<p>In deze versie is de lengte van de array weggelaten. De lengte wordt nu
bepaald door het aantal getallen tussen accolades. De lengte mag alleen
maar weggelaten worden als de array geÃ¯nitialiseerd wordt.</p>
<h3 id="verband-tussen-pointers-en-arrays">Verband tussen pointers en arrays</h3>
<p>De arraynaam is een pointer naar eerste element. Dit verband
verduidelijken we met een voorbeeld.</p>
<pre><code>int rij[20];
</code></pre>
<p>Bij deze array is <code>rij\[0\]</code> het eerste element. Het adres hiervan is
<code>&amp;rij\[0\]</code>. Dit kan ook korter geschreven worden: <code>rij</code> en <code>&amp;rij\[0\]</code>
zijn hetzelfde. Ze duiden allebei het adres van de array aan. Het zijn
allebei pointerconstanten.</p>
<p>In het volgende voorbeeld wordt er met pointers gerekend.</p>
<pre><code>int main()
{
   int getallen[4], *pget, i;
   char tekens[4], *ptek;

   pget = getallen;
   ptek = tekens;
   for (i=0; i&lt;4; i++)
   {
      printf(&quot;pointers + %d: %u %u\n&quot;,
         i, pget + i, ptek + i);
   }
   return 0;
}
</code></pre>
<p>De eerste toekenning plaatst het adres van de array getallen in de
pointervariabele <code>pget</code>. De tweede toekenning doet een gelijkaardige
bewerking. In de <code>printf()</code> opdracht wordt de lusteller <code>i</code> opgeteld bij
de inhoud van de pointers. Dit resultaat komt op het scherm:</p>
<pre><code>pointers + 065486 65498
pointers + 165488 65499
pointers + 265490 65500
pointers + 365492 65501
</code></pre>
<p>De eerste regel geeft de adressen van de eerste elementen van de arrays.
De volgende regel geeft de adressen van de tweede elementen enzovoort.
We zien dus het volgende: als we de inhoud pointer verhogen met 1, dan
wordt het adres, dat in de pointer variabele wordt opgeslagen, verhoogd
met de breedte van het aangeduide element. De pointer pget wijst naar
<code>int</code>, <code>int</code> is 2 bytes breed dus wordt er 2 opgeteld bij de inhoud van
<code>pget</code>. Dezelfde regel kunnen we toepassen voor de pointer <code>ptek</code>. Die
wordt verhoogd met 1 ( breedte <code>char</code> ).</p>
<p>De array <code>getal</code> kan zo voorgesteld worden:</p>
<p>!&lt;&gt;</p>
<p><code>getal + 2</code> en <code>&amp;getal\[2\]</code> stellen beide hetzelfde adres voor.</p>
<p><code>\*(getal + 2)</code> en <code>getal\[2\]</code> stellen beide dezelfde waarde voor.</p>
<p>Opgelet: <code>\*getal + 2</code> is de waarde van het eerste element verhoogd met
2. Deze uitdrukking is dus niet hetzelfde als <code>\*(getal + 2)</code>. De haken
zijn nodig omdat <code>\*</code> een hogere prioriteit heeft dan <code>+</code>.</p>
<p>Hetzelfde probleem ontstaat bij de interpretatie van <code>\*p++</code> . Is dit
<code>(\*p)++</code> of <code>\*(p++)</code> ? Het antwoord is de tweede uitdrukking omdat
<code>\*</code> en <code>++</code> dezelfde prioriteit hebben en unaire operatoren van rechts
naar links groeperen.</p>
<h3 id="arrays-als-functieparameters">Arrays als functieparameters</h3>
<p>Als formele parameter kunnen we arrays gebruiken. De afmeting van de
array mag weggelaten worden.</p>
<pre><code>void druk(int rij[])
{

}

int main()
{
   int reeks[50];

   druk(reeks);

   return 0;
}
</code></pre>
<p>Bij formele parameters is <code>int rij\[\]</code> een pointer variabele, geen
array variabele. We geven hier niet de inhoud van de array door, maar
wel het adres. Dus <code>int rij\[\]</code> en <code>int \*rij</code> zijn hetzelfde als
formele parameter.</p>
<p>We kunnen de lengte van de array doorgeven:</p>
<pre><code>void druk(int rij[], int lengte)
{
   int i;

   for (i=0; i&lt;lengte; i++)
   {
      printf(&quot;%d\n&quot;, rij[i]);
   }
}
</code></pre>
<p>Deze versie doet identiek hetzelfde, alleen de toegang tot de array is
gewijzigd:</p>
<pre><code>void druk(int rij[], int lengte)
{
   int i;

   for (i=0; i&lt;lengte; i++)
   {
      printf(&quot;%d\n&quot;, *(rij + i) );
   }
}
</code></pre>
<p>En tot slot de snelste versie:</p>
<pre><code>void druk(int rij[], int lengte)
{
   register int*p, *peinde;

   p = rij;/* bew 1 */
   peinde = &amp;rij[lengte];
   while (peinde - p &gt;0)/* bew 5 */
   {
      printf(&quot;%d\n&quot;, *p );/* bew 2 */
      p++;/* bew 4 */
   }
}
</code></pre>
<p>In deze laatste versie wordt de pointervariabele <code>p</code> gebruikt om de
elementen van de array te bereiken. Met de <code>++</code> operator wijst <code>p</code>
telkens naar het volgende element in de array. De herhaling stopt als
<code>p</code> het eerste adres aanwijst dat niet tot de array behoort.</p>
<p>Hier is een samenvatting van de pointerbewerkingen:</p>
<ul>
<li>â€‹1. toekenning</li>
</ul>
<p>Een adres wordt toegekend aan een pointervariabele.</p>
<ul>
<li>â€‹2. waarde ophalen</li>
</ul>
<p>De <code>\*</code> bewerking vindt de waarde die door de pointer wordt aangeduid.</p>
<ul>
<li>â€‹3. een pointeradres nemen</li>
</ul>
<p>De pointer int <code>\*p</code> bevindt zich op adres <code>&amp;p</code>. Dit kan dienen als
actuele parameter voor een functie die de doorgegeven pointer wijzigt.</p>
<ul>
<li>â€‹4. een pointer verhogen</li>
</ul>
<p>Na deze bewerking wijst de pointer naar het volgende element.</p>
<ul>
<li>â€‹5. het verschil tussen 2 pointers</li>
</ul>
<p>Dit geeft het aantal elementen dat zich tussen de 2 aangeduide posities
bevindt.</p>
<h3 id="arrays-met-meerdere-dimensies">Arrays met meerdere dimensies</h3>
<p>Bij de declaratie plaatsen we meerdere indexen na de arraynaam. Elke
index staat apart tussen de rechte haken.</p>
<pre><code>double matrix[3][4];
</code></pre>
<p>In het volgende voorbeeld zien we de initialisatie en het gebruik van
een meerdimensionele array.</p>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
   static double matrix[3][4] =
   {
      { 2,5,9,7 },
      { 8,1,3,4 },
      { 10,5,45,23 }
   };
   int i,j;

   for (i=0; i&lt;3; i++)
   {
      for (j=0; j&lt;4; j++)
      {
         printf(&quot;%5.2f &quot;, matrix[i][j] );
      }
      printf(&quot;\n&quot;);
   }
   return 0;
}
</code></pre>
<p>De variabele matrix kunnen we voorstellen als een matrix die bestaat uit
3 rijen met elk 4 elementen. De variabele wordt rij per rij
geÃ¯nitialiseerd (alleen statische en externe arrays kunnen
geÃ¯nitialiseerd worden). De getallen 2, 5, 9 en 7 komen terecht in de
eerste rij. We kunnen ze terugvinden in de elementen <code>matrix\[0\]\[0\]</code>,
<code>matrix\[0\]\[1\]</code>, <code>matrix\[0\]\[2\]</code> en <code>matrix\[0\]\[3\]</code>. Op
dezelfde wijze worden de twee andere rijen gevuld. Het is ook mogelijk
om de binnenste paren accolades, die telkens een rij getallen afsluiten,
weg te laten. Dit is identiek in werking maar is minder overzichtelijk.</p>
<h3 id="pointers-naar-functies">Pointers naar functies</h3>
<p>Zoals reeds vermeld moet bij de declaratie van een pointer aangegeven
worden naar welk type deze pointer wijst. We kunnen in de taal C ook een
functietype gebruiken als het aangewezen type. We geven een voorbeeld:</p>
<pre><code>int (*pf)(int a,int b);
</code></pre>
<p>De variabele <code>pf</code> is een pointer die wijst naar een functie die 2 <code>int</code>
verwacht en een <code>int</code> als resultaat. Deze variabele krijgt met een
toekenning een waarde.</p>
<pre><code>int fu(int a,int b)
{
   return( a + b);
}

pf = fu;
</code></pre>
<p>De pointer <code>pf</code> krijgt als waarde het adres van de functie <code>fu</code>. We
kunnen de aangewezen functie oproepen via de pointervariabele.</p>
<pre><code>c = (*pf)(1,2);
</code></pre>
<h2 id="tekenstrings-en-stringfunctions">Tekenstrings en stringfunctions</h2>
<h3 id="strings-definiÃ«ren">Strings definiÃ«ren</h3>
<p>Een string is een opeenvolging van <code>char</code> constanten, waarbij het einde
aangeduid wordt door 0. We kunnen een stringconstante samenstellen met 2
aanhalingstekens:</p>
<pre><code>&quot;dit is een string&quot;
</code></pre>
<p>Deze constante heeft een dubbele functie: ze zorgt voor opslag van de
tekens in het geheugen en ze fungeert als constante van het type pointer
naar <code>char</code>. In het volgende voorbeeld wordt het adres van een
stringconstante opgeslagen in een pointervariabele.</p>
<pre><code>char *pstr;

pstr = &quot;dit is een string&quot;;
printf(&quot;%s&quot;,pstr);
</code></pre>
<p>Via initialisatie wordt een stringconstante opgeslagen in een <code>char</code>
arrayvariabele. Tussen de rechte haken hoeft geen afmeting vermeld te
worden.</p>
<pre><code>char str1[] = {'a','b','c','d','e','\0' };
</code></pre>
<p>ofwel</p>
<pre><code>char str1[] = &quot;abcde&quot;;
</code></pre>
<p>De lengte van array is 6: 5 tekens + 1 nul. Als we de naam <code>str1</code>
gebruiken, dan is dit een pointer naar het eerste element. Zo kunnen we
enkele gelijke uitdrukkingen opstellen:</p>
<p><code>str1</code> en <code>&amp;str1\[0\]</code></p>
<p><code>\*str1</code> en ``</p>
<p><code>\*(str1+2)</code> en <code>str\[2\]</code> en ``</p>
<p>Er is een verschil tussen de array en de pointer declaratie, maar wel
zijn het allebei geÃ¯nitialiseerde variabelen:</p>
<pre><code>char *ptekst = &quot;een&quot;;
char atekst[]= &quot;twee&quot;;
</code></pre>
<p>De variabele <code>ptekst</code> is een pointer die geÃ¯nitialiseerd wordt met het
adres van de string <code>&quot;een&quot;</code>. Deze string bevindt zich elders in het
geheugen. De variabele atekst is een array die geÃ¯nitialiseerd wordt met
de string <code>&quot;twee&quot;</code>. Dit betekent dat <code>atekst</code> plaats heeft voor 5
tekens. We kunnen de geheugenverdeling zo voorstellen:</p>
<p>!&lt;&gt;</p>
<p>We hebben de volgende overeenkomsten:</p>
<pre><code>&amp;ptekst ---&gt; 30
ptekst       120
*ptekst      'e'
ptekst[0]    'e'
atekst       34
*atekst      't'
atekst[0]    't'
</code></pre>
<p><code>ptekst</code> is een pointervariabele en kan dus gewijzigd worden; <code>atekst</code>
niet:</p>
<pre><code>while ( *ptekst != 0)
{
   putchar ( *ptekst++ );
}
</code></pre>
<p>Deze herhaling drukt alle tekens van de string op het scherm.</p>
<p><code>atekst</code> is een pointerconstante die wijst naar het eerste element van
de array. <code>atekst</code> kan niet gewijzigd worden.</p>
<pre><code>atekst++;  // FOUT
</code></pre>
<p>De inhoud van de array kan wel gewijzigd worden:</p>
<pre><code>atekst[0] = 'p';
</code></pre>
<h3 id="arrays-van-tekenstrings">Arrays van tekenstrings</h3>
<p>We declareren de volgende variabele:</p>
<pre><code>char *kleuren[3] ={ &quot;wit&quot;,
                    &quot;zwart&quot;, &quot;azuurblauw&quot; };
</code></pre>
<p>De variabele <code>kleuren</code> is een array van pointers die wijzen naar char
elementen. De pointers zijn elk geÃ¯nitialiseerd met het adres van een
string. De uitdrukkingen <code>kleuren\[0\]</code>, <code>kleuren\[1\]</code>, en
<code>kleuren\[2\]</code> zijn de 3 pointers. Als we er een <code>\*</code> bijplaatsen
krijgen we: <code>\*kleuren\[0\]</code> is de eerste letter van de eerste string.
In kleuren worden alleen adressen opgeslagen; de strings zelf worden
elders in het geheugen opgeslagen.</p>
<p>!&lt;&gt;</p>
<p>Deze variabele kan ook anders gedeclareerd worden. Het is nu een array
met 2 dimensies. De strings worden in de array zelf opgeslagen. Voor de
string <code>&quot;wit&quot;</code> betekent dit dat slechts een deel van de rij gebruikt
wordt. Een deel van de array blijft dus onbenut.</p>
<pre><code>char kleuren[3][11] ={ &quot;wit&quot;,
                    &quot;zwart&quot;, &quot;azuurblauw&quot; };
</code></pre>
<p>!&lt;&gt;</p>
<p>====Stringin- en uitgave</p>
<p>We creÃ«ren eerst plaats voor de in te lezen string.</p>
<pre><code>char *naam;

scanf(&quot;%s&quot;, naam);
</code></pre>
<p>Deze declaratie van naam levert een crash op; naam is een
pointervariabele, die geen waarde gekregen heeft. <code>scanf()</code> gebruikt de
inhoud van naam als adres om de ingelezen tekens op te slaan. Het
resultaat is dus onvoorspelbaar. Een betere declaratie is dit:</p>
<pre><code>char naam[81];
</code></pre>
<p>Stringin- en uitvoer doen we met de <code>gets()</code> en <code>puts()</code> functies.</p>
<pre><code>int main()
{
   char naam[20][81]; /* plaats voor 20 namen */
   int   i,n;

   n = 0;
   while (gets(naam[n]) != NULL)
   {
      n++;
   }
   for (i=0; i&lt;n; i++)
   {
      puts(naam[i]);
   }
}
</code></pre>
<p>Het programma leest een aantal strings in met <code>gets()</code> en geeft daarna
deze strings weer op het scherm. De functie <code>gets()</code> levert als
resultaat het adres van de ingelezen string. Als de voorwaarde <code>EOF</code>
(dit is end of file) voorkwam tijdens de ingave, is het resultaat 0.
Deze eigenschap wordt in het programma gebruikt om de herhaling van de
ingave stop te zetten. Let op de notatie <code>naam\[n\]</code>, dit is hetzelfde
als <code>&amp;naam\[n\]\[0\]</code>.</p>
<p>Er zijn een aantal verschillen ten opzichte van <code>printf(&quot;%s&quot;)</code> en
<code>scanf(&quot;%s&quot;)</code>. <code>gets()</code> leest alle ingegeven tekens in tot de return; de
return zelf wordt niet opgenomen in de string. <code>scanf(&quot;%s&quot;)</code> start de
string na de eerste whitespace (tab, newline of spatie) en stopt voor de
volgende whitespace. Dit kan gebruikt worden om woorden uit een regel in
te lezen. <code>puts()</code> doet altijd een newline op het einde van de string,
<code>printf()</code> alleen als <code>\n</code> vermeld wordt.</p>
<h3 id="enkele-stringfuncties">Enkele stringfuncties</h3>
<p>We bespreken enkele van de belangrijkste stringfuncties.</p>
<h4 id="strlen"><code>strlen()</code></h4>
<p>Deze functie berekent de lengte van een string in bytes.</p>
<pre><code>void pas(char *string, int lengte)
{
   if (strlen(string)&gt;lengte)
   {
      *(string + lengte) = '\0';
   }
}
</code></pre>
<p>De functie <code>pas()</code> kort een string in tot een gegeven lengte. Dit wordt
gedaan door een 0 in de string bij te plaatsen.</p>
<h4 id="strcat"><code>strcat()</code></h4>
<p>Deze functie voegt 2 strings samen.</p>
<pre><code>int main()
{
   char naam[80];

   gets(naam);
   strcat(naam,&quot; is een mooie naam\n&quot;);
   puts(naam);

   return 0;
}
</code></pre>
<p>De functie <code>strcat()</code> ontvangt 2 <code>char</code> pointers. De string aangeduid
door de eerste pointer wordt uitgebreid met de string aangeduid door de
tweede pointer. De eerste string moet voldoende plaats hebben, anders
worden andere variabelen overschreven.</p>
<h4 id="strcmp"><code>strcmp()</code></h4>
<p>Deze functie vergelijkt 2 strings. Als de strings identiek zijn, is het
resultaat 0, anders is het resultaat verschillend van 0.</p>
<pre><code>int main()
{
   char antw[40];

   puts(&quot;waar woonde Julia ?&quot;);
   gets(antw);
   if (strcmp(antw, &quot;Verona&quot;) == 0)
   {
      puts(&quot;goed&quot;);
   }
   else
   {
      puts(&quot;fout&quot;);
   }
   return 0;
}
</code></pre>
<h4 id="strcpy"><code>strcpy()</code></h4>
<p>Deze functie kopieert een string.</p>
<pre><code>char kopie[40],*p;
p = &quot;origineel&quot;;
strcpy(kopie,p);
</code></pre>
<p>In dit voorbeeld worden de letters van de string een voor een gekopieerd
naar de array <code>kopie</code>.</p>
<h3 id="argumenten-op-de-opdrachtregel">Argumenten op de opdrachtregel</h3>
<p>De argumenten die bij de programmastart worden doorgegeven, zijn
bereikbaar vanuit het programma. Hiervoor wordt <code>main()</code> voorzien met
twee formele parameters.</p>
<pre><code>int main(int argc, char *argv[])
{
   int i;

   for (i=0; i&lt;argc; i++)
   {
      printf(&quot;%s &quot;,argv[i]);
   }
   printf(&quot;\n&quot;);

   return 0;
}
</code></pre>
<p>De eerste parameter <code>argc</code> geeft aan hoeveel argumenten er bij de
programmastart meegegeven zijn. In dit aantal is de programmanaam
meegerekend. De tweede parameter <code>argv</code> is een tabel van pointers naar
<code>char</code>. Elke pointer wijst naar het eerste teken van een argumentstring.
Deze strings zijn afgesloten met een 0. <code>argv\[0\]</code> wijst naar de
programmanaam, <code>argv\[1\]</code> is het eerste argument, enzoverder. Het
gebruik van een pointertabel laat een variabel aantal argumenten toe.</p>
<h3 id="strings-sorteren">Strings sorteren</h3>
<p>Tot slot is hier nog een programmavoorbeeld, dat strings sorteert.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define SLEN 81
#define DIM 20
#define STOP&quot;&quot;

void strsort(char *strings[], int num)
{
   char *temp;
   int klein, zoek;

   for (klein=0; klein&lt;num-1; klein++)
   {
      for (zoek=klein+1; zoek&lt;num; zoek++)
      {
         if ( strcmp(strings[klein],strings[zoek]) &gt;0)
         {
            temp = strings[klein];
            strings[klein] = strings[zoek];
            strings[zoek] = temp;
         }
      }
   }
}

int main()
{
   static char ingave[DIM][SLEN]; /* array voor ingave */
   char *pstr[DIM];               /* pointer tabel */
   int tel = 0;
   int k;

   printf(&quot;geef strings in\n&quot;);
   printf(&quot;eindig met een lege string\n&quot;);
   while( tel&lt;DIM &amp;&amp; gets(ingave[tel]) != NULL
          &amp;&amp; strcmp(ingave[tel],STOP) != 0)
   {
      pstr[tel] = ingave[tel];
      tel++;
   }

   /* sorteer met pointers */
   strsort(pstr, tel);

   puts(&quot;\ndit is gesorteerd\n&quot;);
   for (k=0; k&lt;tel; k++)
   {
      puts(pstr[k]);
   }
}
</code></pre>
<p>Dit programma leest eerst een aantal strings in. De strings komen in de
tweedimensionele array ingave terecht. De herhaling van de ingave stopt
als er geen plaats meer is voor strings of als EOF optreedt of als er
een lege string ingegeven wordt. Tijdens de ingave wordt de pointertabel
<code>pstr</code> gevuld met het adres van elke string.</p>
<p>Met deze tabel <code>pstr</code> wordt het sorteren uitgevoerd. In plaats van
strings te kopiÃ«ren (veel tekens kopiÃ«ren) worden er pointers
gekopieerd. De pointertabel <code>pstr</code> wordt samen met het aantal strings
doorgegeven aan de functie <code>strsort()</code>. Deze functie start bij de eerste
string en gaat na of er verder nog strings zijn die kleiner zijn.
Kleiner betekent hier: komt eerst in de alfabetische rangschikking. Hier
wordt gebruik gemaakt van de eigenschap dat <code>strcmp()</code> iets zegt over de
alfabetische volgorde als de 2 strings verschillend zijn. De mogelijke
resultaten zijn:</p>
<pre><code>strcmp(&quot;a&quot;, &quot;a&quot;)    // geeft 0
strcmp(&quot;b&quot;, &quot;a&quot;)    //       1 (positief)
strcmp(&quot;a&quot;, &quot;b&quot;)    //      -1 (negatief)
</code></pre>
<p>Indien een kleinere string gevonden wordt, dan worden de pointers die
wijzen naar de eerste en de gevonden string verwisseld. Hetzelfde wordt
herhaald voor de tweede tot en met de voorlaatste string.</p>
<h3 id="overzicht-string-functies">Overzicht string functies</h3>
<p>De prototypes van de functies voor stringmanipulatie zijn terug te
vinden in de headerbestand <code>string.h</code>.</p>
<h4 id="strcpy-1"><code>strcpy()</code></h4>
<p>Kopieert string <code>src</code> naar <code>dest</code>.</p>
<p>Prototype:</p>
<pre><code>char *strcpy(char *dest, const char *src);
</code></pre>
<p>Geeft <code>dest</code> terug.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
   char string[10];
   char *str1 = &quot;abcdefghi&quot;;

   strcpy(string, str1);
   printf(&quot;%s\n&quot;, string);
   return 0;
}
</code></pre>
<h4 id="strncpy"><code>strncpy()</code></h4>
<p>Kopieert maximum maxlen tekens van <code>src</code> naar <code>dest</code>.</p>
<p>Prototype:</p>
<pre><code>char *strncpy(char *dest, const char *src, size_t maxlen);
</code></pre>
<p>Indien maxlen tekens gekopieerd worden, wordt geen nul teken achteraan
bijgevoegd; de inhoud van dest is niet met een nul beÃ«indigd.</p>
<p>Geeft <code>dest</code> terug.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
   char string[10];
   char *str1 = &quot;abcdefghi&quot;;

   strncpy(string, str1, 3);
   string[3] = '\0';
   printf(&quot;%s\n&quot;, string);
   return 0;
}
</code></pre>
<h4 id="strcat-1"><code>strcat()</code></h4>
<p>Voegt <code>src</code> bij <code>dest</code>.</p>
<p>Prototype:</p>
<pre><code>char *strcat(char *dest, const char *src);
</code></pre>
<p>Geeft <code>dest</code> terug.</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
   char destination[25];
   char *blank = &quot; &quot;, *c =
                        &quot;C++&quot;, *Borland = &quot;Borland&quot;;

   strcpy(destination, Borland);
   strcat(destination, blank);
   strcat(destination, c);

   printf(&quot;%s\n&quot;, destination);

   return 0;
}
</code></pre>
<h4 id="strncat"><code>strncat()</code></h4>
<p>Voegt maximum maxlen tekens van <code>src</code> bij <code>dest</code>.</p>
<p>Prototype:</p>
<pre><code>char *strncat(char *dest, const char *src, size_t maxlen);
</code></pre>
<p>Geeft <code>dest</code> terug.</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
   char destination[25];
   char *source = &quot; States&quot;;

   strcpy(destination, &quot;United&quot;);
   strncat(destination, source, 7);
   printf(&quot;%s\n&quot;, destination);

   return 0;
}
</code></pre>
<h4 id="strcmp-1"><code>strcmp()</code></h4>
<p>Vergelijkt een string met een andere</p>
<p>Prototype:</p>
<pre><code>int strcmp(const char *s1, const char *s2);
</code></pre>
<p>Geeft een waarde terug:</p>
<p><code>&lt; 0</code> indien <code>s1</code> kleiner dan <code>s2</code></p>
<p><code>== 0</code> indien <code>s1</code> gelijk is aan <code>s2</code></p>
<p><code>&gt; 0</code> indien <code>s1</code> groter is dan <code>s2</code></p>
<p>Voert een vergelijking met teken uit.</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
   char *buf1 = &quot;aaa&quot;;
   char *buf2 = &quot;bbb&quot;,
   char *buf3 = &quot;ccc&quot;;
   int ptr;

   ptr = strcmp(buf2, buf1);
   if (ptr &gt; 0)
   {
      printf(&quot;buffer 2 is greater than
                        buffer 1\n&quot;);    // ja
   }
   else
   {
      printf(&quot;buffer 2 is less than buffer 1\n&quot;);
   }
   ptr = strcmp(buf2, buf3);
   if (ptr &gt; 0)
   {
      printf(&quot;buffer 2 is greater than
                        buffer 3\n&quot;);
   }
   else
   {
      printf(&quot;buffer 2 is less than buffer
                        3\n&quot;);       // ja
   }

   return 0;
}
</code></pre>
<h4 id="strncmp"><code>strncmp()</code></h4>
<p>Vergelijkt maximum maxlen tekens van de ene string met de andere.</p>
<p>Prototype:</p>
<pre><code>int strncmp(const char *s1, const char *s2,
                        size_t maxlen);
</code></pre>
<p>Geeft een waarde terug:</p>
<p><code>&lt; 0</code> indien <code>s1</code> kleiner dan <code>s2</code></p>
<p><code>== 0</code> indien <code>s1</code> gelijk is aan <code>s2</code></p>
<p><code>&gt; 0</code> indien <code>s1</code> groter is dan <code>s2</code></p>
<p>Voert een vergelijking met teken (<code>signed char</code>) uit.</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
   char *buf1 = &quot;aaabbb&quot;, *buf2 =
                        &quot;bbbccc&quot;, *buf3 = &quot;ccc&quot;;
   int ptr;

   ptr = strncmp(buf2,buf1,3);
   if (ptr &gt; 0)
   {
      printf(&quot;buffer 2 is greater than
                        buffer 1\n&quot;);    // ja
   }
   else
   {
      printf(&quot;buffer 2 is less than buffer 1\n&quot;);
   }

   ptr = strncmp(buf2,buf3,3);
   if (ptr &gt; 0)
   {
      printf(&quot;buffer 2 is greater than
                        buffer 3\n&quot;);
   }
   else
   {
      printf(&quot;buffer 2 is less than buffer
                        3\n&quot;);       // ja
   }
   return(0);
}
</code></pre>
<h4 id="strchr"><code>strchr()</code></h4>
<p>Zoekt een teken <code>c</code> in <code>s</code>.</p>
<p>Prototype:</p>
<pre><code>char *strchr(const char *s, int c);
</code></pre>
<p>Geeft een pointer terug naar de eerste plaats waar het teken <code>c</code> in <code>s</code>
voorkomt; indien <code>c</code> niet voorkomt in <code>s</code>, geeft <code>strchr</code> <code>NULL</code> terug.</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
   char string[15];
   char *ptr, c = 'r';

   strcpy(string, &quot;This is a string&quot;);
   ptr = strchr(string, c);
   if (ptr)
   {
      printf(&quot;The character %c is at
                        position: %d\n&quot;, c,
                   ptr-string); // 12
   }
   else
   {
      printf(&quot;The character was not found\n&quot;);
   }
   return 0;
}
</code></pre>
<h4 id="strrchr"><code>strrchr()</code></h4>
<p>Zoekt de laatste plaats waar <code>c</code> in <code>s</code> voorkomt.</p>
<p>Prototype:</p>
<pre><code>char *strrchr(const char *s, int c);
</code></pre>
<p>Geeft een pointer terug naar de laatste plaats waar <code>c</code> voorkomt, of
<code>NULL</code> indien <code>c</code> niet voorkomt in <code>s</code>.</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
   char string[15];
   char *ptr, c = 'i';

   strcpy(string, &quot;This is a string&quot;);
   ptr = strrchr(string, c);
   if (ptr)
   {
      printf(&quot;The character %c is at
                        position: %d\n&quot;, c,
                   ptr-string); // 13
   }
   else
   {
      printf(&quot;The character was not found\n&quot;);
   }
   return 0;
}
</code></pre>
<h4 id="strspn"><code>strspn()</code></h4>
<p>Doorzoekt een string naar een segment dat is een subset van een reeks
tekens.</p>
<p>Prototype:</p>
<pre><code>size_t strspn(const char *s1, const char *s2);
</code></pre>
<p>Geeft de lengte van het initiÃ«le segment van <code>s1</code> dat volledig bestaat
uit tekens uit <code>s2</code>.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;alloc.h&gt;

int main()
{
   char *string1 = &quot;1234567890&quot;;
   char *string2 = &quot;123DC8&quot;;
   int length;

   length = strspn(string1, string2);
   printf(&quot;strings different at position
                        %d\n&quot;,length); // 3
   return 0;
}
</code></pre>
<h4 id="strcspn"><code>strcspn()</code></h4>
<p>Doorzoekt een string.</p>
<p>Prototype:</p>
<pre><code>size_t strcspn(const char *s1, const char *s2);
</code></pre>
<p>Geeft de lengte van het initiÃ«le segment van <code>s1</code> terug dat volledig
bestaat uit tekens niet in <code>s2</code>.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;alloc.h&gt;

int main()
{
   char *string1 = &quot;1234567890&quot;;
   char *string2 = &quot;747DC8&quot;;
   int length;

   length = strcspn(string1, string2);
   printf(&quot;strings intersect at position
                        %d\n&quot;, length); // 3

   return 0;
}
</code></pre>
<p>=====<code>strpbrk()</code></p>
<p>Doorzoekt een string voor de eerste plaats waar een willekeurig teken
uit de tweede string voorkomt.</p>
<p>Prototype:</p>
<pre><code>char *strpbrk(const char *s1, const char *s2);
</code></pre>
<p>Geeft een pointer terug naar de eerste plaats waar een van de tekens uit
<code>s2</code> in <code>s1</code> voorkomt. Indien geen van de <code>s2</code> tekens in <code>s1</code> voorkomen,
wordt <code>NULL</code> teruggegeven.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
   char *string1 = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
   char *string2 = &quot;onm&quot;;
   char *ptr;

   ptr = strpbrk(string1, string2);

   if (ptr)
   {
      printf(&quot;found first character:
                        %c\n&quot;,*ptr);// 'm'
   }
   else
   {
      printf(&quot;strpbrk didn't find
                        character in set\n&quot;);
   }
   return 0;
}
</code></pre>
<h4 id="strstr"><code>strstr()</code></h4>
<p>Zoekt de eerste plaats waar een substring in een andere string voorkomt.</p>
<p>Prototype:</p>
<pre><code>char *strstr(const char *s1, const char *s2);
</code></pre>
<p>Geeft een pointer terug naar het element in <code>s1</code> dat <code>s2</code> bevat (wijst
naar <code>s2</code> in <code>s1</code>), of <code>NULL</code> indien <code>s2</code> niet voorkomt in <code>s1</code>.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
   char *str1 = &quot;Borland International&quot;;
   char *str2 = &quot;nation&quot;, *ptr;

   ptr = strstr(str1, str2);
   printf(&quot;The substring is: %s\n&quot;,
                        ptr); // &quot;national&quot;
   return 0;
}
</code></pre>
<h4 id="strlen-1"><code>strlen()</code></h4>
<p>Berekent de lengte van een string.</p>
<p>Prototype:</p>
<pre><code>size_t strlen(const char *s);
</code></pre>
<p>Geeft het aantal tekens in <code>s</code> terug, de eindnul wordt niet meegeteld.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
   char *string = &quot;Linux&quot;;

   printf(&quot;%d\n&quot;, strlen(string)); // 5
   return 0;
}
</code></pre>
<h4 id="strtok">strtok()</h4>
<p>Zoekt in <code>s1</code> naar het eerste teken dat niet voorkomt in in <code>s2</code>.</p>
<p>Prototype:</p>
<pre><code>char *strtok(char *s1, const char *s2);
</code></pre>
<p><code>s2</code> definieert scheidingstekens. <code>strtok()</code> interpreteert de string
<code>s1</code> als een reeks tokens gescheiden door een reeks tekens uit <code>s2</code>.</p>
<p>Indien geen tokens gevonden worden in <code>s1</code>, wordt <code>NULL</code> teruggegeven.</p>
<p>Indien het token gevonden is , wordt een nulteken in <code>s1</code> geschreven
volgend op het token, en <code>strtok</code> geeft een pointer terug naar het
token.</p>
<p>Volgende oproepen van <code>strtok()</code> met <code>NULL</code> als eerste argument
gebruiken de vorige <code>s1</code> string, vanaf het laatst gevonden token.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char s[] =&quot;aze ry   iio sdf&quot;;
  char *p;

  p = strtok(s,&quot; &quot;);
  while(p != NULL)
  {
     printf(&quot;%s\n&quot;,p);
     p = strtok(NULL,&quot; &quot;);
  }

  return 0;
}
</code></pre>
<h2 id="structuren">Structuren</h2>
<h3 id="malloc-en-free"><code>malloc()</code> en <code>free()</code></h3>
<p>Met de functies <code>malloc()</code> en <code>free()</code> kan je blokken geheugen op
dynamische wijze reserveren en vrijgeven. Met <code>malloc()</code> doe je de
reservatie en met <code>free()</code> wordt een blok geheugen vrijgegeven. De
prototypes van beide functies zien er zo uit:</p>
<pre><code>void *malloc(size_t size);
void free(void *ptr);
</code></pre>
<p>De functie <code>malloc()</code> verwacht als parameter de grootte van het blok
geheugen in bytes. Als resultaat geeft de functie een pointer naar de
eerste byte van het blok terug. Een blok geheugen dat je zo gereserveerd
hebt, moet je met <code>free</code> teruggeven. Als je dat niet doet (vrijwillig of
onvrijwillig), is dat een fout. Er is dan sprake van een <em>geheugenlek</em>.
Met het commando <em>valgrind</em> in Linux kan je nagaan of er geheugenlekken
in een programma voorkomen.</p>
<p>Het volgende voorbeeld toont hoe je dynamisch een array van 100 <code>int</code>&rsquo;s
kan reserveren. Je moet wel de grootte van het blok geheugen berekenen
en aan <code>malloc()</code> doorgeven. In dit geval is dit <code>100 \* sizeof(100)</code>.
Je ziet in het voorbeeld dat het adres dat <code>malloc()</code> teruggeeft, met
een cast omgezet wordt van <code>void *</code> naar <code>int \*</code>.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  int *p = (int *) malloc(100 * sizeof(4));
  int   i;

  for (i=0; i&lt;100; i++)
  {
     p[i] = i*i;
  }

  free(p);
  return 0;
}
</code></pre>
<p>Het voordeel van de werkwijze in dit voorbeeld is de mogelijkheid om de
grootte van het blok geheugen pas te bepalen op het moment dat de
reservatie gebeurt. Hierdoor kan een programma zich aanpassen aan de
geheugenbehoefte van het moment zelf. Als je arrays met een vaste
afmeting declareert, heb je die flexibiliteit niet. Merk op dat de
handelswijze in het voorbeeld overeenkomt met de wijze waarop arrays in
Java worden gereserveerd. In Java is dat altijd dynamisch.</p>
<p>Een verschil tussen Java en C/C++ is het feit dat in Java de vrijgave
van blokken geheugen automatisch verloopt. Het dynamisch geheugen wordt
bijgehouden in een zone die men de heap noemt. Dit is geldig voor zowel
C/C++ als Java. In C moet je na gebruik het geheugen vrijgeven met
<code>free()</code>; in C++ doe je dat met de <code>delete</code> operator. In Java mag je
deze stap achterwege laten. In Java worden regelmatig alle blokken
geheugen opgespoord die niet meer in gebruik zijn. Deze blokken worden
dan automatisch vrijgegeven. Deze bewerking loopt in de achtergrond en
noemt men <em>garbage collection</em>. Je moet dus begrijpen dat de correct
werkende C/C++ programmaâ€™s geen geheugenlekken mogen hebben. Bij
langdurig lopende programmaâ€™s kunnen geheugenlekken een tekort aan
dynamisch geheugen veroorzaken. Dit leidt tot <code>malloc()</code> oproepen die
een <code>NULL</code> als resultaat teruggeven om te melden dat er geen geheugen
meer beschikbaar is. Dit kan pointerfouten veroorzaken.</p>
<h3 id="types-maken-met-typedef">Types maken met <code>typedef</code></h3>
<p>We bespreken eerst de mogelijkheid om aan zelf gedefinieerde types een
naam te geven. Dit bespaart schrijfwerk bij het declareren van
variabelen en parameters. Dit laat ook toe om globaal het type van een
soort gegeven te wijzigen. We creÃ«ren types <code>METER</code>, <code>VECTOR</code> en
<code>STRING</code> met behulp van <code>typedef</code>.</p>
<pre><code>typedef int METER;
typedef double VECTOR[3];
typedef char STRING[80];
</code></pre>
<p>Met <code>typedef</code> leggen we vast dat het nieuwe type <code>METER</code> overeenkomt met
het type <code>int</code>. Net zoals bij <code>#define</code> wordt het type <code>METER</code> in
hoofdletters geschreven. Dit is geen verplichting, maar wordt door veel
programmeurs toegepast om het onderscheid te maken tussen constanten,
types en variabelen. Met deze nieuwe types declareren we variabelen.</p>
<pre><code>METER afstand;
VECTOR vect1,vect2;
STRING tekst=&quot;abcdefghijklmnopqrstuvwxyz&quot;;
</code></pre>
<p>Een zelf gedefinieerd type kan ook bij functies gebruikt worden.</p>
<pre><code>void druk(STRING v)
{
   printf(&quot;dit is de string: %s\n&quot;, v);
}
</code></pre>
<p>Het is zo dat het gebruik van <code>typedef</code> de leesbaarheid van het
programma verbetert.</p>
<h3 id="structuur">Structuur</h3>
<p>Met een structuur kunnen we een type ontwerpen, dat gegevens van een
verschillende soort samenbrengt. We doen dit met het woord <code>struct</code>.</p>
<pre><code>struct boek
{
   char titel[40];
   char auteur[40];
   float prijs;
};
</code></pre>
<p>Deze declaratie creÃ«ert een structuur met de naam boek. Ze bestaat uit 2
<code>char</code> arrays en een <code>float</code>. Met deze structuur declareren we een
variabele.</p>
<pre><code>struct boek roman1;
</code></pre>
<p>Een variabele kan gedeclareerd worden met initialisatie.</p>
<pre><code>struct boek roman2 = {
&quot;De loteling&quot;,&quot;Conscience&quot;,399.5 };
</code></pre>
<p>De <code>roman2</code> bevat de velden <code>titel</code>, <code>auteur</code> en <code>prijs</code>. Het veld
<code>titel</code> krijgt de waarde <code>&quot;De loteling&quot;</code>, auteur wordt <code>&quot;Conscience&quot;</code> en
prijs wordt <code>399.5</code> .</p>
<p>We kunnen een structuur vastleggen als een nieuw type met <code>typedef</code>.</p>
<pre><code>typedef struct
{
   double x;
   double y;
} PUNT;
</code></pre>
<p>Merk op dat er geen structuurnaam, maar alleen een typenaam is. Met het
type <code>PUNT</code> declareren we enkele variabelen.</p>
<pre><code>PUNT p1,p2,p3;
</code></pre>
<p>Deze variabelen hebben elk de velden <code>x</code> en <code>y</code>, waarin een <code>double</code>
opgeslagen wordt. De toegang tot velden wordt getoond in de volgende
functie.</p>
<pre><code>PUNT helft(PUNT pa,PUNT pb)
{
   PUNT pc;

   pc.x = (pa.x + pb.x)/2;
   pc.y = (pa.y + pb.y)/2;
   return( pc );
}
</code></pre>
<p>Deze functie ontvangt 2 variabelen van het type <code>PUNT</code> en levert een
resultaat van hetzelfde type. We kunnen een veld bereiken door de
variabelenaam uit te breiden met een punt en de veldnaam.</p>
<pre><code>p1.x = 1;
p1.y = 2;
p2 = p1;/* x en y velden worden gekopieerd */
p3 = helft( p1, p2 );
</code></pre>
<p>Wanneer een structuurvariabele wordt toegekend aan een andere, wordt de
hele structuur gekopieerd. Dus elk veld van de ene variabele wordt
gekopieerd naar elk veld van de andere.</p>
<h3 id="arrays-van-structuren">Arrays van structuren</h3>
<p>We declareren polygoon als een array van 50 elementen van het type
<code>PUNT</code>.</p>
<pre><code>PUNT polygoon[50];
</code></pre>
<p>Dit zijn de velden van het eerste element van <code>polygoon</code>.</p>
<pre><code>polygoon[0].x
polygoon[0].y
</code></pre>
<p>Dit zijn de velden van het laatste element.</p>
<pre><code>polygoon[49].x
polygoon[49].y
</code></pre>
<p>Het volgende voorbeeld berekent de lengte van een polygoon als de som
van de afstand tussen de opeenvolgende punten.</p>
<pre><code>double afstand(PUNT pa, PUNT pb)
{
   double x,y;

   x = pa.x - pb.x;
   y = pa.y - pb.y;
   return( sqrt(x*x + y*y) );
}

lengte = 0;
for (i=0; i&lt;49; i++)
{
   lengte += afstand(polygoon[i], polygoon[i+1]);
}
</code></pre>
<p>Bij de oproep van <code>afstand()</code> zien we de notatie <code>polygoon\[i\]</code>. Deze
uitdrukking is van het type <code>PUNT</code> en dit komt overeen met de declaratie
van de formele parameters van <code>afstand()</code>.</p>
<h3 id="pointers-naar-structuren">Pointers naar structuren</h3>
<p>Net zoals een pointer naar een int type kunnen we een pointer declareren
die naar het type <code>PUNT</code> wijst.</p>
<pre><code>PUNT *p_ptr;
</code></pre>
<p>We zien dat door het gebruik van het type <code>PUNT</code> in plaats van de hele
structuurnotatie, de declaratie leesbaar blijft. Vermits <code>p_ptr</code> een
pointervariabele is, kan hierin het adres van een <code>PUNT</code> variabele
geplaatst worden.</p>
<pre><code>p_ptr = &amp;p1;
</code></pre>
<p>Om een veld van de aangewezen structuur te bereiken, schrijven we:</p>
<pre><code>(*p_ptr).x
</code></pre>
<p>Deze waarde is dezelfde als <code>p1.x</code> omdat <code>p_ptr</code> naar <code>p1 wijst. De haken zijn nodig omdat .</code> een hogere prioriteit heeft dan <code>\*</code>
. We schrijven dit in een andere vorm.</p>
<pre><code>p_ptr-&gt;x
</code></pre>
<p>De notatie <code>-&gt;</code> is dus een samentrekking van het sterretje en het punt.</p>
<p>In de functie <code>maaknul()</code> wordt geen structuur doorgegeven maar wel een
pointer naar een structuur. Dit is nodig omdat de <code>PUNT</code> variabele
waarvan het adres doorgegeven wordt aan de functie, gewijzigd wordt.</p>
<pre><code>void maaknul(PUNT *p)
{
   p-&gt;x = 0;
   p-&gt;y = 0;
}
</code></pre>
<p>Dit is het gebruik van de functie:</p>
<pre><code>PUNT p1,p2,p3;

maaknul( &amp;p1 );
maaknul( &amp;p2 );
maaknul( &amp;p3 );
</code></pre>
<h3 id="structuur-binnen-structuur">Structuur binnen structuur</h3>
<p>Het is mogelijk om als type voor een veld een zelf gedefinieerd type te
gebruiken.</p>
<pre><code>typedef struct
{
   int jaar;
   int maand;
   int dag;
} DATUM;

typdef struct
{
   DATUM van;
   DATUM tot;
} PERIODE;

PERIODE contract;
</code></pre>
<p>De variabele contract is van het type <code>PERIODE</code> en bestaat dus uit de
velden <code>van</code> en <code>tot</code>. Deze velden zijn op hun beurt structuren. Ze
bestaan uit de velden <code>jaar</code>, <code>dag</code> en <code>maand</code>.</p>
<p>De velden kunnen zo bereikt worden:</p>
<pre><code>contract.tot.jaar
contract.van.dag
</code></pre>
<p>Deze uitdrukkingen moeten we zo interpreteren:</p>
<pre><code>(contract.van).dag
</code></pre>
<p>De <code>.</code> operator groepeert dus van links naar rechts.</p>
<h3 id="unions">Unions</h3>
<p>Soms is het nodig om een bepaalde waarde onder verschillende vormen
bereikbaar te maken. Dit doen we met <code>union</code>.</p>
<pre><code>typedef union
{
   float fwaarde;
   long lwaarde;
} MASKER;
</code></pre>
<p>De schrijfwijze is identiek met die van <code>struct</code>. We hoeven maar het
woord <code>struct</code> te vervangen door <code>union</code>. De betekenis is anders. In
tegenstelling tot <code>struct</code> wordt hier maar een keer geheugenruimte
gereserveerd. In dit voorbeeld hebben de types <code>float</code> en <code>long</code>
dezelfde afmeting. Er wordt dus 4 bytes geheugen gereserveerd. Indien de
velden een verschillende afmeting hebben, dan bepaalt het grootste veld
de hoeveelheid gereserveerd geheugen.</p>
<pre><code>MASKER getal;
getal.fwaarde = 3.14159;
printf(&quot;voorstelling van %f in hex is %lx\n&quot;,
getal.fwaarde,getal.lwaarde);
</code></pre>
<p>Resultaat:</p>
<pre><code>voorstelling van 3.141590 in hex is 40490fcf
</code></pre>
<p>In dit voorbeeld wordt er voor <code>getal</code> 4 bytes gereserveerd. Dit
geheugen is bereikbaar met twee namen: <code>getal.fwaarde</code> en
<code>getal.lwaarde</code>. We plaatsen een float-constante in <code>getal</code> en daarna
toont <code>printf()</code> op welke wijze dit opgeslagen wordt.</p>
<h3 id="bitvelden">Bitvelden</h3>
<p>In sommige gevallen is het bereik van de werkelijke waarden van een veld
slechts een fractie van het maximale bereik. In dat geval is het
wenselijk om de velden te declareren op bitniveau.</p>
<pre><code>typedef struct
{
   unsigned int jaar:12;/* 0 - 4095*/
   unsigned int maand:4;/* 0 - 15*/
   unsigned int dag:5;/* 0 - 31*/
   unsigned int ongeveer:1;/* 0 - 1*/
} CDATUM;
</code></pre>
<p>Elk veld heeft nu een aangepast bereik. Dit verkrijgen we door na elke
veldnaam dubbele punt en bitbreedte bij te voegen. De veldbreedte in bit
mag niet groter zijn dan de woordbreedte van de computer. Als type voor
een bitveld mogen we alleen maar <code>unsigned</code> of <code>signed int</code> gebruiken.</p>
<p>De veldnaam mag weggelaten worden. Hiermee kan men ongebruikte bits
overslaan.</p>
<pre><code>struct metbits
{
   int i:2;
   unsigned j:5;
   int:4;
   int k:1;
   unsigned m:4;
} a,b,c;
</code></pre>
<p>De bitverdeling van <code>a</code>, <code>b</code> en <code>c</code> ziet er als volgt uit:</p>
<p>!&lt;&gt;</p>
<p>De bits 7 tot 10 zijn niet gebruikt.</p>
<h3 id="structuren-en-lijsten">Structuren en lijsten</h3>
<h4 id="zelfreferentiÃ«le-structuren">ZelfreferentiÃ«le structuren</h4>
<p>Dit zijn structuren die een of meerdere pointers bevatten die naar
eenzelfde soort structuur verwijzen. Deze structuren kunnen gebruikt
worden om gegevens op een dynamische manier te organiseren. Men maakt
bijvoorbeeld een ketting van zelfreferentiÃ«le structuren. Elk knooppunt
in deze ketting bevat 1 of meerdere gegevenselementen en bevat ook een
verwijzing naar het volgende knooppunt.</p>
<p>Hier is een voorbeeld van een zelfreferentiÃ«le structuur.</p>
<pre><code>struct knoop
{
   int  data;
   struct knoop *verder;
};
typedef struct knoop KNOOP;
</code></pre>
<p>Het veld <code>verder</code> in deze structuur verwijst naar een andere variabele
van het type s+truct knoop+. Het type <code>KNOOP</code> is een synoniem voor
<code>struct knoop</code>. We declareren enkele variabelen.</p>
<pre><code>KNOOP a,b,c;
</code></pre>
<p>Deze variabelen worden gevuld met gegevens.</p>
<pre><code>a.data = 1;
b.data = 2;
c.data = 3;
a.verder = b.verder = c.verder = NULL;
</code></pre>
<p>De velden verder worden voorlopig niet gebruikt en ze krijgen daarom de
waarde <code>NULL</code> (is gelijk aan 0). <code>NULL</code> wordt gebruikt om aan te geven
dat een pointer naar niets wijst. De huidige toestand stellen we
grafisch voor.</p>
<p>!&lt;&gt;</p>
<p>We maken nu de verbinding tussen <code>a</code>, <code>b</code> en <code>c</code>.</p>
<pre><code>a.verder = &amp;b;
b.verder = &amp;c;
</code></pre>
<p>!&lt;&gt;</p>
<p>Nu zijn de gegevens vanuit <code>a</code> bereikbaar.</p>
<pre><code>a.data--&gt;1
a.verder-&gt;data2
a.verder-&gt;verder-&gt;data3
</code></pre>
<h4 id="niet-gesorteerde-gebonden-lijsten">Niet gesorteerde gebonden lijsten</h4>
<p>De gegevensorganisatie die we daarnet besproken hebben, is een gebonden
lijst. We hebben het nu verder over functies die een niet gesorteerde
gebonden lijst manipuleren. We creÃ«ren een pointervariabele die naar het
eerste element wijst.</p>
<pre><code>KNOOP *p_eerste = NULL;
</code></pre>
<p>Deze variabele wordt met <code>NULL</code> geÃ¯nitialiseerd. Hiermee wordt
aangegeven dat de lijst leeg is.</p>
<pre><code>void voegbij(KNOOP **ptr, int getal)
{
   register KNOOP *nieuw_p;

   nieuw_p = (KNOOP *) malloc(sizeof(KNOOP));
   nieuw_p-&gt;data = getal;
   nieuw_p-&gt;verder = *ptr;
   *ptr = nieuw_p;
}
</code></pre>
<p>Deze functie kan zo gebruikt worden:</p>
<pre><code>voegbij( &amp;p_eerste, 4 );
voegbij( &amp;p_eerste, 5 );
voegbij( &amp;p_eerste, 6 );
</code></pre>
<p>Het eerste wat opvalt, is de formele parameter <code>KNOOP \*\*ptr</code>. Dit is
een dubbele pointer<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>: <code>ptr</code> heeft als inhoud het adres van een
pointer die wijst naar een <code>KNOOP</code>. De actuele parameter is van
hetzelfde type: <code>&amp;p_eerste</code> is het adres van een pointer. We geven niet
de inhoud van een pointer door, maar wel het adres van die pointer. Dit
is nodig omdat <code>p_eerste</code> in de functie gewijzigd moet kunnen worden.
Dit gebeurt als het eerste element van de lijst gewist wordt of als er
een ander element het eerste wordt.</p>
<p>Het eerste wat <code>voegbij()</code> doet, is het oproepen van <code>malloc()</code>. Dit is
een functie die geheugen reserveert. De functie verwacht als actuele
parameter het aantal benodigde bytes en levert als resultaat een pointer
naar het aangevraagde geheugen. In dit geval hebben we geheugen nodig
voor een element van het type <code>KNOOP</code>: dit is <code>sizeof(KNOOP)</code> bytes. Het
resultaat van <code>malloc()</code> is een pointer naar <code>char</code>. Dit adres wordt met
een cast omgezet tot een pointer naar <code>KNOOP</code>. Het bij te voegen getal
wordt in het veld <code>data</code> geplaatst. Het veld <code>verder</code> van het nieuwe
element moet nu wijzen naar het eerste element van de oude lijst.</p>
<pre><code>nieuw_p-&gt;verder = *ptr;
</code></pre>
<p>Het nieuwe element wijst dus naar het element dat vroeger door
<code>p_eerste</code> aangewezen werd. <code>ptr</code> bevat het adres van <code>p_eerste</code>. Dus
<code>\*ptr</code> is hetzelfde als de inhoud van <code>p_eerste</code>. Tot slot wordt
<code>p_eerste</code> gewijzigd.</p>
<p>Dit gebeurt onrechtstreeks:</p>
<pre><code>*ptr = nieuw_p;
</code></pre>
<p><code>p_eerste</code> wijst naar het nieuwe element en dit op zijn beurt wijst naar
de oude lijst.</p>
<p>Toestand voor het bijvoegen van het getal 5:</p>
<p>!&lt;&gt;</p>
<p>Toestand erna:</p>
<p>!&lt;&gt;</p>
<p>De inhoud van een lijst kan zichtbaar gemaakt worden met de functie
<code>druk()</code>.</p>
<pre><code>void druk(KNOOP *ptr)
{
   while (ptr != NULL)
   {
      printf(&quot;%d\n&quot;, ptr-&gt;data);
      ptr = ptr-&gt;verder;
   }
}
</code></pre>
<p>De functie wordt zo gebruikt:</p>
<pre><code>druk(p_eerste);
</code></pre>
<p>De formele parameter <code>ptr</code> is een kopie van de inhoud van <code>p_eerste</code>.
Deze kopie mag zonder meer gewijzigd worden zonder dat <code>p_eerste</code>
verandert.</p>
<p>De pointer doorloopt de hele lijst tot het einde bereikt is en drukt bij
elke herhaling een getal op het scherm.</p>
<p>Hier is een andere versie:</p>
<pre><code>void druk(KNOOP *ptr)
{
   if (ptr != NULL)
   {
      printf(&quot;%d\n&quot;, ptr-&gt;data);
      druk( ptr-&gt;verder );
   }
}
</code></pre>
<p>Deze versie werkt recursief. Dit wil zeggen dat <code>druk()</code> zichzelf
oproept. De functie drukt het getal, dat aangeduid wordt door <code>ptr</code> en
drukt dan de rest van de lijst door zichzelf nog eens op te roepen.</p>
<p>De volgende functie zoekt een getal in een lijst en veegt het uit als
het gevonden wordt.</p>
<pre><code>void veeguit(KNOOP **ptr; int getal)
{
   KNOOP **p1, *p2;

   /* zoeken */
   p1 = ptr;
   while ( *p1 != NULL &amp;&amp; (*p1)-&gt;data != getal)
   {
      p1 =&amp;amp;((*p1)-&gt;verder);
   }

   if (*p1 != NULL)/* gevonden */
   {
      /* uitvegen */
      p2 = *p1; /* bewaar adres gevonden element */
      *p1 = (*p1)-&gt;verder;
      free(p2); /* geheugenvrijgave */
   }
   else
      printf(&quot;niet gevonden\n&quot;)
}
</code></pre>
<p>Aan deze functie wordt het adres van <code>p_eerste</code> doorgegeven, omdat ook
hier <code>p_eerste</code> gewijzigd moet kunnen worden. Na het starten wordt een
kopie gemaakt naar <code>ptr</code>. Deze pointer wordt gebruikt om telkens op te
schuiven naar het volgende element tijdens het zoeken. Dit proces gaat
verder zolang het einde van de lijst niet bereikt is</p>
<pre><code>*p1 != NULL
</code></pre>
<p>en het getal niet gevonden is.</p>
<pre><code>(*p1)-&gt;data != getal
</code></pre>
<p>We zien telkens een <code>\*</code> voor <code>p1</code>. Dit is nodig omdat <code>p1</code> het adres
bevat van een <code>KNOOP</code> pointer. <code>\*p1</code> is dus een pointer naar <code>KNOOP</code>.</p>
<p>Tijdens de herhaling wordt <code>p1</code> gewijzigd: <code>p1</code> wijst dan naar het adres
van de pointer die wijst naar het volgende element.</p>
<p>Welke waarde krijgt <code>p1</code>?</p>
<pre><code>*p1                 // is adres huidige KNOOP element
(*p1)-&gt;verder       //    adres volgende KNOOP element
&amp;((p1)-&gt;verder)     //    adres van de pointer die het adres bevat van het volgende KNOOP element
</code></pre>
<p>Als de herhaling stopt en <code>\*p1</code> is <code>NULL</code>, dan is het einde van de
lijst bereikt en is het getal niet gevonden. In het andere geval moet
het gevonden element geschrapt worden.</p>
<p>Toestand voor het uitvegen van 5:</p>
<p>!&lt;&gt;</p>
<p>Dit is het uitvegen:</p>
<p>!&lt;&gt;</p>
<pre><code>veeguit( &amp;p_eerste, 5);
</code></pre>
<p>Toestand erna:</p>
<p>Na het vinden van het getal 5 wijst <code>\*p1</code> naar het gevonden <code>KNOOP</code>
element. Dit adres wordt opzijgezet in <code>p2</code> en de pointer <code>\*p1</code> krijgt
een nieuwe waarde. Hierdoor wordt het uit te vegen element overgeslagen.</p>
<p>Merk op dat er zich een speciale situatie voordoet als het eerste
element van de lijst geschrapt wordt. In dat geval doet de <code>while</code>
opdracht geen herhaling en bevat <code>p1</code> het adres van <code>p_eerste</code>. Hieruit
volgt dat <code>p_eerste</code> gewijzigd wordt.</p>
<h2 id="bestandsin--en-uitvoer">Bestandsin- en uitvoer</h2>
<p>In dit hoofdstuk worden een aantal functies beschreven voor het lezen en
schrijven van bestanden. Tenzij anders aangegeven zijn de prototypes
allemaal terug te vinden in stdio.h. De in- en uitvoerfuncties maken
deel uit van de ANSI standaard en maken gebruik van filepointers.
Meestal bestaan er op elk systeem ook nog functies die dichter bij de
hardware staan en specifiek zijn voor het desbetreffende operating
system. Om die reden worden deze functies hier niet beschreven.</p>
<p>====<code>fopen()</code></p>
<p>Vooraleer er gelezen of geschreven wordt van of naar een bestand, moet
een bestand geopend worden. Bij deze actie wordt een filepointer
geassocieerd met de file. In de overige functies moet een filepointer
meegegeven worden als referentie naar het bestand. In C zijn er twee
voorgedefinieerde filepointers voor in- en uitvoer: <code>stdin</code>, <code>stdout</code> en
<code>stderr</code>. Ze worden gebruikt voor de invoer van het toetsenbord, de
uitvoer naar het scherm en foutuitvoer.</p>
<p>Prototype:</p>
<pre><code>FILE *fopen(const char *filename, const char *mode);
</code></pre>
<p>Hierbij is <code>filename</code> een string die het pad van het bestand bevat en
kunnen in de string <code>mode</code> de volgende letters voorkomen.</p>
<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| Letter                               | Betekenis                            |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| r                                    | open enkel om te lezen               |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| w                                    | creÃ«er voor schrijven; overschrijft  |
|                                      | een bestaand bestand                 |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| a                                    | bijvoegen, open voor schrijven op    |
|                                      | het einde van het bestand of creÃ«er  |
|                                      | voor schrijven                       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| +                                    | nog een letter volgt (bv combinatie  |
|                                      | lezen en schrijven)                  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| b                                    | open in binaire modus                |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| t                                    | open in tekstmodus                   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>
<p>In de binaire modus worden bytes letterlijk geschreven en gelezen. In de
tekstmodus wordt de carriage return/linefeed combinatie vervangen door
een enkele linefeed. Bij het lezen van een tekstbestand wordt dus nooit
een carriage return aan het programma gegeven. Bij het schrijven gebeurt
het omgekeerde.</p>
<p>De functie <code>fopen()</code> geeft als resultaat een filepointer of <code>NULL</code> bij
fout.</p>
<h3 id="fclose"><code>fclose()</code></h3>
<p>Met deze functie wordt een bestand gesloten.</p>
<p>Prototype:</p>
<pre><code>int fclose(FILE *stream);
</code></pre>
<p>De functie geeft als resultaat een 0 bij succes of <code>EOF</code> bij fout.</p>
<pre><code>/* Programma dat een kopie maakt van een bestand */

#include &lt;stdio.h&gt;

int main()
{
  FILE *in, *out;

  if ((in = fopen(&quot;file.dat&quot;,
                    &quot;rt&quot;)) == NULL)
  {
     fprintf(stderr, &quot;Cannot open input file.\n&quot;);
     return 1;
  }

  if ((out = fopen(&quot;file.bak&quot;,
                    &quot;wt&quot;)) == NULL)
  {
     fprintf(stderr, &quot;Cannot open output file.\n&quot;);
     return 1;
  }

  while (!feof(in))
     fputc(fgetc(in), out);

  fclose(in);
  fclose(out);
  return 0;
}
</code></pre>
<h3 id="ferror"><code>ferror()</code></h3>
<p>Deze macro geeft als resultaat een waarde verschillend van nul als er
een fout is opgetreden bij deze filepointer.</p>
<p>Prototype:</p>
<pre><code>int ferror(FILE *stream);
</code></pre>
<h3 id="perror"><code>perror()</code></h3>
<p>Deze functie drukt een foutmelding op het scherm via <code>stderr</code>.</p>
<p>Prototype:</p>
<pre><code>void perror(const char *s);
</code></pre>
<p>Eerst wordt de string <code>s</code> gedrukt. Daarna volgt een dubbele punt en een
foutmelding die overeenkomt met de huidige waarde van <code>errno</code>.</p>
<h3 id="strerror"><code>strerror()</code></h3>
<p>Deze functie geeft als resultaat een foutmelding-string die overeenkomt
met het doorgegeven foutnummer.</p>
<p>Prototype (ook in <code>string.h</code>):</p>
<pre><code>char *strerror(int errnum);
</code></pre>
<h3 id="_strerror"><code>_strerror()</code></h3>
<p>Deze functie geeft een string met een foutmelding terug. Het formaat is
zoals bij <code>perrror</code>.</p>
<p>Prototype (ook in <code>string.h</code>):</p>
<pre><code>char *_strerror(const char *s);
</code></pre>
<p>Het volgende voorbeeld toont hoe foutmeldingen op het scherm kunnen
geplaatst worden.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

int main()
{
  FILE *stream;

  /* open a file for writing */
  stream = fopen(&quot;DUMM.FIL&quot;, &quot;r&quot;);

  /* force an error condition by attempting to read */
  (void) getc(stream);

  if (ferror(stream)) /* test for an error on the
                    stream */
  {
     /* display an error message */
     printf(&quot;Error reading from DUMMY.FIL\n&quot;);
     perror(&quot;fout&quot;);

     printf(&quot;%s\n&quot;,strerror(errno));

     printf(&quot;%s\n&quot;, _strerror(&quot;Custom&quot;));

     /* reset the error and EOF indicators */
     clearerr(stream);
  }

  fclose(stream);
  return 0;
}
</code></pre>
<h3 id="fwrite"><code>fwrite()</code></h3>
<p>Met deze functie kan informatie naar een bestand geschreven worden. De
functie schrijft <code>n</code> elementen van afmeting <code>size</code> bytes naar het
bestand. De pointer <code>ptr</code> wijst naar de te schrijven informatie.</p>
<p>Prototype:</p>
<pre><code>size_t fwrite(const void *ptr, size_t size, size_t n,
                    FILE *stream);
</code></pre>
<p>De functie geeft als resultaat het aantal elementen (niet bytes) dat
weggeschreven is.</p>
<p>Het volgende voorbeeld toont hoe een structuur naar een binair bestand
geschreven wordt.</p>
<pre><code>#include &lt;stdio.h&gt;

struct mystruct
{
   int i;
   char ch;
};

int main()
{
  FILE *stream;
  struct mystruct s;

      /* open file */
  if ((stream = fopen(&quot;TEST.$$$&quot;,
                    &quot;wb&quot;)) == NULL)
  {
     fprintf(stderr, &quot;Cannot open output file.\n&quot;);
     return 1;
  }
  s.i = 0;
  s.ch = 'A';

      /* write struct s to file */
  fwrite(&amp;s, sizeof(s), 1, stream);
  fclose(stream); /* close file */
  return 0;
}
</code></pre>
<h3 id="fread"><code>fread()</code></h3>
<p>Deze functie leest uit een bestand. Er worden <code>n</code> elementen van afmeting
<code>size</code> bytes in de array <code>ptr</code> gelezen.</p>
<p>Prototype:</p>
<pre><code>size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
</code></pre>
<p>De functie levert als resultaat het aantal elementen (niet bytes) dat
effectief gelezen is.</p>
<h3 id="fseek"><code>fseek()</code></h3>
<p>Deze functie verplaatst de wijzer die de positie aangeeft waar
eerstvolgend gelezen of geschreven wordt.</p>
<p>Prototype:</p>
<pre><code>int fseek(FILE *stream, long offset, int fromwhere);
</code></pre>
<p><code>offset</code> is de nieuwe positie relatief ten opzichte van de positie
gespecificeerd met <code>fromwhere</code>.</p>
<p>De functie geeft 0 bij succes of nonzero bij fout.</p>
<p>De parameter <code>fromwhere</code> kan een van de volgende waarden zijn:</p>
<ul>
<li>
<p><code>SEEK_SET</code> verplaats vanaf het begin van het bestand</p>
</li>
<li>
<p><code>SEEK_CUR</code> verplaats vanaf de huidige positie</p>
</li>
<li>
<p><code>SEEK_END</code> verplaats vanaf het einde van het bestand</p>
</li>
</ul>
<h3 id="fgets"><code>fgets()</code></h3>
<p>Deze functie leest een regel uit een bestand.</p>
<p>Prototype:</p>
<pre><code>char *fgets(char *s, int n, FILE *stream);
</code></pre>
<p>De parameter <code>n</code> geeft aan voor hoeveel tekens er plaats is in de buffer
<code>s</code>.</p>
<p>Bij succes, wordt de string <code>s</code> of <code>NULL</code> bij einde van het bestand of
fout teruggegeven.</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
  FILE *stream;
  char string[] = &quot;This is a test&quot;;
  char msg[20];

  /* open a file for update */
  stream = fopen(&quot;DUMMY.FIL&quot;, &quot;w+&quot;);

  /* write a string into the file */
  fwrite(string, strlen(string), 1, stream);

  /* seek to the start of the file */
  fseek(stream, 0, SEEK_SET);

  /* read a string from the file */
  fgets(msg, strlen(string)+1, stream);

  /* display the string */
  printf(&quot;%s&quot;, msg);

  fclose(stream);
  return 0;
}
</code></pre>
<h3 id="fputs"><code>fputs()</code></h3>
<p>Met deze functie wordt een regel naar een bestand geschreven.</p>
<p>Prototype:</p>
<pre><code>int fputs(const char *s, FILE *stream);
</code></pre>
<p>De functie geeft als resultaat bij succes het laatst weggeschreven teken
of <code>EOF</code> bij fout.</p>
<h3 id="fgetc"><code>fgetc()</code></h3>
<p>Met deze functie wordt een teken gelezen uit een bestand.</p>
<p>Prototype:</p>
<pre><code>int fgetc(FILE *stream);
</code></pre>
<p>De functie geeft het teken of <code>EOF</code> terug.</p>
<h3 id="fputc"><code>fputc()</code></h3>
<p>Met deze functie wordt een teken naar een bestand geschreven.</p>
<p>Prototype:</p>
<pre><code>int fputc(int c, FILE *stream);
</code></pre>
<h3 id="fprintf"><code>fprintf()</code></h3>
<p>Dit is de file-variant van <code>printf</code>.</p>
<p>Prototype:</p>
<pre><code>int fprintf(FILE *stream, const char *format, ...);
</code></pre>
<p>De functie geeft als resultaat het aantal geschreven bytes of <code>EOF</code> bij
fout.</p>
<h3 id="fscanf"><code>fscanf()</code></h3>
<p>Dit is de file-variant van <code>scanf</code>.</p>
<p>Prototype:</p>
<pre><code>int fscanf(FILE *stream, const char *format, ... );
</code></pre>
<p>De functie geeft als resultaat het aantal in variabelen opgeborgen
waarde.</p>
<h1 id="gereserveerde-woorden">Gereserveerde woorden</h1>
<pre><code>auto      extern   sizeof
break     float    static
case      for      struct
char      goto     switch
const     if       typedef
continue  int      union
default   long     unsigned
do        register void
double    return   volatile
else      short    while
enum      signed
</code></pre>
<h1 id="prioriteiten-van-de-operatoren">Prioriteiten van de operatoren</h1>
<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| Operator                             | Groepering                           |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| +() \[\] -&gt;                       |                                      |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>! \~ ++ -- - (type) \* &amp;amp; sizeof | rechts -\&gt; links (unair)             | | </code>                                    |                                      |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>\* / %</code>                             | links -&gt; rechts                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>+ -</code>                                | links -&gt; rechts                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>&lt;&lt; &gt;&gt;</code>                              |                                      |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>&lt; &lt;= &gt; &gt;=</code>                          | links -&gt; rechts                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>== !=</code>                              | links -&gt; rechts                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>&amp;</code>                                  | links -&gt; rechts                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>\^</code>                                 | links -&gt; rechts                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| +                                    | +                                    |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| links -&gt; rechts                     | <code>&amp;&amp;</code>                                 |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| links -&gt; rechts                     | +                                    |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
|                                      | +                                    |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| links -&gt; rechts                     | <code>?:</code>                                 |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| links -&gt; rechts                     | +$$= += -= \*= /= %= \^= &amp;=    |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| =$$+                               | rechts -&gt; links                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| <code>,</code>                                  | links -&gt; rechts                     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>
<h1 id="c-1">C++</h1>
<h2 id="inleiding">Inleiding</h2>
<p>In de geschiedenis van de programmeertalen zijn er regelmatig nieuwe
paradigmaâ€™s opgedoken. Met elk van die paradigmaâ€™s werd een nieuwe
programmeerstijl verdedigd. Een voorbeeld hiervan is het <em>gestructureerd
programmeren</em>, dat jaren geleden het tijdperk van de goto-loze
programmeerstijl inluidde. Deze programmeerstijl was een stap vooruit in
het schrijven van duidelijke en leesbare programmaâ€™s. Een relatief
recente programmeerstijl is het object georiÃ«nteerd programmeren. Het is
de verdienste van de programmeertaal C++ en later Java gevolgd door
Python en Ruby om de object georiÃ«nteerde programmeerstijl populair te
maken.</p>
<p>Met dit deel krijg je een eerste kennismaking met een object
georiÃ«nteerde taal. De kennismaking verloopt aan de hand van C++
voorbeelden. Een andere mogelijkheid zou zijn gebruik maken van de
recentere taal Java. Deze taal heeft veel weg van C++ maar is ontdaan
van alle onhebbelijkheden die in C++ voorkomen. Java laat toe om een
programma op verschillende platformen te draaien zonder te
hercompileren. Java is ondertussen goed ingeburgerd als eerste OO
programmeertaal in de academische bachelor. De belangrijkste reden om na
Java toch nog C++ te onderwijzen is dat C++ nog veel gebruikt wordt en
in bepaalde toepassingsdomeinen beter voldoet dan Java.</p>
<h3 id="eigenschappen-van-object-georiÃ«nteerde-talen">Eigenschappen van object georiÃ«nteerde talen</h3>
<p>Object georiÃ«nteerde talen hebben een aantal specifieke kenmerken die ze
onderscheiden van niet object georiÃ«nteerde talen. Deze eigenschappen
zijn:</p>
<h4 id="inkapseling-van-gegevens-en-methoden">Inkapseling van gegevens en methoden</h4>
<p>Het is een gekende techniek om gegevens die een sterke relatie met
elkaar hebben, te groeperen in een structuur of wat met in object
georiÃ«nteerde termen een klasse noemt. Deze groepering maakt het
gemakkelijker om het overzicht op de gegevens binnen een programma te
bewaren.</p>
<p>Hiermee wordt bedoeld dat niet alleen gegevens maar ook acties die
inwerken op deze gegevens worden gegroepeerd binnen een klasse. Deze
techniek laat toe om de gegevens binnen een klasse af te schermen van de
buitenwereld. Wie deze gegevens wil raadplegen om veranderen moet dit
doen via speciale functies die bij de klasse horen. De toegang tot de
gegevens is niet direct maar indirect. De acties of functies binnen een
klasseworden in de object georiÃ«nteerde wereld methoden genoemd. Het
voordeel van deze techniek is de mogelijkheid om achteraf nog wijze
waarop de gegevens binnen de klasse opgeslagen worden, gemakkelijk te
wijzigen.</p>
<h4 id="erfenis">Erfenis</h4>
<p>Als op een zekere dag blijkt dat de gegevensopslag binnen een klasse
uitgebreid moet worden, dan zal men in plaats van de klasse te wijzigen
een afleiding maken van deze klasse. De nieuwe klassen erft alle
gegevens en methoden van de klasse waarvan geÃ«rfd wordt. Aan de nieuwe
klassen kunnen andere gegevens en methoden toegevoegd worden of kan een
overgeÃ«rfde methode vervangen worden door een nieuwe versie. Dit is het
principe van de erfenis.</p>
<h4 id="late-of-dynamische-verbinding">Late of dynamische verbinding</h4>
<p>In de klassieke programmeertalen zorgt de linker ervoor dat de
werkelijke adressen van de functies ingevuld wordt bij elke CALL
instructie. Dit is het principe van de vroege of statische verbinding.
In object georiÃ«nteerde talen kan deze verbinding uitgesteld worden tot
het uitvoeren van het programma. Vlak voor de uitvoering van de CALL
wordt het adres van de functies opgezocht. Dit mechanisme geeft een
verhoogde flexibiliteit en is de kern bij het object georiÃ«nteerd
programmeren.</p>
<p>In C++ kaj je kiezen tussen vroege en late verbinding. In Java heb je
die keuze niet meer; hier is het altijd de late verbinding.</p>
<h4 id="polymorfie">Polymorfie</h4>
<p>Deze term wordt gebruikt om aan te geven dat de oproep van een functie
of methode soms tot een ander gedrag leidt. Het gedrag van de opgeroepen
methode is afhankelijk van de gegevens. Deze speciale afhankelijkheid
tussen gegevens en methode maakt het mogelijk om delen van programmaâ€™s
te ontwerpen die een zekere vorm van algemeenheid bewaren. Hiermee
verhoogt de kans dat deze programmadelen later herbruikt worden. Het
mechanisme om polymorfie toe te laten is de late verbinding. Een
voorbeeld uit het dagelijkse leven maakt polymorfie duidelijk: als we
iemand de opdracht geven om een voertuig dan zal de man (of vrouw) in
kwestie zijn gedrag aanpassen naargelang hij (of zij) een gewone auto
moet wassen of een autobus.</p>
<p>EÃ©n van de object georiÃ«nteerde talen is C++. Andere talen zijn Eiffel,
Smalltalk, ObjectC, Simula en Turbo Pascal. Verder zijn er object
georiÃ«nteerde uitbreidingen op reeds bestaande talen; dit geldt onder
andere voor Lisp en Prolog. Aan dit lijstje wordt uiteraard de jongste
tal Java, Python en Ruby toegevoegd.</p>
<h3 id="geschiedenis-van-c">Geschiedenis van C++</h3>
<p>De taal C++ is ontworpen door Bjarne Stroustrup en is volledig gebaseerd
op C. C op zijn beurt is afgeleid van zijn voorganger BCPL. De
commentaarstarter // die in C++ ingevoerd is, bestond al in BCPL. Heel
wat concepten van C++ (de naam C++ werd in de zomer van 1983
uitgevonden) zijn afgeleid van andere programmeertalen. Het
klasseconcept met afleidingen en virtuele functies werd van Simula67
overgenomen. De mogelijkheid om bewerkingstekens een andere betekenis te
geven en om overal in het programma declaraties van variabelen te
schrijven is van Algol68 overgenomen. Zo ook komen de ideeÃ«n voor
templates en exceptions uit Ada, Clu en ML. C++ werd door de auteur
ontworpen voor eigen gebruik. De eerste versie was geen eigen compiler
maar wel een C naar C++ omzetter. Dit programma heette <code>cfront</code>. Door de
stijgende populariteit van C++ bleek toch een standaardisatie
noodzakelijk. Deze stap in gang gezet binnen ANSI als de X3J16 commissie
in 1989. De ANSI C++ standaardisatie zal vermoedelijk ook deel uitmaken
van een internationale ISO standaard. Tijdens de periode van het
ontstaan tot de standaardisatie is C++ geÃ«volueerd. Een aantal
wijzigingen zijn er gekomen na het opdoen van praktische ervaring.</p>
<p>Oorspronkelijk werd C ontworpen om assembler te vervangen. Ook C++ kan
in deze optiek gebruikt verder gebruikt worden. Met andere woorden C++
staat dicht bij de machine. Van de andere kant is C++ bedoeld om de
complexiteit van een probleem in kaart te brengen. Door een
klassehiÃ«rarchie op te bouwen is het mogelijk om een klare kijk te
behouden op de gegevens en bijbehorende acties in een probleem. Hierdoor
is het mogelijk dat Ã©Ã©n persoon met C++ programmaâ€™s van meer dan 25.000
regels kan ontwerpen en onderhouden. In C zou dit veel moeilijker zijn.</p>
<p>De evolutie van C++ loopt nog altijd verder. In 2011 is de laatste
standaard opgesteld. Deze staat bekend onder de naam <em>C++11</em>. De
vernieuwingen die hierin voorgesteld worden, zijn niet opgenomen in deze
cursustekst.</p>
<h3 id="waarom-object-georiÃ«nteerd-programmeren">Waarom object georiÃ«nteerd programmeren?</h3>
<p>Veel C programmeurs blijven liever bij C en zijn niet geneigd om C++ te
leren. Hun argumenten zijn dikwijls als volgt:</p>
<ul>
<li>
<p>C++ is een moeilijke taal. De concepten zijn veel abstracter en de
mechanismen in de taal zijn op het eerste zicht niet erg duidelijk.
Waarom een moeilijke taal zoals C++ gebruiken als het met eens
simpele taal zoals C ook gaat.</p>
</li>
<li>
<p>Bij C++ is het veel moeilijker om de programmauitvoering te volgen.
Om de haverklap worden constructors uitgevoerd. Door het mechanisme
van de late binding weet je niet direct waar je terecht komt bij de
stap voor stap uitvoering.</p>
</li>
<li>
<p>Sommigen willen toch de principes van het object georiÃ«nteerd
programmeren volgen, maar doen dit liever in C. Deze werkwijze is
nogal omslachtig.</p>
</li>
<li>
<p>Bij C++ is de programmeur verplicht om tijdens de analyse zijn
denkproces aan te passen aan het object georiÃ«nteerd ontwerpen. Dit
onvermijdelijke denkwerk gebeurt reeds voor het programmeren en kan
niet omzeild worden. In deze analysefase ben je verplicht om diep te
denken over gegevens en acties en hun onderling relaties. Het
resultaat van dit denkwerk is het objectenmodel van het probleem.
Dit model dient als leidraad tijdens het programmeerwerk. Tijdens de
testfase zal dan blijken dat er minder denk- en programmeerfouten
zijn en bijgevolg het programma sneller afwerkt zal zijn.</p>
</li>
</ul>
<h4 id="programmeerparadigmas">Programmeerparadigmaâ€™s</h4>
<p>Tijdens de geschiedenis van de programmeertalen zijn er heel wat
programmeerprincipes opgedoken. EÃ©n van de eerste principes is het
programmeren met procedures<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> Hierbij is het de bedoeling om alle
acties die nodig zijn om een bepaalde taak uit te voeren worden in een
routine, procedure of functie ondergebracht. De analyse die deze
groepering vooraf gaat is vooral gericht naar uitvoerbare acties. Er
ontstaat een hiÃ«rarchie van procedures.</p>
<p>Voor het controleren van de volgorde waarin acties worden uitgevoerd
werd eerst de goto gebruikt. Tegenwoordig wordt deze constructie niet
meer gebruikt (tenzij in assembler). De if-then-else is er in de plaats
gekomen. Dit principe heet gestructureerd programmeren. Deze stijl wordt
alle moderne programmeertaal mogelijk gemaakt.</p>
<p>Na een aantal jaren is gebleken dat een goede data-analyse belangrijk
is. Een aantal procedures die betrekking hebben op dezelfde gegevens
worden in een module gegroepeerd. De data binnen de module mag niet
rechtstreeks toegankelijk zijn, maar gebeurt door middel van procedures.
Dit is het modulair programmeren. Hierbij wordt het principe van de
data-hiding toegepast. De wijze waarop de data is opgeslagen is niet
gekend door de gebruiker van de module. Het modulair programmeren laat
ook toe grotere programmaâ€™s te ontwerpen. In C is een module een apart
<code>.c</code> bestand waarin de gegevens in globale variabelen worden
bijgehouden. Om de data-hiding mogelijk te maken moet het woord <code>static</code>
aan elke declaratie voorafgaan. Deze methode heeft een nadeel: elke
module stelt slechts Ã©Ã©n gegevensgroep voor, bijvoorbeeld een tabel met
strings. Als we meerdere gegevensgroepen willen maken moeten we <code>struct</code>
gebruiken. Hiermee verliezen we de data-hiding. De taal C is daarom niet
geschikt om op een succesvolle manier gegevens voor de gebruiker te
verbergen. Door dit nadeel is het beter om C te verlaten en C++ te
gebruiken. C++ kent het principe van de klasse. Hiermee is een perfecte
data-hiding mogelijk.</p>
<p>Bij het modulair programmeren ontstaan modules. Bij nieuwe projecten is
het dikwijls lastig om bestaande modules opnieuw te gebruiken. Dikwijls
zijn er kleine aanpassingen nodig of wordt toch maar de hele module
herschreven. Het herbruiken van reeds bestaande programmatuur is niet
gemakkelijk bij het modulair programmeren. Bij het object georiÃ«nteerd
programmeren is het mogelijk om afleidingen te maken van bestaande
klassen. In de nieuwe klassen kunnen dan de kleine wijzigingen gebeuren.
Een andere ontwerptechniek is het ontwerpen van een klasse waarin een
aantal functies alleen maar als prototype voorkomen. In de afleiding van
deze klassen wordt de implementatie van deze functies ingevuld. Door
deze techniek is het mogelijk om een klasse te maken die nog
algemeenheid als eigenschap hebben. Een algemene (of in OO termen:
abstracte) klasse is niet bedoeld om hiermee variabelen te declareren.
Van een abstracte klasse worden afleidingen gemaakt en deze afleidingen
worden gebruikt om variabelen te declareren. Door de techniek van de
afleiding ontstaan er hiÃ«rarchieÃ«n van klassen. Die maken het mogelijk
om de functionaliteit en gegevens in een groot programma goed in kaart
te brengen. C programmeurs die klagen over de moeilijkheidsgraad van
C++, klagen over het feit dat ze een OO analyse van gegevens/acties
moeten uitvoeren; iets dat zij tot nu toe nooit deden. Daarom is C++
leren niet zomaar weer een nieuwe taal leren, het is een andere manier
van denken.</p>
<p>Als besluit op deze inleiding geven we de tegenargumenten die voor C++
pleiten:</p>
<ul>
<li>
<p>De concepten van een OO taal zijn abstracter omdat het denken
tijdens een OO analyse abstracter is. Deze hogere graad van denken
loont wel de moeite. Hiermee worden vroegtijdig de elementen
(gegevens en bijbehorende acties) van het probleem gestructureerd en
worden tegenstrijdigheden die later zouden kunnen opduiken bij
onderhoud of wijziging vermeden.</p>
</li>
<li>
<p>Het is inderdaad veel moeilijker om een C++ programma stap voor stap
te volgen, want we worden geconfronteerd met alle details van alle
klassen die doorlopen worden. Het is beter om niet stap voor stap te
debuggen, maar wel op klasseniveau. Test elke klasse Ã©Ã©n voor Ã©Ã©n.
Door de data-hiding is de relatie tussen de verschillende klassen
minimaal. Elke klasse kan daarom als een op zich bestaand domein
beschouwd worden.</p>
</li>
<li>
<p>Het is beter om OO te programmeren met een taal die dit principe
ondersteund. Een goede programmeur kan wel in zekere mate OO
principes in C toepassen, maar dit gaat gepaard met veel pointers
naar functies, <code>void \*</code> pointers en cast bewerkingen. Dit zijn
allemaal constructies die gemakkelijk fouten introduceren.</p>
</li>
<li>
<p>Niet object georiÃ«nteerde verschillen tussen C en C++</p>
</li>
</ul>
<p>Normaal gezien is het mogelijk om een C programma te compileren met
behulp van een C++ compiler. Er zijn wel enkele kleine verschillen
tussen beide compilers voor wat betreft de C syntax.</p>
<h2 id="c-constructies-met-een-andere-betekenis-in-c">C constructies met een andere betekenis in C++</h2>
<p>We geven hier een overzicht van de belangrijkste taal elementen die
anders zijn in C++ dan in C.</p>
<ul>
<li>
<p>In C++ is er geen beperking op de lengte van namen.</p>
</li>
<li>
<p>De C++ compiler moet eerst een prototype van een functie gezien
hebben voor dat deze functie opgeroepen kan worden.</p>
</li>
<li>
<p>Een karakterconstante is in C++ van het <code>type</code> char, in C is dit
<code>int</code>.</p>
</li>
</ul>
<h3 id="referentietype">Referentietype</h3>
<p>Dit is een nieuw type in C++. Het referentietype maakt het mogelijk om
een variabele te declareren die als synomiem van een andere variabele
dienst doet.</p>
<pre><code>int a;
int &amp;x = a;
int &amp;y; // Fout: initialisatie ontbreekt

x = 5;   // a is nu 5
</code></pre>
<p>De variabele is een gewoon geheel getal. De variabele <code>x</code> is een
referentievariabele die verwijst naar de variabele <code>a</code>. Voor <code>x</code> is er
geen opslagruimte voor een <code>int</code>. Als <code>x</code> gewijzigd wordt, wordt de
inhoud van
<code>a+gewijzigd.  Een referentievariabele moet geÃ¯nitialiseerd worden bij de declaratie. Daarom is de declaratie van +y</code>
fout. Het is niet mogelijk om na de declaratie de referentievariabele
naar een andere variabele te laten verwijzen.</p>
<p>De referentievariabele wordt dikwijls als formele parameter gebruikt.
Hier is een klassiek voorbeeld:</p>
<pre><code>void swap(int &amp;x, int &amp;y)
{
   int h;

   h = x;
   x = y;
   y = h;
}

int main()
{
   int a = 5;
   int b = 6;

   swap (a, b);   // verwissel a en b

   return 0;
}
</code></pre>
<p>Bij het gebruik als parameter gedraagt een referentietype zich als een
VAR parameter in Pascal. Het voordeel is het feit dat in de functie
<code>swap</code> de variabelen <code>x</code> en <code>y</code> er als een gewone variabele uitzien en
niet als een pointervariabele.</p>
<h2 id="de-klasse-in-c">De klasse in C++</h2>
<h3 id="een-klasse-definiÃ«ren">Een klasse definiÃ«ren</h3>
<p>C++ kent niet alleen het type <code>struct</code> maar ook het type <code>class</code>. Beiden
kunnen gebruikt worden om gegevens in te kapselen. Dit doen we om
gegevens, die sterk verbonden zijn, samen te brengen onder een noemer.
Het sleutelwoord class is nieuw in C++ en laat de bescherming van de
gegevens binnen een klasse toe.</p>
<p>Het eerste voorbeeld heeft wat te maken met grafische weergave van
gegevens. In een grafische omgeving moeten we de coÃ¶rdinaten van een
punt op het scherm bijhouden. Dit doen we door de coÃ¶rdinaten van een
plaats op te slaan in een klasse:</p>
<pre><code>class Punt
{
   int x;
   int y;
};
</code></pre>
<p>De klasse <code>Punt</code> bevat dus de velden <code>x</code> en <code>y</code>. Deze vorm van groeperen
kennen we al van C. Met de klasse <code>Punt</code> kan een variabele gedeclareerd
worden en we kunnen trachten om de velden <code>x</code> en <code>y</code> te bereiken.</p>
<pre><code>Punt p1;
</code></pre>
<p>De variabele <code>p1</code> is van het type <code>Punt</code> en is in staat om 2 coÃ¶rdinaten
te onthouden. Dit is niet meteen zichtbaar aan de variabele. Dit is het
principe van de inkapseling. We gebruiken de term object om een
variabele van een zekere klasse aan te duiden. Als we het in de toekomst
over objecten hebben, dan bedoelen we hiermee variabelen of stukken
dynamisch geheugen waarin zich informatie van een zekere klasse bevindt.</p>
<h3 id="toegang-tot-leden">Toegang tot leden</h3>
<p>Als we de leden van het object <code>p1</code> willen bereiken, dan zouden we het
volgende kunnen uitproberen:</p>
<pre><code>int main()
{
   Punt p1;

   p1.x = 50;
   p1.y = 70;

   return 0;
}
</code></pre>
<p>Helaas geeft dit programma twee compilatiefouten. De twee velden <code>x</code> en
<code>y</code> zijn niet toegankelijk van buiten het object. Als we binnen de
definitie van de klassen niet een van de woorden <code>private</code>, <code>protected</code>
of <code>public</code> zijn alle leden privaat, <code>private</code> dus. We hadden evengoed
dit kunnen schrijven:</p>
<pre><code>class Punt
{
private:
   int x;
   int y;
};
</code></pre>
<p>Op deze wijze wordt duidelijk weergegeven dat de leden x en y niet
publiek toegankelijk zijn.</p>
<h3 id="een-constructor-bijvoegen">Een constructor bijvoegen</h3>
<p>Omdat de leden van de klasse <code>Punt</code> niet publiek toegankelijk zijn is er
een probleem om bijvoorbeeld de variabele <code>p1</code> te initialiseren of om de
waarden <code>x</code> en <code>y</code> van een <code>Punt</code> object te weten te komen. Daarom zijn
we verplicht tot de leden van een klasse via lidfuncties te organiseren.
Een lidfunctie is een functie die deel uitmaakt van een klasse. Dikwijls
wordt ook de term methode voor dit soort functies gebruikt. Er is een
speciale vorm van een lidfunctie die enkel voor de initialisatie van een
object wordt gebruikt. Deze vorm wordt constructor genoemd. Een
constructor krijgt als naam de naam van de klasse.</p>
<pre><code>class Punt
{
private:
   int x;
   int y;

public:
   Punt(int ix, int iy);
};
</code></pre>
<p>Binnen de klassebeschrijving noteren we een prototype van een functie.
Omdat we voor de functienaam de naam van de klasse kiezen, is deze
functie een constructor. We voorzien de constructor van twee formele
parameters ix en iy. Dit betekent dat we aan de constructor twee
getallen kunnen meegeven die dienen voor de initialisatie van het
object. Bij een constructor mogen nooit een return type noteren;
parameters mogen wel. In dit voorbeeld zijn er twee parameters.</p>
<p>Wat deze constructor moet doen, is nog niet vastgelegd. Binnen de klasse
staat alleen maar een prototype. Nu zijn er twee manieren om de
implementatie vast te leggen.</p>
<h4 id="een-constructor-implementatie-buiten-de-klasse">Een constructor implementatie buiten de klasse</h4>
<p>We noteren de implementatie van de constructor buiten de accolades van
de klassebeschrijving. Om aan te geven dat het hier gaat over een
lidfunctie van de klasse Punt moeten we nog eens de klassenaam aan de
functienaam laten voorafgaan. Tussen de klassenaam en de functienaam
schrijven we twee dubbele punten.</p>
<pre><code>Punt::Punt(int ix, int iy)
{
   x = ix;
   y = iy;
}
</code></pre>
<p>Omdat het hier om een constructor gaat, schrijven we tweemaal <code>Punt</code> .
Eenmaal als klassenaam en als functienaam. Binnen de acties van een
lidfunctie zijn de dataleden van een klasse vrij toegankelijk. De namen
<code>x</code> en <code>y</code> binnen de constructor zijn de twee dataleden van een <code>Punt</code>
object. Aan elk van de dataleden wordt een startwaarde toegekend.</p>
<p>Voor het toekennen van een startwaarde is er bij constructors aan andere
schrijfwijze mogelijk. Hierbij wordt na een dubbele punt de lijst van te
initialiseren datavelden geschreven met telkens de startwaarde erbij:</p>
<pre><code>Punt::Punt(int ix, int iy) : x(ix), y(iy)
{
}
</code></pre>
<p>Deze schrijfwijze mag alleen maar bij constructors toegepast worden.</p>
<h4 id="een-constructor-implementatie-binnen-de-klasse">Een constructor implementatie binnen de klasse</h4>
<p>We kunnen de implementatie van de constructor ook binnen de klasse
noteren. Het voordeel is dat we minder schrijfwerk hebben. Het nadeel is
dat als we de implementatie van de constructor wijzigen, dan moet er
binnen de klassedefinitie gewijzigd worden. Vermits we alle
klassedefinities in headerbestanden onderbrengen, veroorzaakt dit de
hercompilatie van alle .cpp bestanden die van deze klasse gebruik maken.</p>
<pre><code>class Punt
{
private:
   int x;
   int y;

public:
   Punt(int ix, int iy) : x(ix), y(iy)
   {
   }
};
</code></pre>
<p>Voor een constructor maakt het geen verschil uit welke twee opties
gekozen wordt. Voor lidfuncties, die dus geen constructor zijn, is er
wel een verschil tussen implementatie binnen of buiten de klasse. Dit
onderscheid bespreken we later.</p>
<h3 id="objecten-declareren">Objecten declareren</h3>
<p>Zoals we met een eenvoudig type een variabele kunnen declareren, kunnen
we met een klasse een object declareren.</p>
<pre><code>#include &lt;iostream.h&gt;

Punt pg(23, 34);

int main()
{
   Punt p1(30, 40);
   Punt p2 = Punt(44, 55);

   cout &lt;&lt; &quot;main\n&quot;;

   return 0;
}
</code></pre>
<p>Omdat er een constructor is die twee gehele getallen verwacht als
parameter, moeten we bij de initialisatie tussen ronde haken twee
getallen voorzien. Het is hier dat de constructor in actie treedt. Een
constructor kunnen we nooit zelf starten. Een constructor wordt
uitgevoerd voor een object, zodra dit object tot leven komt. Voor <code>pg</code>
is dit zelfs voor de start van <code>main()</code>. Dit betekent dat voor het
starten van <code>main()</code> de dataleden <code>x</code> en <code>y</code> van het object pg met
23+<code>en 34 worden gevuld. Daarna start</code> main()+ en daarna wordt
achtereenvolgens de constructor voor <code>p1</code> en <code>p2</code> opgeroepen. Dan pas
start de uitvoering van <code>printf()</code>. Voor <code>p1</code> en <code>p2</code> is telkens een
andere schrijfwijze van de initialisering toegepast.</p>
<h3 id="meerdere-constructors">Meerdere constructors</h3>
<p>Het is mogelijk om meerdere constructors te voorzien binnen een klasse.
Het aantal en het type parameters van alle constructors moeten
verschillend zijn. Met andere woorden: elke constructor heeft aan ander
prototype. In de klasse <code>Punt</code> hadden we al een constructor met als
parameters de coÃ¶rdinaten van een punt. We voegen nu een constructor bij
die geen parameters heeft.</p>
<pre><code>class Punt
{
private:
   int x;
   int y;

public:
   Punt(int ix, int iy) : x(ix), y(iy)
   {
   }
   Punt() : x(0), y(0)
   {
   }
};
</code></pre>
<p>De implementatie van deze nieuwe constructor plaatsen we voor het gemak
in de klasse zelf. Deze constructor zorgt ervoor de dataleden <code>x</code> en <code>y</code>
automatisch 0 worden als we de expliciete initialisatie weglaten bij de
declaratie van een object. In de volgende versie van <code>main</code> zien we twee
objecten van de klasse <code>Punt</code>; Ã©Ã©n met en Ã©Ã©n zonder initialisatie.</p>
<pre><code>int main()
{
   Punt p1(30, 40);
   Punt p2;

   return 0;
}
</code></pre>
<p>Het object <code>p1</code> wordt met de eerste constructor geÃ¯nitialiseerd en <code>p2</code>
wordt geÃ¯nitialiseerd met de tweede constructor. Dit betekent dat de
<code>p2.x</code> en <code>p2.y</code> allebei nul worden. De compiler beslist aan de hand van
het aantal en het type actuele parameters welke constructor bij de
declaratie opgeroepen wordt. Dit is meteen ook de reden waarom er geen
twee constructors met hetzelfde prototype mogen zijn.</p>
<h3 id="een-object-initialiseren-door-een-ander-object">Een object initialiseren door een ander object</h3>
<p>Het is mogelijk om bij de declaratie een object te initialiseren met een
ander object.</p>
<pre><code>int main()
{
   Punt p1(30, 40);
   Punt p2 = p1;

   return 0;
}
</code></pre>
<p>We zouden kunnen verwachten dat de compiler zou eisen dat er een
constructor met prototype</p>
<pre><code>Punt(const Punt &amp;x);
</code></pre>
<p>voorkomt in de klasse. We hoeven deze constructor echter niet te
definiÃ«ren omdat dit automatisch gebeurt. Elke klasse krijgt automatisch
een constructor die dient voor de initialisatie met een object van
dezelfde klasse. Deze constructor wordt copy constructor genoemd; hij
kopieert Ã©Ã©n voor Ã©Ã©n alle dataleden van het ene naar het andere object.
Dit gedrag is hetzelfde als bij het kopiÃ«ren van structuren in C. Bij de
klassen <code>Punt</code> is het lidsgewijs kopiÃ«ren het juiste gedrag. In het
bovenstaande voorbeeld worden de datavelden <code>x</code> en <code>y</code> van <code>p1</code> naar
<code>p2</code> gekopieerd.</p>
<h3 id="objecten-kopiÃ«ren">Objecten kopiÃ«ren</h3>
<p>Zo kunnen we ook objecten kopiÃ«ren met een toekenning. Deze operator
kopieert zoals bij de copy constructor alle dataleden.</p>
<pre><code>int main()
{
   Punt p1(30, 40);
   Punt p2;

   p2 = p1;

   return 0;
}
</code></pre>
<p>Voor deze bewerking heeft de compiler automatisch een operator voor de =
bewerking binnen de klasse bijgevoegd. Het bijvoegen van bewerkingen
bekijken we later nog wel.</p>
<h3 id="lidfuncties-in-een-klasse-bijvoegen">Lidfuncties in een klasse bijvoegen</h3>
<p>De twee dataleden van de klasse <code>Punt</code> zijn privaat. Dit betekent dat we
niet rechtstreeks toegang krijgen tot de dataleden. Daarom voegen we een
klassefunctie bij die de coÃ¶rdinaten van een <code>Punt</code> op het scherm drukt.</p>
<pre><code>class Punt
{
private:
   int x;
   int y;

public:
   Punt(int ix, int iy) : x(ix), y(iy)
   {
   }
   Punt() x(0), y(0)
   {
   }
   void druk();
};

void Punt::druk()
{
   cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; x &lt;&lt;
&quot;,&quot; &lt;&lt; y &lt;&lt; &quot;&gt;&quot;;
}
</code></pre>
<p>De klassefunctie druk kan zonder meer toegang krijgen tot de dataleden
van het object in kwestie. De functie <code>druk()</code> kan alleen maar gestart
worden met een concreet object:</p>
<pre><code>void main()
{
   Punt p1(67,78);
   Punt p2(34,98);

   p1.druk();
   p2.druk();
}
</code></pre>
<p>De notatie van de oproep van een klassefunctie is dezelfde als in C voor
de toegang tot een veld van een structuur. De naam van het object wordt
gevolgd door een punt en de naam van de klassefunctie.</p>
<h3 id="inline-uitvoering-van-een-lidfunctie">Inline uitvoering van een lidfunctie</h3>
<p>Het is mogelijk om de tijd die nodig is voor de oproep en de terugkeer
van een functie te elimineren. Dit is nodig als een klassefunctie zeer
kort is.</p>
<p>We gaan twee lidfuncties aan de klasse <code>Punt</code> bijvoegen om de waarden
van dataleden <code>x</code> en <code>y</code> terug te geven. We tonen twee versies van de
implementatie van de lidfuncties.</p>
<h4 id="een-lidfunctie-implementatie-buiten-de-klasse">Een lidfunctie implementatie buiten de klasse</h4>
<p>Binnen de klasse <code>Punt</code> worden twee prototypes voor <code>haalx</code> en <code>haaly</code>
bijgevoegd.</p>
<pre><code>class Punt
{
private:
   int x;
   int y;

public:
   Punt(int ix, int iy) : x(ix), y(iy)
   {
   }
   Punt() : x(0), y(0)
   {
   }
   void druk();
   int haalx();
   int haaly();
};
</code></pre>
<p>De implementaties van de twee functies ziet er zo uit:</p>
<pre><code>int Punt::haalx()
{
   return ( y );
}

int Punt::haaly()
{
   return ( y );
}
</code></pre>
<p>We kunnen deze twee functies expliciet gebruiken om de waarden van de
coÃ¶rdinaten op te halen zonder grens van de inkapseling te overtreden.
Dit wordt als volgt gedaan:</p>
<pre><code>int main()
{
   Punt pp(67, 89);

   cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; pp.haalx()
        &lt;&lt; &quot;,&quot; &lt;&lt; pp.haaly() &lt;&lt;&quot;&gt;\n&quot;;

   return 0;
}
</code></pre>
<p>Bij deze implementatie is er sprake van een echte subroutine. Er is
bijgevolg een oproep en een terugkeer. Het nadeel van deze twee functies
is dat ze zeer kort zijn; dit betekent dat er meer tijd besteed wordt
aan de oproep en de terugkeer (jsr en ret instructies) dan aan de
uitvoering van de acties van de functies. Daarom kan gekozen worden voor
de inline uitvoering van dit soort van korte functies.</p>
<h4 id="een-lidfunctie-implementatie-binnen-de-klasse">Een lidfunctie implementatie binnen de klasse</h4>
<p>We plaatsen de opdrachtregel van de klassefuncties binnen de definitie
van de klasse.</p>
<pre><code>class Punt
{
private:
   int x;
   int y;

public:
   Punt(int ix, int iy) { x = ix; y = iy; }
   Punt() { x = 0; y = 0; }
   void druk();
   int haalx()
   {
      return( x );
   }
   int haaly()
   {
      return( y );
   }
};
</code></pre>
<p>Door deze notatievorm wordt de functie inline uitgevoerd. Elke oproep in
C++ notatie wordt vervangen door de instructies van de opdrachtregel.
Het is evident dat deze oplossing alleen efficiÃ«nt is bij zeer korte
klassefuncties. Het gevolg is wel dat het programma in zijn totale
lengte (in machineinstructies uitgedrukt) langer wordt omdat het
principe van de subroutine niet wordt toegepast.</p>
<p>Er is een alternatieve implementatie van een inline klassefunctie
mogelijk. De implementatie wordt dan toch buiten de klassedefinitie
geschreven, maar het prototype bij de implementatie van de klassefunctie
wordt voorafgegaan door het woord <code>inline</code>.</p>
<pre><code>class Punt
{
private:
   int x;
   int y;

public:
   Punt(int ix, int iy) : x(ix), y(iy)
   {
   }
   Punt() : x(0), y(0)
   {
   }
   void druk();
   int haalx();
   int haaly();
};

inline int Punt::haalx()
{
   return ( y );
}

inline int Punt::haaly()
{
   return ( y );
}
</code></pre>
<h2 id="bewerkingen-in-een-klasse">Bewerkingen in een klasse</h2>
<p>C++ kent de mogelijkheid om een nieuwe betekenis te geven aan een
bewerkingsteken afhankelijk van de klasse waarop de bewerking betrekking
heeft. Zo kan men een andere betekenis geven aan de optelling bij
breuken en bij complexe getallen. We geven een voorbeeld dat handelt
over breuken.</p>
<h3 id="bewerkingen-als-functies-in-een-klasse">Bewerkingen als functies in een klasse</h3>
<p>We ontwerpen de klasse om een breuk op te slaan. De klasse krijgt twee
dataleden: een voor de teller en een voor de noemer. Beide worden
opgeslagen als een geheel getal. De constructor is voorzien van
verstekwaarden; zo krijgt een breuk de waarde 0/1 wanneer de
initialisatie ontbreekt.</p>
<pre><code>// breuk.h
class Breuk
{
public:
   Breuk(int t=0, int n=1) : teller(t), noemer(n)
   {
   }
   Breuk &amp;operator++();
   Breuk operator+(Breuk b);

private:
   int teller;
   int noemer;
};
</code></pre>
<p>Wanneer we een bewerkingsteken willen definiÃ«ren dan geven we de
bijbehorende functie een speciale naam. We combineren het sleutelwoord
<code>operator</code> met het bewerkingsteken in kwestie. Voor de ++ bewerking
wordt dit:</p>
<pre><code>Breuk &amp;operator++();
</code></pre>
<p>Deze functie geeft een <code>Breuk</code> als referentietype terug. Dit is nodig
omdat de
<code>bewerking in uitdrukkingen kan voorkomen. Het terugkeer type is het referentietype omdat de</code>
bewerking zowel links of rechts van een toekenning kan voorkomen.</p>
<pre><code>Breuk b1;
Breuk b2;

b1++ = b2++;
</code></pre>
<p>Op dezelfde wijze wordt de functienaam voor de optelling samengesteld:</p>
<pre><code>Breuk operator+(Breuk b);
</code></pre>
<p>In dit geval is er een parameter: dit is de breuk die bij andere breuk
wordt opgeteld. Het resultaat van de bewerking is het <code>Breuk</code> type. De
bewerking kan zo gebruikt worden:</p>
<pre><code>b3 = b1+b2;
</code></pre>
<p>We zouden de bewerking ook als een functie kunnen starten</p>
<pre><code>b3 = b1.operator+(b2);
</code></pre>
<p>Deze schrijfwijze is alleen maar nuttig om te zien hoe de bewerking
gestart wordt.</p>
<p>De implementatie van beide bewerkingen worden als gewone klassefuncties
geschreven. Voor de ++ bewerking wordt de noemer Ã©Ã©nmaal bij de teller
opgeteld. Met</p>
<pre><code>return *this;
</code></pre>
<p>wordt een referentie naar het huidige object als resultaat teruggegeven.</p>
<pre><code>// breuk.cpp
#include &lt;iostream.h&gt;
#include &quot;breuk.h&quot;

Breuk &amp;Breuk::operator++()
{
   teller += noemer;
   return *this;
}

Breuk Breuk::operator+(Breuk b)
{
   Breuk nb;

   nb.teller = teller * b.noemer + noemer * b.teller;
   nb.noemer = noemer * b.noemer;

   return nb;
}
</code></pre>
<p>In de + bewerking wordt een nieuwe <code>Breuk</code> gemaakt. De som van de twee
op te tellen breuken wordt in deze nieuwe variabele geplaatst. Met
return, in dit geval de som, gaat het resultaat terug naar de oproeper.</p>
<h3 id="vriendfuncties-van-een-klasse">Vriendfuncties van een klasse</h3>
<p>In sommige gevallen is het nodig om een bewerking als een functie buiten
de klasse te definiÃ«ren. Dit is het geval bij de functie die de uitvoer
van een <code>Breuk</code> verzorgt. Omdat deze functie toegang moet krijgen tot de
private leden van de klasse <code>Breuk</code> maken we de functie een vriend van
de klasse <code>Breuk</code>.</p>
<pre><code>friend ostream &amp;operator&lt;&lt;(ostream &amp;os, Breuk b);
</code></pre>
<p>Het bovenstaande prototype wordt in de klasse bijgevoegd. Met het woord
<code>friend</code> gevolgd door een prototype wordt aangegeven dat een niet-klasse
functie toegang krijgt tot alle private leden.</p>
<p>Voor de uitvoer wordt het naar links schuif teken &lt;&lt; gebruikt. We
schrijven dit teken na het woord <code>operator</code>. De parameters van de
uitvoerbewerking zijn het uitvoerkanaal en de Breuk die getoond moet
worden. <code>ostream</code> is het type van het uitvoerkanaal. <code>cout</code> behoort tot
dit type. Als terugkeertype zien we een referentie naar ostream. We
geven het uitvoerkanaal terug als referentie. Dit is nodig omdat de
uitvoerbewerking samen met het uitvoerkanaal en de breuk opnieuw als een
ostream aanzien wordt. Hierdoor kan men meerdere uitvoerbewerkingen na
elkaar schrijven.</p>
<pre><code>(cout &lt;&lt; b1) &lt;&lt; b2;
</code></pre>
<p>In de bovenstaande uitvoer wordt <code>cout &lt;&lt; b1</code> opnieuw als een
uitvoerkanaal aanzien. Naar dit kanaal wordt de uitvoer van <code>b2</code>
gestuurd.</p>
<p>De implementatie van de uitvoerbewerking gaat na of de noemer 1 is.
Indien ja, wordt alleen de teller getoond. Anders worden teller en
noemer gescheiden met een deelstreep getoond.</p>
<pre><code>ostream &amp; operator&lt;&lt;(ostream &amp;os, Breuk b)
{
   if (b.noemer == 1)
   {
      cout &lt;&lt; b.teller;
   }
   else
   {
      cout &lt;&lt; b.teller &lt;&lt; &quot;/&quot; &lt;&lt; b.noemer;
   }
   return os;
}
</code></pre>
<p>De uitvoerbewerking geeft als resultaat het doorgegeven uitvoerkanaal
terug.</p>
<p>We tonen nog een voorbeeld van een hoofdprogramma waarin de klasse
<code>Breuk</code> gebruikt wordt.</p>
<pre><code>#include &lt;iostream.h&gt;
#include &quot;breuk.h&quot;

void main()
{
   Breuk b;

   cout &lt;&lt; b &lt;&lt; endl;
   b++;
   cout &lt;&lt; b &lt;&lt; endl;

   Breuk c(1,4);
   Breuk d(1,2);
   Breuk e;

   e = c + d;
   cout &lt;&lt; e &lt;&lt; endl;
}
</code></pre>
<h2 id="dynamische-objecten">Dynamische objecten</h2>
<p>Zoals C kent C++ ook het principe van het dynamisch reserveren van
geheugen voor gegevensopslag. In C++ zijn voor dit doel de operatoren
<code>new</code> en <code>delete</code> ingevoerd.</p>
<h3 id="de-new-bewerking">De <code>new</code> bewerking</h3>
<p>Met de <code>new</code> bewerking kan geheugen op dynamische wijze gereserveerd
worden. In tegenstelling tot C waar <code>malloc()</code> een ingebouwde functie
is, is in C++ <code>new</code> een ingebouwde bewerking. Deze bewerking wordt
toegepast op de typeinformatie.</p>
<h4 id="new-bij-een-niet-klasse"><code>new</code> bij een niet-klasse</h4>
<p>De eerste vorm waarin <code>new</code> gebruikt kan worden is de toepassing op een
enkelvoudig type. Als we bijvoorbeeld geheugen voor Ã©Ã©n int willen
reserveren dan kan dit zo:</p>
<pre><code>int *pi = new int;

*pi = 5;
</code></pre>
<p>De toepassing van de bewerking <code>new</code> op het type levert het adres op van
een blokje geheugen. In dit geheugen is plaats voor Ã©Ã©n getal van het
type <code>int</code>. In tegenstelling tot C is er geen cast-bewerking nodig.</p>
<h4 id="new-bij-een-klasse"><code>new</code> bij een klasse</h4>
<p>Dikwijls wordt de <code>new</code> bewerking gebruikt om geheugen te reserveren
voor objecten. We gebruiken dan als type-informatie de klassenaam. In
het volgende voorbeeld wordt een object van de klasse <code>Punt</code>
gereserveerd.</p>
<pre><code>Punt *pu = new Punt;
</code></pre>
<p>ofwel, in een andere schrijfwijze:</p>
<pre><code>Punt *pu;

pu = new Punt;
</code></pre>
<p>Bij het uitvoeren van de <code>new</code> bewerking gebeuren er eigenlijk twee
stappen:</p>
<ul>
<li>
<p><code>new</code> reserveert geheugen als nodig is voor de klasse.</p>
</li>
<li>
<p>Indien de reservatie gelukt is, wordt nog de constructor uitgevoerd.</p>
</li>
</ul>
<p>In het voorgaande voorbeeld wordt de constructor zonder parameter
uitgevoerd. Hierdoor worden de dataleden allebei nul.</p>
<p>Bij de klasse <code>Punt</code> is het mogelijk om bij het dynamisch reserveren van
een object meteen ook gegevens voor de initialisatie mee te geven. We
maken dan gebruik van de constructor met twee parameters.</p>
<pre><code>void fu()
{
   Punt *pa;
   Punt *pb;

   pa = new Punt(23,34);
   pb = new Punt(45,56);

   pa-&gt;druk();
   pb-&gt;druk();
}
</code></pre>
<p>Als in het bovenstaande voorbeeld de functie <code>fu()</code> gestart wordt,
worden er twee objecten in dynamisch geheugen gereserveerd. Omdat bij
<code>new</code> na de klassenaam twee getallen voorkomen, wordt de constructor met
twee parameters gestart. Na het reserveren van twee objecten wordt met
de methode <code>druk()</code> de coÃ¶rdinaten in <code>pa</code> en <code>pb</code> op het scherm
geschreven. Omdat <code>pa</code> en <code>pb</code> pointers zijn, moet een pijl gebruikt
worden om methoden te bereiken.</p>
<h3 id="de-delete-bewerking">De <code>delete</code> bewerking</h3>
<p>Als in het voorgaande voorbeeld het einde van de functie bereikt wordt,
houden de pointers <code>pa</code> en <code>pb</code> op te bestaan. Vermits ze allebei wijzen
naar dynamisch gereserveerd geheugen, zou hierdoor een geheugenlek
ontstaan. Daarom moet vÃ³Ã³r het einde van de functie het geheugen
vrijgegeven worden. Dit doen we met de <code>delete</code> bewerking.</p>
<pre><code>void fu()
{
   Punt *pa;
   Punt *pb;

   pa = new Punt(23,34);
   pb = new Punt(45,56);

   pa-&gt;druk();
   pb-&gt;druk();

   delete pa;
   delete pb;
}
</code></pre>
<p>Na het woord <code>delete</code> schrijven we de naam van de pointervariabele die
wijst naar het dynamisch geheugen. Voor elke <code>new</code> bewerking die in een
programma voorkomt moet er een overeenkomstige <code>delete</code> bewerking zijn.</p>
<h3 id="new-en-delete-bij-arrays"><code>new</code> en <code>delete</code> bij arrays</h3>
<p>Bij het gebruik van de bewerking <code>new</code> bestaat de mogelijkheid om
geheugen voor arrays te reserveren. We schrijven dan na <code>new</code> een
arraytype. De waarde tussen de rechte haken mag wel een variabele zijn.
Hierdoor kan de lengte van de array dynamisch bepaald zijn. In het
volgende voorbeeld krijgt <code>p</code> het adres van een blok van 100 charâ€™s.</p>
<pre><code>char *p = new char[100]
delete [] p;
</code></pre>
<p>Bij het vrijgeven van het geheugen met <code>delete</code> moet aangegeven worden
dat het gaat over een array. Daarom moeten voor de variabelenaam rechte
haken geschreven worden. De vrijgave van het geheugen moet expliciet
geschreven worden voordat een pointervariabele ophoudt te bestaan.</p>
<h3 id="het-gebruik-van-new-binnen-een-klasse">Het gebruik van <code>new</code> binnen een klasse</h3>
<p>Het is mogelijk om de hoeveelheid geheugen die nodig is binnen de klasse
ook dynamisch te reserveren. Op deze manier zijn er geen beperkingen op
de lengte van de binnen een klasse opgeslagen gegevens.</p>
<p>In het volgende voorbeeld wordt een klasse <code>Tekst</code> gedemonstreerd. Deze
klassen kan gebruikt worden om tekstobjecten te creÃ«ren. Om te vermijden
dat er conflicten ontstaan als er lange teksten opgeslagen moeten
worden, is de opslag van de string binnen een object dynamisch. De
klasse <code>Tekst</code> ziet er als volgt uit:</p>
<pre><code>class Tekst
{
private:

   char *ptekst;

public:
   Tekst(const char *pv = &quot;&quot;);
   ~Tekst();
   char *str() const
   {
      return( ptekst );
   }
   Tekst &amp;operator=(const Tekst &amp;t);
   Tekst &amp;operator+=(const Tekst &amp;t);
   Tekst operator+(const Tekst &amp;t);
};
</code></pre>
<p>Voor de opslag van de string binnen het object is er het private datalid
<code>ptekst</code>. De constructor</p>
<pre><code>Tekst(const char *pv = &quot;&quot;);

wordt opgeroepen als een +Tekst+ object met een char string initialiseren. Indien de parameter bij de oproep van de constructor ontbreekt, dan wordt een lege string als verstekwaarde gebruikt.

De implementatie van de constructor is als volgt:

Tekst::Tekst(const char *pv)
{
   ptekst = new char [strlen(pv) + 1];
   strcpy(ptekst, pv);
}
</code></pre>
<p>Met <code>new</code> worden zoveel bytes gereserveerd als de string lang is. Er is
ook een extra byte voor de nulwaarde op het einde. Het resultaat van
<code>strlen()</code> is immers de lengte van de string zonder de eindnul
meegerekend. De originele string wordt in het gereserveerde geheugen
gekopieerd. De kopieerbewerking is nodig om ervoor te zorgen dat object
een eigen string in eigendom heeft. Indien we alleen het adres van de
string zouden kopiÃ«ren, dan ontstaat er een situatie waarin een object
verwijst naar geheugen die niet door het object wordt beheerd. Dit zou
gevaarlijke situatie zijn.</p>
<h3 id="een-destructor-bijvoegen">Een destructor bijvoegen</h3>
<p>Omdat er in de constructor dynamisch geheugen wordt gereserveerd, is het
nodig dat in de klasse ook een destructor bestaat. Het prototype wordt
met een tilde geschreven:</p>
<pre><code>~Tekst();
</code></pre>
<p>Een destructor heeft geen parameters en geen terugkeertype. Een
destructor kan wel virtueel zijn (een constructor daarentegen niet). Ook
in de implementatie komt de tilde voor.</p>
<pre><code>Tekst::~Tekst()
{
   cout &lt;&lt; &quot;delete &quot; &lt;&lt; ptekst &lt;&lt; &quot;\n&quot;; // alleen voor test
   delete [] ptekst;
}
</code></pre>
<p>In deze destructor wordt met <code>delete</code> het geheugen van de string
vrijgegeven. De uitvoerbewerking staat er alleen maar om te kunnen zien
wanneer de destructor uitgevoerd wordt en is daarom niet noodzakelijk.</p>
<h3 id="de-klasse-tekst-gebruiken">De klasse <code>Tekst</code> gebruiken</h3>
<p>Het gebruik van de klasse Tekst is als volgt:</p>
<pre><code>#include &lt;iostream.h&gt;
#include &quot;tekst.h&quot;

int main()
{
   Tekst t(&quot;hallo&quot;);

   cout &lt;&lt; t.str() &lt;&lt; &quot;\n&quot;;

   return 0;
}
</code></pre>
<p>De definitie van de klasse plaatsen we best in een headerbestand. Zo
bevindt de definitie van <code>Tekst</code> zich in het bestand <code>tekst.h</code>. De tekst
<code>t</code> wordt geÃ¯nitialiseerd met de string <code>&quot;hallo&quot;</code>. Vlak voor het einde
van <code>main</code>() wordt de destructor opgeroepen voor het object <code>t</code>. met de
methode <code>str()</code> verkrijgen we het adres van de opgeslagen tekst. De
klasse <code>Tekst</code> kunnen we gebruiken zonder dat we iets zien van de wijze
waarop de implementatie binnen de klasse is gemaakt. Deze inkapseling is
Ã©Ã©n van de principes van het object georiÃ«nteerd programmeren.</p>
<h3 id="bewerkingen-in-een-klasse-bijvoegen">Bewerkingen in een klasse bijvoegen</h3>
<p>In het voorgaande voorbeeld is de klasse <code>Tekst</code> eerder beperkt. Daarom
voegen we een tweetal bewerkingen bij in de klasse. We zouden deze
bewerkingen kunnen bijvoegen in de vorm van klassefuncties zoals
bijvoorbeeld <code>druk()</code> in de klasse <code>Punt</code>. Een ander alternatief is het
veranderen van de betekenis van bewerkingstekens binnen een klasse. Dit
betekent dat een bewerkingsteken een nieuwe betekenis krijgt. Volgens
dit principe gaan we het <code>=</code> teken, <code>+=</code> teken en het <code>+</code> teken koppelen
aan een klassefunctie binnen de klasse <code>Tekst</code>. Binnen de definitie van
de klasse <code>Tekst</code> worden de prototypes voor deze twee bewerkingen
bijgevoegd.</p>
<pre><code>Tekst &amp;operator=(const Tekst &amp;t);
Tekst &amp;operator+=(const Tekst &amp;t);
Tekst operator+(const Tekst &amp;t);
</code></pre>
<p>Het zijn twee klassefuncties met een speciale naam. We laten het woord
<code>operator</code> volgen door het bewerkingsteken dat we een nieuwe betekenis
willen geven. De klassefuncties <code>operator=</code>, <code>operator+=</code> en <code>operator+</code>
hebben Ã©Ã©n formele parameter. Via deze parameter wordt de
rechter-operand van de bewerking doorgegeven. De linker-operand wordt
doorgegeven via de impliciete pointer naar het object. Met de plus
operator kunnen we dan schrijven:</p>
<pre><code>Tekst t1(&quot;dag &quot;);
Tekst t2(&quot;wereld&quot;);
Tekst t3(&quot;&quot;);

t3 = t1 + t2;
</code></pre>
<p>Deze <em>optelling</em> zou ook als volgt geschreven kunnen worden:</p>
<pre><code>t3 = t1.operator+(t2);
</code></pre>
<p>Deze schrijfwijze is niet zo goed leesbaar, maar geeft wel duidelijk
weer hoe de twee operands aan de optelling worden doorgegeven. De
implementaties van de <code>=</code> en <code>+=</code> bewerkingen zien er zo uit:</p>
<pre><code>Tekst &amp;Tekst::operator=(const Tekst &amp;t)
{
   delete ptekst;// verwijder de oude tekst
   ptekst = new char [strlen(t.str() ) + 1]; // ruimte voor nieuwe tekst
   strcpy(ptekst, t.str() );// kopieer tekst
   return( *this );
}

Tekst &amp;Tekst::operator+=(const Tekst &amp;t)
{
   char *poud;

   poud = ptekst;// hou oude tekst opzij

// reserveer ruimte voor nieuwe tekst
   ptekst = new char [strlen(poud) + strlen(t.str() ) + 1];

   strcpy(ptekst, poud);// kopieer eerste tekst
   strcat(ptekst, t.str() ); // voeg tweede tekst erbij
   delete poud;// verwijder oude tekst
   return( *this );
}
</code></pre>
<p>Bij elk van de twee bewerkingen wordt opnieuw dynamisch geheugen
gereserveerd omdat de lengte van de nieuwe tekst, die in een object
opgeslagen wordt, groter kan zijn dan de oude tekst. Telkens wordt het
betrokken object via <code>return</code> teruggegeven. Dit is nodig omdat het
resultaat van de bewerking ook van het type <code>Tekst</code> is.</p>
<p>De + bewerking kan kort geschreven worden:</p>
<pre><code>Tekst Tekst::operator+(const Tekst &amp;t)
{
   Tekst nt;// nieuwe tekst

   nt = *this;// kopieer eerste tekst
   nt += t;// voeg tweede tekst bij
   return( nt );// geef nieuwe tekst terug als resultaat
}
</code></pre>
<p>We maken gebruik van een lokaal <code>Tekst</code> object <code>nt</code>. Met een toekenning
en daarna <code>+=</code> bewerking worden de twee bronteksten samengevoegd in een
nieuwe tekst. Deze nieuwe tekst wordt als resultaat teruggegeven. In de
<code>+</code> bewerking wordt gebruik gemaakt van de eerder ontworpen <code>=</code> en <code>+=</code>
bewerkingen. Het terugkeer type is in dit geval gÃ©Ã©n referentietype.</p>
<h3 id="bewerkingen-in-een-klasse-gebruiken">Bewerkingen in een klasse gebruiken</h3>
<p>Het gebruik van de klasse <code>Tekst</code> is als volgt:</p>
<pre><code>#include &lt;iostream.h&gt;
#include &quot;tekst.h&quot;

int main()
{
   Tekst t(&quot;hallo&quot;);
   Tekst t2;
   Tekst t3(&quot;o&quot;);

   cout &lt;&lt; t.str() &lt;&lt; &quot;\n&quot;;
   t2 = t;
   t2 = t + t3;
   cout &lt;&lt; t2.str() &lt;&lt; &quot;\n&quot;;

   return 0;
}
</code></pre>
<p>Merk op dat er een verschil is tussen de twee bewerkingen met het =
teken in het volgende fragment:</p>
<pre><code>{
   Tekst ta(&quot;1234&quot;);
   Tekst tb = ta;
   Tekst tc(&quot;&quot;);

   tc = ta;
}
</code></pre>
<p>Bij het eerste = teken wordt de copyconstructor gestart om <code>tb</code> te
initialiseren; bij het tweede = teken wordt de klassefunctie
<code>operator=()</code> gestart. Let op: de copyconstructor hebben we niet zelf
bijgevoegd in de klasse <code>Tekst</code>. Daarom wordt de default copyconstructor
uitgevoerd. Deze is evenwel niet geschikt voor gebruik van zodra binnen
een klasse zelf dynamisch geheugen wordt bijgehouden. Dit is de reden
waarom het bovenstaand fragment problemen kan geven zolang geen eigen
versie van de copyconstructor binnen de klasse <code>Tekst</code> wordt bijgevoegd.</p>
<h2 id="objecten-binnen-objecten">Objecten binnen objecten</h2>
<p>In vele gevallen is het nuttig om een klasse te beschouwen als een
enkelvoudig type. We gaan dan gemakkelijker klassen gebruiken om daarmee
nieuwe klassen samen te stellen. De techniek die we nu voorstellen is
het gebruik van een bestaande klasse als type vaar dataleden van een
nieuwe klasse. Het voorbeeld, dat we geven, heeft te maken met lijnen.
Als we de gegevens van een lijn willen bijhouden, dan moeten we het
begin- en eindpunt van de lijn opslaan. Een lijn bestaat uit twee punten
of anders gezegd: de klasse <code>Lijn</code> bevat twee dataleden van de klasse
<code>Punt</code>. Dit principe wordt aggregatie genoemd. We demonstreren dit met
een voorbeeld.</p>
<pre><code>#include &lt;iostream.h&gt;
#include &lt;math.h&gt;
#include &quot;punt.h&quot;


class Lijn
{
private:
   Punt p1;
   Punt p2;

public:
   Lijn(int x1, int y1, int x2, int y2) : p1(x1,y1),
p2(x2, y2)
   {
   }
   double lengte();
};

double Lijn::lengte()
{
   double dx, dy;

   dx = p1.haalx() - p2.haalx();
   dy = p1.haaly() - p2.haaly();
   return( sqrt(dx*dx + dy*dy) );
}

int main()
{
   Lijn ln(1,2,4,6);

   cout &lt;&lt; ln.lengte() &lt;&lt; &quot;\n&quot;;

   return 0;
}
</code></pre>
<p>We maken in het voorbeeld een klasse <code>Lijn</code>. Deze klasse bevat twee
dataleden van het type <code>Punt</code>. Hiermee wordt het verband uitgedrukt dat
een lijn twee punten verbindt. De <code>Punt</code> dataleden <code>p1</code> en <code>p2</code> zijn
privaat. Dit betekent dat ze niet vrij toegankelijk zijn van buiten de
klasse. De klasse <code>Lijn</code> kent Ã©Ã©n constructor. Deze constructor verwacht
vier getallen als parameter. Dit zijn de twee coÃ¶rdinatenparen voor de
begin- en eindpunten. Voor deze constructor is een speciale schrijfwijze
toegepast. Als we de constructor als volgt zouden schrijven, dan zou de
compiler een foutmelding geven:</p>
<pre><code>Lijn::Lijn(int x1, int y1, int x2, int y2)
{
   p1.x = x1;
   p1.y = y1;
   p2.x = x2;
   p2.y = y2;
}
</code></pre>
<p>Wat is er nu fout aan deze schrijfwijze? De fout heeft te maken met de
beveiliging van de private dataleden. De dataleden <code>x</code> en <code>y</code> van de
twee <code>Punt</code> objecten zijn niet vrij toegankelijk. Vanuit de <code>Lijn</code>
constructor is er alleen maar toegang tot de publieke klassefuncties van
<code>p1</code> en <code>p2</code>. De dataleden <code>x</code> en <code>y</code> zijn privaat binnen de klasse
<code>Punt</code> en daarom niet toegankelijk. Wel is de constructor van <code>Punt</code>
toegankelijk. Er is echter in C++ geen mogelijkheid om rechtstreeks een
constructor te starten als een functieoproep. Daarom kent C++ een
speciale schrijfwijze om de dataleden van een klasse te initialiseren
met een constructor. Daarom wordt de <code>Punt</code> constructor als volgt
geschreven:</p>
<pre><code>Lijn(int x1, int y1, int x2, int y2) : p1(x1,y1),
p2(x2, y2)
{
}
</code></pre>
<p>Na de lijst van formele parameters volgt een dubbele punt. Hierna
vermelden we de namen van de dataleden die binnen <code>Lijn</code> voorkomen. Dit
zijn <code>p1</code> en <code>p2</code>. Na elk datalid noteren we de naam van de actuele
parameters tussen haken. Zo wordt <code>p1</code> geÃ¯nitialiseerd met <code>x1</code> en <code>y1</code>;
<code>p2</code> wordt geÃ¯nitialiseerd met <code>x2</code> en <code>y2</code>. Vanzelfsprekend moet er
binnen de klasse <code>Punt</code> een constructor bestaan die met deze parameters
overeen komt.</p>
<p>Met de functie lengte kan de lengte van een object van de klasse <code>Lijn</code>
berekend worden.</p>
<h2 id="klassen-afleiden">Klassen afleiden</h2>
<p>Als we van plan zijn om een bepaalde klasse uit te breiden met nieuwe
dataleden of klassefuncties, dan zouden we rechtstreeks in de
klassedefinitie deze dataleden of klassefuncties kunnen bijvoegen. Deze
strategie heeft echter nadelen, zeker als de klasse reeds een tijd in
gebruik is. Het is veiliger om de klasse ongewijzigd te laten en een
afleiding te maken van deze klasse. Dit betekent dat we een nieuwe
klasse ontwerpen die alle eigenschappen van een bestaande klasse
overerft. Deze strategie heeft twee voordelen:</p>
<ul>
<li>
<p>de bestaande klasse hoeft niet gewijzigd te worden</p>
</li>
<li>
<p>de functionaliteit van een bestaande klasse wordt volledig
overgenomen in de nieuwe klasse</p>
</li>
<li>
<p>de nieuwe klasse kan extra aangevuld worden met nieuwe dataleden en
klassefuncties</p>
</li>
</ul>
<p>Als we een klasse nodig hebben voor de voorstelling van een punt,
waarbij ook nog in de klasse een naam opgeslagen wordt, dan is er een
nieuwe klasse nodig. Als naam voor de nieuwe klasse kiezen we
<code>PuntmetNaam</code>. De originele klasse <code>Punt</code> laten we ongewijzigd. We maken
een afleiding van <code>Punt</code> en voegen er een naam aan toe.</p>
<p>De klasse definitie van +PuntmetNaam+ziet er als volgt uit:</p>
<pre><code>#include &lt;iostream.h&gt;
#include &quot;tekst.h&quot;
#include &quot;punt.h&quot;

class PuntmetNaam : public Punt
{
private:
   Tekst naam;

public:
   PuntmetNaam(int ix, int iy, char *nm) : Punt(ix, iy), naam(nm)
   {
   }
   void druk();
};
</code></pre>
<p>Op dezelfde regel als de klassenaam schrijven we de naam van de klasse
waarvan we willen afleiden. Het woord <code>public</code> geeft aan dat het gaat om
een publieke afleiding. Dit betekent dat alle private dataleden en
klassefuncties binnen <code>Punt</code> niet toegankelijk zijn vanuit de
klassefuncties van <code>PuntmetNaam</code>. De protected leden van <code>Punt</code> zijn wel
toegankelijk vanuit <code>PuntmetNaam</code> meer niet van buiten de klasse.</p>
<p>Binnen de klasse <code>PuntmetNaam</code> wordt een extra datalid bijgevoegd:
<code>Tekst naam</code>. Hiermee kunnen we een naam opslaan. De constructor voor
<code>PuntmetNaam</code> krijgt een extra parameter ten opzicht van die van <code>Punt</code>.
De derde parameter is string voor de naam. Door deze nieuwe constructor
wordt de oude (overgeÃ«rfde) constructor niet meer toegankelijk. Dit is
het herdefiniÃ«ren van een overgeÃ«rfde klassefunctie. De constructor
bevat na de parameterlijst een dubbele punt en daarna een lijst van te
initialiseren entiteiten: <code>Punt(ix, iy), naam(nm)</code>. Met de eerste
initialiseren worden de coÃ¶rdinaten <code>ix</code> en <code>iy</code> naar de <code>Punt</code>
constructor doorgegeven. Met de tweede wordt de naam geÃ¯nitialiseerd. We
zien dus twee soorten initialisators. Met een klassenaam geven we aan
met welke gegevens de superklasse wordt geÃ¯nitialiseerd. Met een naam
van een datalid geven we de initialisatie aan van een in de klasse zelf
voorkomend klasselid.</p>
<pre><code>void PuntmetNaam::druk()
{
   cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; naam.str();
   Punt::druk();
   cout &lt;&lt; &quot;&gt;&quot;;
}
</code></pre>
<p>Net zoals de constructor wordt ook de functie <code>druk()</code> opnieuw
gedefinieerd. Ook hier is er een verwijzing naar een klassefunctie van
de superklasse. Met <code>Punt::druk()</code> wordt een functie uit de superklasse
opgeroepen. De naam van de functie wordt voorafgegaan door de klassenaam
en twee dubbele punten. Als we dit zouden weglaten, dan ontstaat er
ongewild recursie.</p>
<p>In het hoofdprogramma worden twee objecten gedeclareerd. Telkens wordt
<code>druk()</code> uitgevoerd.</p>
<pre><code>int main()
{
   Punt p1(12,23);
   PuntmetNaam p2(56, 67, &quot;oorsprong&quot;);

   p1.druk();
   cout &lt;&lt; &quot;\n&quot;;
   p2.druk();
   cout &lt;&lt; &quot;\n&quot;;

   return 0;
}
</code></pre>
<p>Het verband tussen de twee klassen kan grafisch weergegeven worden. Deze
diagrammatechniek stamt uit Universal Modelling Language(UML).</p>
<p>!&lt;&gt;</p>
<p>Deze tekening geeft weer dat de klasse <code>PuntmetNaam</code> afgeleid is van de
klasse <code>Punt</code>. Elke rechthoek stelt een klasse voor. De naam binnen de
rechthoek stelt de klassenaam voor. Eventueel kunnen de dataleden en
klassefuncties elk met een aparte rechthoek bijgevoegd worden.</p>
<p>Het diagramma ziet er dan als volgt uit:</p>
<p>!&lt;&gt;</p>
<p>In deze vorm toont het diagramma duidelijk dat door erfenis de klasse
<code>PuntmetNaam</code> niet alleen <code>naam</code> als datalid heeft maar ook <code>x</code> en <code>y</code>.</p>
<h2 id="virtuele-klassefuncties">Virtuele klassefuncties</h2>
<p>Door het mechanisme van de afleiding is het mogelijk om een bepaalde
klasse als basisklasse te gebruiken. Van deze basisklasse worden
verschillende afleidingen gemaakt. De afgeleide klassen erven allemaal
het gedrag van de basisklasse. De basisklasse bevat het
gemeenschappelijk gedrag van de verschillende basisklassen. Dikwijls
zijn er in de basisklasse klassefuncties nodig waarvan het gedrag pas
definitief in de afgeleide klassen wordt bepaald. Daarom is het nodig
dat de taal C++ voorzien is van een mechanisme om de keuze van welke
klassefunctie gestart wordt (die uit de basisklasse of die uit de
afgeleide klasse) te verschuiven tot bij de uitvoering van het
programma. Dit mechanisme heet in C++ virtuele functie. In andere talen
worden ook wel de termen dynamische of late binding gebruikt.</p>
<p>Het concept virtuele functie is de kern van de taal C++ die het mogelijk
maakt om delen van software te ontwerpen die algemeen is en
onafhankelijk van alle later toe te voegen objecttypes.</p>
<p>Om dit concept duidelijk te maken starten we de uitleg van een
voorbeeld. In dit voorbeeld maken we een algemene klasse die voor de
opslag van een waarde wordt gebruikt. De virtuele functie maakt het
mogelijk om specifiek gedrag in een afgeleide klasse te gebruiken vanuit
een algemene klasse zonder de details te kennen van de afgeleide klassen
en zonder afbreuk te doen aan de algemeenheid van de basisklasse. In het
voorbeeld dat volgt willen we gewoon een waarde op het scherm drukken
zonder te weten van welk specifiek getaltype de waarde is.</p>
<h3 id="een-abstracte-klasse-maken">Een abstracte klasse maken</h3>
<p>We maken een basisklasse die gaat dienen voor de opslag van een waarde.
Als klassenaam kiezen we de naam <code>Waarde</code>. De eerste letter is een
hoofdletter, bijgevolg is dit een klassenaam. Deze klasse moet dienen om
een waarde van een nog niet gekend type op te slaan. We wensen nu nog
niet vast te leggen welk type gebruik zal worden want dan zou de klasse
<code>Waarde</code> niet algemeen bruikbaar zijn. De klasse <code>Waarde</code> zou moeten
kunnen werken met elk mogelijk getaltype.</p>
<pre><code>class Waarde
{
private:
    // geen datalid

public:
   // hier plaatsen we de vrij toegankelijke klassefuncties
};
</code></pre>
<p>De beslissing om geen datalid voor de waarde in de klasse <code>Waarde</code> te
plaatsen is een goede beslissing. We kunnen immers het datalid voor de
waarde in de afgeleide klassen plaatsen. De klasse <code>Waarde</code> is bedoeld
als basisklasse. We zullen van deze klasse nooit objecten maken. Zo
komen we meteen tot het begrip abstracte klasse. een abstracte klasse is
niet bedoeld om er concrete objecten mee te maken maar wel om een
algemeen gedrag te bepalen voor een reeks afgeleide klassen.</p>
<h3 id="een-virtuele-functie-maken">Een virtuele functie maken</h3>
<p>Bij dit voorbeeld is het gewenste algemeen gedrag van de klasse <code>Waarde</code>
de mogelijkheid om de opgeslagen waarde op het scherm te drukken. Daarom
plaatsen we een klassefunctie <code>druk()</code> in het publieke gedeelte.</p>
<pre><code>class Waarde   // abstracte klasse
{
public:
   virtual void druk() = 0;
};
</code></pre>
<p>De schrijfwijze van het prototype van <code>druk()</code> vertoont twee nieuwe
elementen:</p>
<ul>
<li>
<p>Voor <code>void</code> staat het woord <code>virtual</code></p>
</li>
<li>
<p>na de sluitende ronde haak staat <code>= 0</code></p>
</li>
</ul>
<p>Met het woord <code>virtual</code> geven we aan dat <code>druk()</code> een virtuele functie
is. De precieze werking wordt later duidelijk. Na <code>druk()</code> staat er
<code>= 0</code>. Hiermee geven we aan dat we voor <code>druk()</code> nog geen implementatie
voorzien. Deze implementatie moet ingevuld worden in de verschillende
afleidingen van de basisklasse. Deze = 0 is niet nodig om de functie
virtueel te maken maar wel om de klasse abstract te maken.</p>
<p>Van een abstracte klasse mogen we geen objecten maken. Wel is het
mogelijk om een pointer of een referentie naar een abstracte klasse te
maken.</p>
<pre><code>Waarde w1;// FOUT
Waarde *pw1// GOED
</code></pre>
<h3 id="afleidingen-maken">Afleidingen maken</h3>
<p>We maken twee afleidingen van de basisklasse. Een voor de opslag van een
geheel getal en een voor de opslag van een reÃ«el getal.</p>
<pre><code>class IWaarde : public Waarde
{
private:
   int intwaarde;

public:
   IWaarde(int iw) : intwaarde(iw)
   {
   }
   virtual void druk();
};

class FWaarde : public Waarde
{
private:
   double floatwaarde;

public:
   FWaarde(double iw) : floatwaarde(iw)
   {
   }
   virtual void druk();
};
</code></pre>
<p>Elke van deze afleidingen krijgt een privaat datalid voor de opslag van
de waarde. Het type van de waarde is telkens verschillend. In elke
afgeleide klasse is er een constructor voorzien om het object te
initialiseren. In elke afgeleide klasse wordt ook het prototype van
<code>druk()</code> bijgevoegd. Dit betekent dat de functionaliteit van de functie
<code>druk()</code> in de verschillende afgeleide klassen willen invullen. Het
woord virtual wordt herhaald voor het prototype, dit is niet verplicht.
Wel is het verplicht om bij het herdefiniÃ«ren van een virtuele functie
in een afgeleide klasse dezelfde formele parameters te voorzien als in
de basisklasse.</p>
<p>De twee <code>druk()</code> functies verschillen omdat de te drukken waarden van
een ander type zijn:</p>
<pre><code>void IWaarde::druk()
{
   cout &lt;&lt; &quot;geheel &quot; &lt;&lt; intwaarde;
}

void FWaarde::druk()
{
   cout &lt;&lt; &quot;reeel &quot; &lt;&lt; floatwaarde;
}
</code></pre>
<h3 id="objectcompatibiliteit">Objectcompatibiliteit</h3>
<p>In programmeertalen zoals Pascal, C en C++ is er een strikte
typecontrole door de compiler. De omzetting van het ene type naar het
andere type is niet altijd toegelaten. Op enkele uitzonderingen na is
het verboden om verschillende types te gebruiken in toekenningen. In C
en C++ kan deze beperking natuurlijk omzeild worden door de geforceerde
omzetting (cast), maar deze programmeertechniek is niet elegant en
veroorzaakt veel sneller fouten op. In C++ wordt de cast-bewerking
grotendeels overbodig door de mogelijkheid om in beperkte mate toch
toekenningen te doen tussen verschillende types.</p>
<p>In C++ is het toegelaten om een toekenning te doen van pointers (dit
geldt ook voor het referentietype) van een verschillende type. Er is wel
een voorwaarde: de pointer aan de linkerzijde van de toekenning moet van
een type zijn dat als superklasse voorkomt van de klasse van de pointer
aan de rechterzijde van de toekenning. Deze uitzondering is de enige op
de regel die zegt dat de twee types aan beide zijden van een toekenning
gelijk moeten zijn.</p>
<p>Een voorbeeld maakt dit duidelijk:</p>
<pre><code>Waarde *pw;
IWaarde *piw;
FWaarde *pfw;

pw = piw;   // ok, Waarde is de basisklasse van IWaarde
pw = pfw;   // ok, Waarde is de basisklasse van FWaarde
piw = pw;   // fout, Iwwaarde is geen basisklasse van Waarde
</code></pre>
<p>Deze compatibiliteit tussen verschillende pointertypes is nodig om
gebruik te kunnen maken van de virtuele functies. Ter verduidelijking is
hier nog het schema dat het verband tussen de verschillende klassen uit
het voorbeeld weergeeft.</p>
<p>!&lt;&gt;</p>
<h3 id="het-mechanisme-van-de-virtuele-functie">Het mechanisme van de virtuele functie</h3>
<p>Als we een virtuele klassefunctie oproepen via een pointer naar de
basisklasse komt effect van de virtuele functie tot uiting.</p>
<pre><code>IWaarde i1(5);
FWaarde f1(7.9);
Waarde *pw;

pw = &amp;i1;
pw-&gt;druk();
pw = &amp;f1;
pw-&gt;druk();
</code></pre>
<p>De pointer <code>pw</code> is een pointer naar een <code>Waarde</code> object. De declaratie
en het gebruik van <code>pw</code> is toegelaten. Objecten van een abstracte klasse
mogen niet, pointers naar een abstracte klasse mogen wel. Bij de eerste
toekenning wijst <code>pw</code> naar een <code>IWaarde</code> object. Bij de oproep van
<code>druk()</code> wordt de <code>IWaarde</code> variant van <code>druk()</code> gestart. Op het scherm
verschijnt <code>5</code>. Bij de tweede toekenning wijst <code>pw</code> naar een <code>FWaarde</code>
object. Bij de tweede oproep van <code>druk()</code> wordt de <code>FWaarde</code> variant van
<code>druk()</code> gestart. Op het scherm verschijnt <code>7.9</code>. In elk object van een
klasse met tenminste Ã©Ã©n virtuele functie zit extra informatie
opgeslagen over de klasse van het object. Door deze informatie is het
mogelijk dat bij de oproep van <code>druk()</code> bepaald wordt welke variant uit
een van de afgeleide klassen wordt gestart.</p>
<p>Dit is de volledige tekst van het voorbeeld:</p>
<pre><code>#include &lt;iostream.h&gt;

class Waarde   // abstracte klasse
{
public:
   virtual void druk() = 0;
};

class IWaarde : public Waarde
{
private:
   int intwaarde;

public:
   IWaarde(int iw) : intwaarde(iw)
   {
   }
   virtual void druk();
};

class FWaarde : public Waarde
{
private:
   double floatwaarde;

public:
   FWaarde(double iw) : floatwaarde(iw)
   {
   }
   virtual void druk();
};

void IWaarde::druk()
{
   cout &lt;&lt; &quot;geheel &quot; &lt;&lt; intwaarde;
}

void FWaarde::druk()
{
   cout &lt;&lt; &quot;reeel &quot; &lt;&lt; floatwaarde;
}

void toon(Waarde *pw)
{
   pw-&gt;druk();
}

int main()
{
   //Waarde ww;    fout Waarde is een abstracte klasse
   IWaarde i1(5);
   FWaarde f1(7.9);
   toon( &amp;i1 );
   toon( &amp;f1 );

   Waarde *pw1 = new IWaarde(256);
   Waarde *pw2 = new FWaarde(1.0/3.0);
   pw1-&gt;druk();
   pw2-&gt;druk();
}
</code></pre>
<p>In het voorbeeld wordt het principe van de virtuele functie tweemaal
gedemonstreerd. Eenmaal worden adressen van objecten aan de functie
<code>toon()</code> doorgegeven. De functie <code>toon</code> is ontwerpen met het doel de
waarde van het doorgegeven object te tonen. Het object wordt doorgegeven
via zijn adres. Dit is efficiÃ«nter dan de volledige waarde door te
geven. De functie <code>toon()</code> verwacht het adres van een <code>Waarde</code> object.
Vermits <code>Waarde</code> een abstracte basisklasse is van <code>IWaarde</code> of
<code>FWaarde</code>, kan het doorgegeven object een <code>IWaarde</code> of een <code>FWaarde</code>
object zijn. Gezien vanuit de functie <code>toon()</code> kan niet op voorhand
voorspeld worden of het doorgegeven object een <code>IWaarde</code> of een
<code>FWaarde</code>. Dit is de reden waarom we een virtuele functie gebruiken als
mechanisme voor de start van <code>druk()</code>. Binnen <code>toon()</code> is er geen kennis
nodig over de mogelijke specialisaties van <code>Waarde</code>. We kunnen dit
voorbeeld besluiten met te zeggen dat een <code>Waarde</code> object toonbaar is;
de waarde van het object kan verschillend zijn in de verschillende
afleidingen. Dit verschil in gedrag wordt vastgelegd in de implementatie
van de afgeleide klassen.</p>
<h2 id="constante-objecten">Constante objecten</h2>
<p>Het is mogelijk om binnen de klassedeclaratie voorzieningen te treffen
om constante objecten correct te behandelen. Een constant object is een
object dat niet wijzigbaar is. Dit geven we aan bij de declaratie met
het woord <code>const</code>. Bijvoorbeeld:</p>
<pre><code>const Punt pc(45,67);
</code></pre>
<p>Het object pc is niet wijzigbaar; bijgevolg mogen voor dit object alleen
klassefuncties gestart worden die garanderen dat er geen van de
dataleden gewijzigd wordt. In de klassedeclaratie van Punt zien we na
sommige functienamen het woord <code>const</code> staan. Hiermee wordt aangegeven
dat de functie gaan dataleden wijzigt. Indien toch een wijziging van een
datalid binnen een klassefunctie gebeurt, wordt dit als fout door de
compiler gemeld.</p>
<pre><code>#include &lt;iostream.h&gt;

// werken met constante objecten

class Punt
{
private:
   int x;
   int y;

public:
   Punt(int ix = 0, int iy = 0) : x(ix), y(iy)
   {
   }
   void druk() const
   {
      cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; x &lt;&lt;&quot;,&quot; &lt;&lt; y &lt;&lt;&quot;&gt;&quot; &lt;&lt; endl;
   }

   // geen wijzigingen van dataleden toegelaten in const functies
   int haalx() const
   {
      // x++; fout
      return(x);
   }
   int haaly() const
   {
      return(y);
   }

   void zetx(int ix)
   {
      x = ix;
   }
   void zety(int iy)
   {
      y = iy;
   }
};

int main()
{
   Punt p1(2,3);
   const Punt p2(4,5);

   p1.druk();
   p2.druk();
   // p2.zetx(8); fout p2 kan niet gewijzigd worden

   return 0;
}
</code></pre>
<p>In main worden twee objecten gedeclareerd: <code>p1</code> en <code>p2</code>. De laatste is
een constante. Dit betekent dat alleen const functies bij dit object
gestart kunnen worden.</p>
<h2 id="statische-leden-in-een-klasse">Statische leden in een klasse</h2>
<p>Statische dataleden zijn leden waarvoor slechts Ã©Ã©nmaal geheugenruimte
wordt gereserveerd. In het volgende voorbeeld bestaat er binnen de
klasse <code>Punt</code> een statisch dataveld aantal. De geheugenruimte bestaat
slechts Ã©Ã©nmaal. Elk object van het type <code>Punt</code> heeft een eigen <code>x</code> en
<code>y</code> veld, maar het veld aantal is gemeenschappelijk voor de hele klasse.
De toegang tot aantal verloopt niet via een object maar wel via de
klasse. Het veld aantal wordt in dit voorbeeld gebruikt om bij te houden
hoeveel objecten van de klasse <code>Punt</code> er bestaan. Deze boekhouding wordt
met behulp van de constructor en destructor georganiseerd. Telkens als
we de constructor of destructor doorlopen wordt aantal met 1 verhoogd of
verlaagd. Door het feit dat aantal privaat is, zijn we er zeker van dat
aantal niet buiten de klasse gewijzigd kan worden. Daarom zijn er ook
toegangsfuncties bijgevoegd. Dit zijn <code>init_aantal()</code> en
<code>haal_aantal()</code>. Dit zijn statische functies. Dit betekent dat ze niet
in het kader van een object worden gestart, maar wel binnen de klasse.</p>
<p>De geheugenruimte voor een statisch datalid moet expliciet gereserveerd
worden.</p>
<pre><code>#include &lt;iostream.h&gt;

// statische leden in een klasse

class Punt
{
private:
   int x;
   int y;
   static int aantal;

public:
   Punt(int ix = 0, int iy = 0) : x(ix), y(iy)
   {
      aantal++;
   }
   ~Punt()
   {
      aantal--;
   } // destructor

   void druk() const;
   int haalx() const
   {
      return(x);
   }
   int haaly() const
   {
      return(y);
   }
   void zetx(int ix)
   {
      x = ix;
   }
   void zety(int iy)
   {
      y = iy;
   }

   // statische klassefuncties worden zonder this opgeroepen
   static void init_aantal()
   {
      aantal = 0;
   }
   static int haal_aantal()
   {
      return( aantal);
   }
};

void druk();

void Punt::druk() const
{
   ::druk();// de twee dubbele punten zijn nodig voor recursie
            // te vermijden
   cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; x &lt;&lt;&quot;,&quot; &lt;&lt; y &lt;&lt;&quot;&gt;&quot; &lt;&lt; endl;
}

void druk()
{
   cout &lt;&lt; &quot;cv10 &quot;;
}

// de geheugenruimte voor statische dataleden
// moet expliciet gereserveerd worden

int Punt::aantal;

void fu()
{
   Punt p1(2,3);
   const Punt p2(4,5);

   p1.druk();
   p2.druk();

   cout &lt;&lt; &quot;aantal punten &quot; &lt;&lt; Punt::haal_aantal() &lt;&lt; endl;
}

int main()
{
   // oproep zonder object
   Punt::init_aantal();

   fu();
   cout &lt;&lt; &quot;aantal punten &quot; &lt;&lt; Punt::haal_aantal() &lt;&lt; endl;

   return 0;
}
</code></pre>
<h2 id="de--operator-bij-reeksen">De [] operator bij reeksen</h2>
<p>In dit voorbeeld wordt gedemonstreerd hoe het mogelijk om de index bij
arrays te controleren. Het is mogelijk om binnen een klasse een nieuwe
betekenis te geven aan de <code>operator\[\]</code>. We kunnen zo een klasse laten
werken als een array uit C of Pascal. Dit geeft ons de mogelijkheid om
de waarde van de index te controleren.</p>
<p>De klasse <code>Reeks</code> heeft een private pointer naar een array van <code>int</code>&rsquo;s.
Deze array wordt gereserveerd in de constructor en wordt terug
vrijgegeven in de destructor. We houden binnen de klassen ook de lengte
bij en het datalid lengte. De functie <code>controle_index()</code> wordt gebruikt
om de index te controleren en eventueel een foutmelding te geven. Bij
fout wordt het programma afgebroken met <code>exit()</code>;. De <code>operator\[\]</code>
ontvangt de index, controleert die en geeft dan de gewenste dat terug.
Het prototype ziet er als volgt uit:</p>
<pre><code>int&amp; operator [] ( unsigned long index )
</code></pre>
<p>Merk op dat het terugkeertype een referentietype is. Dit is nodig om de
inhoud van de reeks te kunnen wijzigen.</p>
<pre><code>#include &lt;iostreams.h&gt;
#include &lt;stdlib.h&gt;

// een toepassing van de [] operator

class Reeks
{
private:
   int *data;
   unsigned long lengte;

protected:
   void controle_index( unsigned long index, int lijnnr )
   {
      if ( index &gt;= lengte )
      {
         cout &lt;&lt; &quot;arrayindex-fout in regel &quot;
              &lt;&lt; lijnnr&lt;&lt; &quot; index &quot; &lt;&lt; index &lt;&lt; endl;
         exit(1);
      }
   }

public:
   Reeks(unsigned long grootte)
   {
      lengte = grootte;// hou de grootte bij
      data = new int[grootte];// reserveer ruimte
      cout &lt;&lt; &quot;Reeks constructor\n&quot;;
   }
   ~Reeks()
   {
      delete [] data;// geef reeks vrij
      cout &lt;&lt; &quot;Reeks destructor\n&quot;;
   }

   int&amp; operator [] ( unsigned long index )
   {
      controle_index( index , __LINE__ );// eerst controle
      return data[index];
   }
};

int main()
{
   Reeks lijst(10);

   for (int i=0; i&lt;20; i++)
   {
      lijst[i] = i;
      cout &lt;&lt; lijst[i];
   }

   return 0;
}
</code></pre>
<p>In <code>main()</code> wordt een reeks van 10 gehele getallen gecreÃ«erd. De lijst
wordt opgevuld met getallen en hier ontstaat een fout: bij <code>i = 10</code>
wordt het programma afgebroken.</p>
<h2 id="sjablonen-algemene-reeksen">Sjablonen: algemene reeksen</h2>
<p>Het voorgaande voorbeeld was niet flexibel genoeg. Daarom wordt de
klasse <code>Reeks</code> algemener gemaakt door sjablonen (templates) te
gebruiken. Hierdoor is <code>Reeks</code> onafhankelijk van de opgeslagen soort.
<code>Reeks</code> in niet meer een lijst van <code>int</code>&rsquo;s maar wel van klasse <code>T</code>
elementen. Dit zien we aan de naam van de klasse:</p>
<pre><code>template&lt;class T&gt;
class Reeks
</code></pre>
<p>De klasse <code>Reeks</code> kent nu een typeparameter <code>T</code>. Hiermee kunnen we
aangeven van welke klasse de gegevens zijn. In heel de klasse is int
door <code>T</code> vervangen. De klasse <code>Reeks</code> is hierdoor algemener geworden.
Voor het overige is <code>Reeks</code> niet gewijzigd.</p>
<pre><code>#include &lt;iostreams.h&gt;
#include &lt;stdlib.h&gt;

// reeks.h een algemene reeks

template&lt;class T&gt;
class Reeks
{
private:
   T *data;
   unsigned long lengte;

protected:
   void controle_index( unsigned long index, int lijnnr )
   {
      if ( index &gt;= lengte )
      {
         cout &lt;&lt; &quot;arrayindex-fout in regel &quot;
         &lt;&lt; lijnnr&lt;&lt; &quot; index &quot; &lt;&lt; index &lt;&lt; endl;
         exit(1);
      }
   }

public:
   Reeks(unsigned long grootte)
   {
      lengte = grootte;
      data = new T[grootte];
      cout &lt;&lt; &quot;Reeks&lt;T&gt; constructor\n&quot;;
   }
   ~Reeks()
   {
      delete [] data;
      cout &lt;&lt; &quot;Reeks&lt;T&gt; destructor\n&quot;;
   }

   T&amp; operator [] ( unsigned long index )
   {
      controle_index( index , __LINE__ );
      return data[index];
   }
};
</code></pre>
<p>In het hoofdprogramma maken we een reeks van <code>int</code> getallen. We moeten
het type <code>int</code> als parameter meegeven:</p>
<pre><code>Reeks&lt;int&gt;lijst(10);
Reeks&lt;double&gt;lijst2(100);
Reeks&lt;Punt&gt;lijst3(5);
</code></pre>
<p>Het actuele type wordt vermeld tussen kleiner en groter-dan tekens.</p>
<pre><code>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;reeks.h&quot;

// sjablonen: algemene reeksen

int main()
{
   Reeks&lt;int&gt; lijst(10);

   for (int i=0; i&lt;20; i++)
   {
      lijst[i] = i;
      cout &lt;&lt; lijst[i];
   }

   return 0;
}
</code></pre>
<p>De reeks in dit voorbeeld is zo algemeen geworden dat we dit type in
veel gevallen kunnen toepassen. We hoeven niet meer voor elke soort
gegevens een nieuwe reeks te ontwerpen.</p>
<h2 id="uitzonderingen">Uitzonderingen</h2>
<p>Uitzonderingen (exceptions) laten toe om fouten op een gepaste manier af
te handelen. In de voorgaande voorbeelden wordt de arrayfout drastisch
afgehandeld. Het programma wordt gewoon afgebroken. Door gebruik te
maken van uitzonderingen kan de foutafhandeling aangepast worden aan de
noden van de gebruiker van een klasse. Binnen de klasse wordt in een
foutsituatie de <code>throw</code> bewerking uitgevoerd. Hiermee wordt de fout aan
de gebruiker van de klassen gemeld.</p>
<pre><code>throw Fout();
</code></pre>
<p>Aan <code>throw</code> wordt een object van een klasse meegegeven. Hiermee wordt de
fout geÃ¯dentificeerd. <code>Fout()</code> is de oproep van de standaard constructor
zonder parameter. Om aan te geven dat we op mogelijke fouten reageren,
definiÃ«ren we een <code>try</code>-blok.</p>
<pre><code>try
{

}
catch(Fout)
{
   // foutafhandeling
}
</code></pre>
<p>Alle acties binnen het <code>try</code>-blok kunnen onderbroken worden door een
<code>throw</code>. Alle bestaande objecten worden automatisch afgebroken door hun
destructor. Dit geldt niet voor objecten die we dynamisch met <code>new</code>
hebben gereserveerd. Het kan daarom nodig zijn om pointers naar een
klasse op te nemen binnen een nieuwe klasse zodat de destructor van deze
nieuwe klassen voor het vrijgeven van de pointer zorgt.</p>
<pre><code>#include &lt;iostream.h&gt;

// uitzonderingen

class Fout // dit is de foutklasse
{
};

class Gegeven
{
private:
   int getal;

public:
   Gegeven(int geg=0) : getal(geg)
   {
      cout &lt;&lt; &quot;Gegeven(&quot; &lt;&lt; getal&lt;&lt;&quot;) constructor&quot; &lt;&lt; endl;
   }
   ~Gegeven()
   {
      cout &lt;&lt; &quot;Gegeven(&quot; &lt;&lt; getal&lt;&lt;&quot;) destructor&quot; &lt;&lt; endl;
   }
};

void fu()
{
   Gegeven g = 2;
   Gegeven *pg;

   pg = new Gegeven(3);
   throw Fout();// g wordt afgebroken
   // pg niet
}

void fu2()
{
   Gegeven h = 4;

   fu();// h wordt afgebroken
}

int main()
{
   try// probeer fu2() te starten
   {
      fu2();
   }
   catch(Fout)// van fouten hier op
   {
      cout &lt;&lt; &quot;fout&quot; &lt;&lt; endl;
   }

   return 0;
}
</code></pre>
<p>In de functie <code>fu()</code> wordt een <code>throw</code> uitgevoerd. Hierdoor worden <code>h</code>
en <code>g</code> automatisch afgebroken. Dit is niet het geval voor het object dat
door <code>pg</code> wordt aangewezen. In <code>main()</code> komen we terecht in het
<code>catch</code>-blok en wordt de nodige actie ondernomen.</p>
<h2 id="een-algemene-reeks-met-uitzondering">Een algemene reeks met uitzondering</h2>
<p>De algemene reeks is nu met uitzonderingen beveiligd. De foutklasse
<code>Arrayfout</code> houdt de foutmelding in tekstvorm bij. Binnen
<code>controle_index()</code> kan een <code>throw</code> gestart worden.</p>
<pre><code>// sjabloon Reeks met uitzondering

class Arrayfout
{
private:
   char *melding;

public:
   Arrayfout(char *p) : melding(p)
   {
   }
   char *foutmelding()
   {
      return( melding );
   }
};


template &lt;class T&gt;
class Reeks
{
private:
   T *data;
   unsigned long lengte;

protected:
   void controle_index( unsigned long index, int lijnnr )
   {
      if ( index &gt;= lengte )
      {
         throw Arrayfout(&quot;arrayindex-fout&quot;);
      }
   }

public:
   Reeks(unsigned long grootte)
   {
      lengte = grootte;
      data = new T[grootte];
      cout &lt;&lt; &quot;Reeks constructor\n&quot;;
   }
   ~Reeks()
   {
      delete [] data;
      cout &lt;&lt; &quot;Reeks destructor\n&quot;;
   }
   T&amp; operator [] ( unsigned long index )
   {
      controle_index( index , __LINE__ );
      return data[index];
   }
};
</code></pre>
<p>In het hoofdprogramma is een <code>try</code> en <code>catch</code>-blok bijgevoegd. Hiermee
kunnen we de arrayfout opvangen.</p>
<pre><code>#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
#include &quot;vreeks.h&quot;

int main()
{
   try// probeer
   {
      Reeks&lt;int&gt; lijst(10);// een lijst van 10 int's

      for (int i=0; i&lt;20; i++)
      {
         lijst[i] = i;
         cout &lt;&lt; lijst[i];
      }
   }
   catch(Arrayfout &amp;f)// vang arrayfout
   {
      cout &lt;&lt; f.foutmelding();// toon de foutmelding
   }

   return 0;
}
</code></pre>
<h2 id="reeks-template-met-automatische-uitbreiding"><code>Reeks</code> template met automatische uitbreiding</h2>
<p>Het volgende voorbeeld is het bestand <code>nvreeks.h</code>. Deze template klasse
is in staat om de capaciteit van de opslag te vergroten zonder dat er
gevens verloren gaan.</p>
<p>!&lt;&gt;</p>
<p>In het volgende testprogramma wordt het gebruik van deze reeks
gedemonstreerd.</p>
<pre><code>// cppvb17.cpp
#include &lt;stdio.h&gt;
#include &quot;nvreeks.h&quot;

int main()
{
   try
   {
      Reeks&lt;int&gt; tab(10);

      for (int i=0; i&lt;20; i++)
      {
         int sq = i*i;
         tab.voegbij(sq);
      }

      for (int i=0; i&lt;tab.grootte(); i++)
      {
         printf(&quot;%d: %d\n&quot;, i, tab[i]);
      }
   }
   catch(Arrayfout)
   {
      printf(&quot;Arrayfout\n&quot;);
   }
   catch(...)
   {
      printf(&quot;onbekende fout\n&quot;);
   }

   return 0;
}
</code></pre>
<p>In het bovenstaand programma zullen de <code>catch</code> blokken nooit bereikt
worden omdat de reeks automatisch vergroot wordt. Er wordt gestart met
grootte 10 en geÃ«indigd met 20.</p>
<h2 id="pointers-opslaan-in-een-container">Pointers opslaan in een container</h2>
<p>In dit voorbeeld is voor het inhoudstype <code>T</code> gekozen voor de pointer
<code>Info \*</code>.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;nvreeks.h&quot;

class Info
{
public:
   Info(int g): getal(g)
   {
   }
   void toon()
   {
      printf(&quot;%d\n&quot;, getal);
   }
private:
   int getal;
};

int main()
{
   try
   {
      Reeks&lt;Info *&gt; tab(10);


      for (int i=0; i&lt;22; i++)
      {
         int sq = i*i;
         tab.voegbij(new Info(sq));
      }

      // alle Info's tonen
      for (int i=0; i&lt;tab.grootte(); i++)
      {
         tab[i]-&gt;toon();
      }

      // alle Info's vrijgeven
      for (int i=0; i&lt;tab.grootte(); i++)
      {
         tab[i]-&gt;toon();
      }
   }
   catch(Arrayfout)
   {
      printf(&quot;Arrayfout\n&quot;);
   }
   catch(...)
   {
      printf(&quot;onbekende fout\n&quot;);
   }
}
</code></pre>
<h2 id="een-container-als-klassevariabele">Een container als klassevariabele</h2>
<p>In dit voorbeeld is de container een klassevariabele. .<em>cppvb19.cpp</em></p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;nvreeks.h&quot;

class Info
{
public:
   Info(int g): getal(g)
   {
   }
   void toon()
   {
      printf(&quot;%d\n&quot;, getal);
   }

private:
   int getal;
};

class Gegevens
{
public:
   Gegevens(int n): lijst(n)
   {
      for (int i=0; i&lt;n; i++)
      {
         lijst.voegbij(new Info(i * i));
      }
   }
   void toon()
   {
      printf(&quot;Gegevens:\n&quot;);
      for (int i=0; i&lt;lijst.grootte(); i++)
      {
         lijst[i]-&gt;toon();
      }
   }
   ~Gegevens()
   {
      for (int i=0; i&lt;lijst.grootte(); i++)
      {
         delete lijst[i];
      }
   }

private:
   Reeks&lt;Info *&gt; lijst;
};


int main()
{
   try
   {
      Gegevens g(22);
      g.toon();
   }
   catch(Arrayfout)
   {
      printf(&quot;Arrayfout\n&quot;);
   }
   catch(...)
   {
      printf(&quot;onbekende fout\n&quot;);
   }

   return 0;
}
</code></pre>
<h2 id="de-stl-containerbibliotheek">De STL containerbibliotheek</h2>
<h3 id="een-vector-voorbeeld">Een vector voorbeeld</h3>
<p>In dit voorbeeld wordt het gebruik van <code>vector</code> getoond.</p>
<pre><code>#include &lt;vector&gt;

using namespace std;

class Punt
{
private:
  int x;
  int y;

public:
  Punt(int ix, int iy) : x(ix), y(iy)
  {
  }

  void toon()
  {
    printf(&quot;%d, %d\n&quot;, x, y);
  }
};


int main()
{
   vector&lt;Punt *&gt; lijst;

   for (int i=0; i&lt;20; i++)
   {
      Punt *p = new Punt(1+i,2+i);
      lijst.push_back(p);
   }



   for (int i= 0;i&lt;lijst.size(); i++)
   {
      lijst[i]-&gt;toon();
   }

   vector&lt;Punt *&gt;::iterator it = lijst.begin();
   while (it != lijst.end())
   {
     Punt *q = *it;
     q-&gt;toon();

     it++;
   }


   for (int i= 0;i&lt;lijst.size(); i++)
   {
      delete lijst[i];
   }

   return 0;
}
</code></pre>
<h3 id="een-list-voorbeeld">Een list voorbeeld</h3>
<p>Hier is het voorgaande voorbeeld overgenomen en <code>vector</code> door <code>list</code>
vervangen. De herhaling waarbij de rechte haken <code>\[\]</code> worden gebruikt
voor indexering is geschrapt. Bij <code>list</code> en andere containers is dit
niet mogelijk.</p>
<pre><code>#include &lt;list&gt;

using namespace std;

class Punt
{
private:
  int x;
  int y;

public:
  Punt(int ix, int iy) : x(ix), y(iy)
  {
  }
  ~Punt()
  {
    printf(&quot;~Punt\n&quot;);
  }

  void toon()
  {
    printf(&quot;%d, %d\n&quot;, x, y);
  }
};


int main()
{
   list&lt;Punt *&gt; lijst;

   for (int i=0; i&lt;20; i++)
   {
      Punt *p = new Punt(1+i,2+i);
      lijst.push_back(p);
   }

   list&lt;Punt *&gt;::iterator it = lijst.begin();
   while (it != lijst.end())
   {
     Punt *q = *it;
     q-&gt;toon();

     it++;
   }


   it = lijst.begin();
   while (it != lijst.end())
   {
     Punt *q = *it;
     delete q;

     it++;
   }

   return 0;
}
</code></pre>
<h3 id="geheugenlekken-opsporen">Geheugenlekken opsporen</h3>
<p>In dit voorbeeld wordt een ingenieus systeem toegepast om geheugenlekken
op te sporen. Elke klasse moet afgeleid worden van <code>GElem</code>. Er moet ook
een enkel globaal GLijst gemaakt worden. Op het einde van het programma
wordt automatisch gemeld welke objecten nog niet vrijgegeven worden.</p>
<pre><code>#ifndef DBG_GEHEUGEN

#include &lt;stdio.h&gt;
#include &lt;list&gt;

using namespace std;

// deze klasse is een element bedoeld om in een lijst
// op te slaan. Omdat vanuit deze klasse verwezen
// wordt naar de lijst klasse en omdat dit compilatiefouten
// geeft, wordt de lijstklasse als parameter class T doorgegeven

template&lt;class T&gt;
class GElem_tm     // dit is de elementklasse met template parameter
{
public:
   GElem_tm()
   {
      printf(&quot;GElem()\n&quot;);
      T::haal().voegbij(this); // T wordt GLijst
   }
   ~GElem_tm()
   {
      printf(&quot;~GElem()\n&quot;);
      T::haal().verwijder(this); // T wordt GLijst
   }

   // deze functie moet een andere invulling
   // krijgen in de afleiding
   virtual void toon()
   {
      printf(&quot;GElem\n&quot;);
   }
};

class GLijst;  // voorwaartse declaratie van een klasse
               // hiermee wordt de compiler verteld dat
               // deze naam een klasse is

          // dit is de elementklasse met template parameter
          // de actuele parameter is GLijst
typedef GElem_tm&lt;GLijst&gt; GElem;


// de klasse GLijst houd een lijst van GElem bij
// elke in de toepassing gebruikte klasse
// moet overerven van GElem

class GLijst
{
public:
   GLijst()
   {
      printf(&quot;GLijst()\n&quot;);
   }
   void voegbij(GElem *em)
   {
      lijst.push_back(em);
   }
   void verwijder(GElem *em)
   {
      lijst.remove(em);
   }
   void toon()
   {
      printf(&quot;GLijst:\n&quot;);

      printf(&quot;lijst van nog niet vrijgegeven objecten\n&quot;);

      list&lt;GElem *&gt;::iterator it = lijst.begin();
      while (it != lijst.end())
      {
         GElem *q = *it;
         q-&gt;toon();

         it++;
      }

   }
   ~GLijst()
   {
      printf(&quot;~GLijst\n&quot;);
      list&lt;GElem *&gt;::iterator it = lijst.begin();
      while (it != lijst.end())
      {
         printf(&quot;element vergeten vrij te geven\n&quot;);
         GElem *q = *it;
         q-&gt;toon();


      /* Deze delete zorgt er ook voor dat het GElem uit
         de lijst verwijderd is. Om problemen te vermijden
         met it laten we it steeds naar het begin van de lijst
         wijzen.
       */
         // verwijder GElem uit lijst en geheugen
         delete *it;

         // het begin van de lijst is veranderd,
         // daarom opnieuw instellen
         it = lijst.begin();

         // dit zou fout zijn
         //  it++;
      }
   }


   // deze functie geeft een referentie naar het
   // ene en enige GLIijst object terug
   static GLijst &amp;haal()
   {
       return geheugen;
   }
   // dit is een statisch GLijst object
   static GLijst geheugen;

private:
   list&lt;GElem *&gt; lijst;
};

#endif

#include &lt;stdio.h&gt;
#include &quot;dbg-geheugen.h&quot;

using namespace std;

// dit is een klasse die getest wordt
// tegen geheugenlekken, vandaar
// de erfenis van GElem

class Punt : public GElem
{
private:
  int x;
  int y;

public:
  Punt(int ix, int iy) : x(ix), y(iy)
  {
  }
  ~Punt()
  {
    printf(&quot;~Punt\n&quot;);
  }

  void toon()
  {
    printf(&quot;Punt: %d, %d\n&quot;, x, y);
  }
};


// dit is het object met daarin de lijst
// de constructor en destructor worden
// automatisch gestart
GLijst GLijst::geheugen;

int main()
{
   printf(&quot;start\n&quot;);

   Punt *p1 = new Punt(5,6);
   Punt *p2 = new Punt(7,8);
   Punt *p3 = new Punt(10,10);


   // deze toon geeft al aan dat er
   // Punt objecten in het geheugen
   // zitten
   GLijst::geheugen.toon();
   printf(&quot;einde\n&quot;);

   // nadat deze accolade overschreden is,
   // wordt de destructor van GLijst gestart
   // en die meldt dat er nog 3 objecten
   // in het geheugen zitten

   return 0;
}
</code></pre>
<h2 id="qt-voorbeelden">Qt Voorbeelden</h2>
<h3 id="kleinste-voorbeeld">Kleinste voorbeeld</h3>
<p>Dit is een klein Qt voorbeeld met een <code>paint()</code> functie.</p>
<pre><code>#include &lt;qapplication.h&gt;
#include &lt;qpushbutton.h&gt;
#include &lt;qfont.h&gt;
#include &lt;qpainter.h&gt;


class MyWidget : public QWidget
{
public:
    MyWidget( QWidget *parent=0, const char *name=0 );

protected:
    void paintEvent( QPaintEvent * );
};


MyWidget::MyWidget( QWidget *parent, const char *name )
        : QWidget( parent, name )
{
    setMinimumSize( 200, 120 );
    setMaximumSize( 200, 120 );

    QPushButton *quit = new QPushButton( &quot;Quit&quot;, this, &quot;quit&quot; );
    quit-&gt;setGeometry( 62, 40, 75, 30 );
    quit-&gt;setFont( QFont( &quot;Times&quot;, 18, QFont::Bold ) );

    connect( quit, SIGNAL(clicked()), qApp, SLOT(quit()) );
}

void MyWidget::paintEvent( QPaintEvent * )
{
    QString s = &quot;Hallo&quot;;
    QPainter p( this );
    p.drawText( 20, 20, s );
}


int main( int argc, char **argv )
{
    QApplication a( argc, argv );

    MyWidget w;
    w.setGeometry( 100, 100, 200, 120 );
    a.setMainWidget( &amp;w );
    w.show();
    return a.exec();
}
</code></pre>
<h3 id="figuren-voorbeeld">Figuren voorbeeld</h3>
<p>!&lt;&gt;</p>
<pre><code>/****************************************************************
**
** Qt figuren vb
**
****************************************************************/

#include &lt;qapplication.h&gt;
#include &lt;qpushbutton.h&gt;
#include &lt;qfont.h&gt;
#include &lt;qpainter.h&gt;
#include &lt;vector&gt;

using namespace std;


class Figuur
{
public:
   Figuur(int ix, int iy) : x(ix), y(iy)
   {
   }
   virtual void teken(QPainter *p, int dx, int dy) = 0;

protected:
   int x;
   int y;
};

class Lijn : public Figuur
{
public:
   Lijn(int ix1, int iy1, int ix2, int iy2) : Figuur(ix1, iy1), x2(ix2), y2(iy2)
   {
   }

   void teken(QPainter *p, int dx, int dy);

private:
   int x2;
   int y2;
};

class Rechthoek : public Figuur
{
public:
   Rechthoek(int ix1, int iy1, int ix2, int iy2) : Figuur(ix1, iy1), x2(ix2), y2(iy2)
   {
   }

   void teken(QPainter *p, int dx, int dy);

private:
   int x2;
   int y2;
};




class SFiguur : public Figuur
{
public:
   SFiguur(int ix, int iy) : Figuur(ix, iy)
   {
   }
   void voegbij(Figuur *f);
   void teken(QPainter *p, int dx, int dy);

private:
   vector&lt;Figuur *&gt; figuren;
};



void SFiguur::voegbij(Figuur *f)
{
   figuren.push_back(f);
}

void Lijn::teken(QPainter *p, int dx, int dy)
{
   p-&gt;drawLine(dx + x, dy + y, dx + x2, dy + y2);
}

void Rechthoek::teken(QPainter *p, int dx, int dy)
{
   p-&gt;drawRect(dx + x, dy + y, x2 - x, y2 - y);
}

void SFiguur::teken(QPainter *p, int dx, int dy)
{
   for (int i= 0;i&lt;figuren.size(); i++)
   {
      figuren[i]-&gt;teken(p, dx + x, dy + y);
   }
}

class FVenster : public QWidget
{
public:
    FVenster( QWidget *parent=0, const char *name=0 );

protected:
    void paintEvent( QPaintEvent * );

private:
   SFiguur *fig;
};


FVenster::FVenster( QWidget *parent, const char *name )
        : QWidget( parent, name )
{
    setMinimumSize( 400, 300 );
    setMaximumSize( 400, 300 );

    // maak een SFiguur
    fig = new SFiguur(100, 100);
    fig-&gt;voegbij(new Rechthoek(0, 30, 30, 60));
    fig-&gt;voegbij(new Lijn(0, 30, 15, 0));
    fig-&gt;voegbij(new Lijn(15, 0, 30, 30));
}

void FVenster::paintEvent( QPaintEvent * )
{
    QString s = &quot;Hallo&quot;;
    QPainter p( this );

    fig-&gt;teken(&amp;p, 0, 0);
}


int main( int argc, char **argv )
{
    QApplication a( argc, argv );

    FVenster w;
    w.setGeometry( 100, 100, 200, 120 );
    a.setMainWidget( &amp;w );
    w.show();
    return a.exec();
}
</code></pre>
<p>Dit is de <code>Makefile</code> om beide voorbeelden te compileren. Je ziet dat er
gelinkt wordt met de <code>qt</code> bibliotheek die zich in de directory
<code>/usr/lib/qt/lib</code> bevindt.</p>
<pre><code>gpainter: qpainter.o
    g++ -o qpainter qpainter.o -L/usr/lib/qt/lib -lqt

qpainter.o: qpainter.cpp
    g++ -c qpainter.cpp

figuren: figuren.o
    g++ -o figuren figuren.o -L/usr/lib/qt/lib -lqt


figuren.o: figuren.cpp
    g++ -c figuren.cpp
</code></pre>
<h1 id="java">Java</h1>
<p>De programmeertaal Java.</p>
<h1 id="bash">Bash</h1>
<p>De programmeertaal Bash.</p>
<h1 id="python">Python</h1>
<p>De programmeertaal Python.</p>
<h1 id="ruby">Ruby</h1>
<p>De programmeertaal Ruby.</p>
<h1 id="javascript">Javascript</h1>
<p>De programmeertaal Javascript.</p>
<h1 id="dart">Dart</h1>
<h2 id="a-basic-dart-program">A Basic Dart Program</h2>
<p>The following code uses many of Dartâ€™s most basic features:</p>
<pre><code>// Define a function.
printNumber(num aNumber)
{
  print('The number is $aNumber.'); // Print to the console.
}

// This is where the app starts executing.
main() {
  var number = 42;           // Declare and initialize a variable.
  printNumber(number);       // Call a function.
}
</code></pre>
<p>Hereâ€™s what this program uses that applies to all (or almost all) Dart
apps:</p>
<pre><code>// This is a comment.
</code></pre>
<p>Use <code>//</code> to indicate that the rest of the line is a comment.
Alternatively, use <code>/* â€¦ */</code>. For details, see the section called
<em>Comments</em>.</p>
<dl>
<dt><code>num</code></dt>
<dd>A type. Some of the other built-in types are <code>String</code>, <code>int</code> and
<code>bool</code>.</dd>
<dt><code>42</code></dt>
<dd>A number <em>literal</em>. Literals are a kind of compile-time constant.</dd>
<dt><code>print()</code></dt>
<dd>A handy way to display output.</dd>
<dt>`` (or <code>&quot;â€¦&quot;</code>)</dt>
<dd>A string literal.</dd>
<dd>
<p>String interpolation: including a variable or expressionâ€™s string
equivalent inside of a string literal. For more information, see the
section called <em>Strings</em>.</p>
</dd>
<dt><code>main()</code></dt>
<dd>The special, <em>required</em>, top-level function where app execution
starts.</dd>
<dt><code>var</code></dt>
<dd>A way to declare a variable without specifying its type.</dd>
</dl>
<h2 id="important-concepts">Important Concepts</h2>
<p>As you learn about the Dart language, keep these facts and concepts in
mind:</p>
<ul>
<li>
<p>Everything you can place in a variable is an object, and every
object is an instance of a class. Even numbers, functions, and null
are objects. All objects inherit from the Object class.</p>
</li>
<li>
<p>Specifying static types (such as <code>num</code> in the preceding example)
clarifies your intent and enables static checking by tools, but itâ€™s
optional. (You might notice when youâ€™re debugging your code that
objects with no specified type get a special type: <code>dynamic</code>.)</p>
</li>
<li>
<p>Dart parses all your code before running it. You can provide tips to
Dart-for example, by using types or compile-time constants-to catch
errors or help your code run faster.</p>
</li>
<li>
<p>Dart supports top-level functions (such as <code>main()</code>), as well as
functions tied to a class or object (static and instance methods,
respectively). You can also create functions within functions
(nested or local functions).</p>
</li>
<li>
<p>Similarly, Dart supports top-level variables, as well as variables
tied to a class or object (static and instance variables). Instance
variables are sometimes known as fields or properties.</p>
</li>
<li>
<p>Unlike Java, Dart doesnâ€™t have the keywords <code>public</code>, <code>protected</code>,
and <code>private</code>. If an identifier starts with an underscore (<code>_</code>),
itâ€™s private to its library. For details, see the section called
<em>Libraries and Visibility</em>.</p>
</li>
<li>
<p>Identifiers can start with a letter or <code>_</code>, followed by any
combination of those characters plus digits.</p>
</li>
<li>
<p>Sometimes it matters whether something is an expression or a
statement, so weâ€™ll be precise about those two words.</p>
</li>
<li>
<p>Dart tools can report two kinds of errors: warnings and errors.
Warnings are just hints that your code might not work, but they
donâ€™t prevent your program from executing. Errors can be either
compile-time or run-time. A compile-time error prevents the code
from executing at all; a run-time error results in an exception
being raised while the code executes.</p>
</li>
<li>
<p>Dart has two runtime modes: <em>production</em> and <em>checked</em>. Production
is faster, but checked is helpful at development.</p>
</li>
</ul>
<h3 id="keywords">Keywords</h3>
<dl>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>abstract</code>   | <code>continue</code>   | <code>factory</code>    | <code>import</code>     | <code>return</code>     | <code>try</code>        |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>as</code>         | <code>default</code>    | <code>false</code>      | <code>in</code>         | <code>set</code>        | <code>typedef</code>    |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>assert</code>     | <code>do</code>         | <code>final</code>      | <code>is</code>         | <code>static</code>     | <code>var</code>        |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>break</code>      | <code>dynamic</code>    | <code>finally</code>    | <code>library</code>    | <code>super</code>      | <code>void</code>       |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>case</code>       | <code>else</code>       | <code>for</code>        | <code>new</code>        | <code>switch</code>     | <code>while</code>      |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>catch</code>      | <code>export</code>     | <code>get</code>        | <code>null</code>       | <code>this</code>       | <code>with</code>       |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>class</code>      | <code>external</code>   | <code>if</code>         | <code>operator</code>   | <code>throw</code>      | <code>const</code>      |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Dart keywords</p>
</dd>
</dl>
<h3 id="runtime-modes">Runtime Modes</h3>
<p>We recommend that you develop and debug in checked mode, and deploy to
production mode.</p>
<p><em>Production</em> mode is the default runtime mode of a Dart program,
optimized for speed. Production mode ignores assert statements and
static types.</p>
<p><em>Checked</em> mode is a developer-friendly mode that helps you catch some
type errors during runtime. For example, if you assign a non-number to a
variable declared as a num, then checked mode throws an exception.</p>
<h2 id="variables">Variables</h2>
<p>Hereâ€™s an example of creating a variable and assigning a value to it:</p>
<pre><code>var name = 'Bob';
</code></pre>
<p>Variables are references. The variable called <code>name</code> contains a
reference to a <code>String</code> object with a value of &ldquo;Bob&rdquo;.</p>
<h3 id="default-value">Default Value</h3>
<p>Uninitialized variables have an initial value of <code>null</code>. Even variables
with numeric types are initially null, because numbers are objects.</p>
<pre><code>int lineCount;
assert(lineCount == null);
// Variables (even if they will be numbers) are initially null.
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>The <code>assert()</code> call is ignored in production mode. In checked mode,
<code>assert(condition)</code> throws an exception unless <code>condition</code> is true.
For details, see the section called <em>Assert</em>.</p>
</blockquote>
<h3 id="optional-types">Optional Types</h3>
<p>You have the option of adding static types to your variable
declarations:</p>
<pre><code>String name = 'Bob';
</code></pre>
<p>Adding types is a way to clearly express your intent. Tools such as
compilers and editors can use these types to help you, by providing
early warnings for bugs and code completion.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>This chapter follows the style guide recommendation of using <code>var</code>,
rather than type annotations, for local variables.</p>
</blockquote>
<h3 id="final-and-const">Final and Const</h3>
<p>If you never intend to change a variable, use <code>final</code> or <code>const</code>, either
instead of var or in addition to a type. A final variable can be set
only once; a const variable is a compile-time constant.</p>
<p>A local, top-level, or class variable thatâ€™s declared as <code>final</code> is
initialized the first time itâ€™s used:</p>
<pre><code>final name = 'Bob';   // Or: final String name = 'Bob';
// name = 'Alice';    // Uncommenting this results in an error
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Lazy initialization of <code>final</code> variables helps apps start up faster.</p>
</blockquote>
<p>Use <code>const</code> for variables that you want to be compile-time constants.
Where you declare the variable, set the value to a compile-time constant
such as a literal, a const variable, or the result of an arithmetic
operation on constant numbers:</p>
<pre><code>const bar = 1000000;       // Unit of pressure (in dynes/cm2)
const atm = 1.01325 * bar; // Standard atmosphere
</code></pre>
<h2 id="built-in-types">Built-in Types</h2>
<p>The Dart language has special support for the following types:</p>
<ul>
<li>
<p>numbers</p>
</li>
<li>
<p>strings</p>
</li>
<li>
<p>booleans</p>
</li>
<li>
<p>lists (also known as arrays)</p>
</li>
<li>
<p>maps</p>
</li>
</ul>
<p>You can initialize an object of any of these special types using a
literal. For example, `` is a string literal, and <code>true</code> is a boolean
literal.</p>
<p>Because every variable in Dart refers to an object-an instance of a
class-you can usually use constructors to initialize variables. Some of
the built-in types have their own constructors. For example, you can use
the <code>Map()</code> constructor to create a map, using code such as <code>new Map()</code>.</p>
<h3 id="numbers">Numbers</h3>
<p>Dart numbers come in two flavors:</p>
<dl>
<dt><code>int</code></dt>
<dd>Integers of arbitrary size</dd>
<dt><code>double</code></dt>
<dd>64-bit (double-precision) floating-point numbers, as specified by
the IEEE 754 standard</dd>
</dl>
<p>Both <code>int</code> and <code>double</code> are subtypes of num. The num type includes basic
operators such as
<code>, -, /, and *, as well as bitwise operators such as &gt;&gt;. The num type is also where youâ€™ll find +abs()</code>,
<code>ceil()</code>, and <code>floor()</code>, among other methods. If num and its subtypes
don?t have what you?re looking for, the Math library might. (In
JavaScript produced from Dart code, big integers currently behave
differently than they do when the same Dart code runs in the Dart VM.)</p>
<p>Integers are numbers without a decimal point. Here are some examples of
defining integer literals:</p>
<pre><code>var x = 1;
var hex = 0xDEADBEEF;
var bigInt = 346534658346524376592384765923749587398457294759347029438709349347;
</code></pre>
<p>If a number includes a decimal, it is a <code>double</code>. Here are some examples
of defining double literals:</p>
<pre><code>var y = 1.1;
var exponents = 1.42e5;
</code></pre>
<p>Hereâ€™s how you turn a string into a number, or vice versa:</p>
<pre><code>// String -&gt; int
var one = int.parse('1');
assert(one == 1);

// String -&gt; double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -&gt; String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');
</code></pre>
<p>The <code>int</code> type specifies the traditional bitwise shift (&lt;&lt;, &gt;&gt;), AND
(&amp;), and OR (|) operators. For example:</p>
<pre><code>assert((3 &lt;&lt; 1) == 6);  // 0011 &lt;&lt; 1 == 0110
assert((3 &gt;&gt; 1) == 1);  // 0011 &gt;&gt; 1 == 0001
assert((3 | 4)  == 7);  // 0011 | 0100 == 0111
</code></pre>
<h3 id="strings-1">Strings</h3>
<p>A Dart string is a sequence of UTF-16 code units. You can use either
single or double quotes to create a string:</p>
<pre><code>var s1 = 'Single quotes work well for string literals.';
var s2 = &quot;Double quotes work just as well.&quot;;
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = &quot;It's even easier to just use the other string delimiter.&quot;;
</code></pre>
<p>To get the string corresponding to an object, Dart calls the objectâ€™s
<code>toString()</code> method.</p>
<pre><code>var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
       'Dart has string interpolation, which is very handy.');
assert('That deserves all caps. ${s.toUpperCase()} is very handy!' ==
       'That deserves all caps. STRING INTERPOLATION is very handy!');
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>The == operator tests whether two objects are equivalent. Two strings
are equivalent if they have the same characters.</p>
</blockquote>
<p>You can concatenate strings using adjacent string literals:</p>
<pre><code>var s = 'String ' 'concatenation'
        &quot; works even over line breaks.&quot;;
assert(s == 'String concatenation works even over line breaks.');
</code></pre>
<p>Another way to create a multi-line string: use a triple quote with
either single or double quotation marks:</p>
<pre><code>var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = &quot;&quot;&quot;This is also a
multi-line string.&quot;&quot;&quot;;
</code></pre>
<p>You can create a &ldquo;raw&rdquo; string by prefixing it with r:</p>
<pre><code>var s = r&quot;In a raw string, even \n isn't special.&quot;;
</code></pre>
<p>You can use Unicode escapes inside of strings:</p>
<pre><code>print('Unicode escapes work: \u2665'); // Unicode escapes work: [heart]
</code></pre>
<p>For more information on using strings, see the section called <em>Strings
and Regular Expressions</em>.</p>
<h3 id="booleans">Booleans</h3>
<p>To represent boolean values, Dart has a type named <code>bool</code>. Only two
objects have type bool: the boolean literals, <code>true</code> and <code>false</code>.</p>
<p>When Dart expects a boolean value, only the value true is treated as
true. All other values are treated as false. Unlike in JavaScript,
values such as <code>1</code>, <code>&quot;aString&quot;</code>, and <code>someObject</code> are all treated as
false.</p>
<p>For example, consider the following code, which is valid both as
JavaScript and as Dart code:</p>
<pre><code>var name = 'Bob';
if (name) {
  print('You have a name!'); // Prints in JavaScript, not in Dart.
}
</code></pre>
<p>If you run this code as JavaScript, it prints &ldquo;You have a name!&rdquo; because
<code>name</code> is a non-null object. However, in Dart running in production
mode, the above doesnâ€™t print at all because name is converted to
<code>false</code> (because <code>name != true</code>). In Dart running in checked mode, the
above code throws an exception because the <code>name</code> variable is not a
bool.</p>
<p>Hereâ€™s another example of code that behaves differently in JavaScript
and Dart:</p>
<pre><code>if (1) {
  print('JavaScript prints this line because it thinks 1 is true.');
} else {
  print('Dart in production mode prints this line.');
  // However, in checked mode, if (1) throws an exception.
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>The previous two samples work only in production mode, not checked
mode. In checked mode, an exception is thrown if a non-boolean is used
when a boolean value is expected.</p>
</blockquote>
<p>Dartâ€™s treatment of booleans is designed to avoid the strange behaviors
that can arise when many values can be treated as true. What this means
for you is that, instead of using code like <code>if (nonbooleanValue)</code>, you
should instead explicitly check for values. For example:</p>
<pre><code>// Check for an empty string.
var fullName = '';
assert(fullName.isEmpty);

// Check for zero.
var hitPoints = 0;
assert(hitPoints &lt;= 0);

// Check for null.
var unicorn;
assert(unicorn == null);

// Check for NaN.
var iMeantToDoThis = 0/0;
assert(iMeantToDoThis.isNaN);
</code></pre>
<h3 id="lists">Lists</h3>
<p>Perhaps the most common collection in nearly every programming language
is the array, or ordered group of objects. In Dart, arrays are <code>List</code>
objects, so we usually just call them lists.</p>
<p>Dart list literals look like JavaScript array literals. Hereâ€™s a simple
Dart list:</p>
<pre><code>var list = [1,2,3];
</code></pre>
<p>Lists use zero-based indexing, where 0 is the index of the first element
and <code>list.length - 1</code> is the index of the last element. You can get a
listâ€™s length and refer to list elements just as you would in
JavaScript:</p>
<pre><code>var list = [1,2,3];
assert(list.length == 3);
assert(list[1] == 2);
</code></pre>
<p>The <code>List</code> type has many handy methods for manipulating lists. For more
information about lists, see the section called <em>Generics</em> and the
section called <em>Collections</em>.</p>
<h3 id="maps">Maps</h3>
<p>In general, a map is an object that associates keys and values. Dart
support for maps is provided by map literals and the <code>Map</code> type.</p>
<p>Hereâ€™s a simple Dart map:</p>
<pre><code>var gifts = {                         // A map literal
// Keys       Values
  'first'  : 'partridge',
  'second' : 'turtledoves',
  'fifth'  : 'golden rings'
};
</code></pre>
<p>In map literals, each key must be a string. If you use a <code>Map</code>
constructor, any object can be a key.</p>
<pre><code>var map = new Map();                  // Use a map constructor.
map[1] = 'partridge';                 // Key is 1; value is 'partridge'.
map[2] = 'turtledoves';               // Key is 2; value is 'turtledoves'.
map[5] = 'golden rings';              // Key is 5; value is 'golden rings'.
</code></pre>
<p>A map value can be any object, including <code>null</code>.</p>
<p>You add a new key-value pair to an existing map just as you would in
JavaScript:</p>
<pre><code>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';    // Add a key-value pair
</code></pre>
<p>You retrieve a value from a map the same way you would in JavaScript:</p>
<pre><code>var gifts = { 'first': 'partridge' };
assert(gifts['first'] == 'partridge');
</code></pre>
<p>If you look for a key that isnâ€™t in a map, you get a <code>null</code> in return:</p>
<pre><code>var gifts = { 'first': 'partridge' };
assert(gifts['fifth'] == null);
</code></pre>
<p>Use <code>.length</code> to get the number of key-value pairs in the map:</p>
<pre><code>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);
</code></pre>
<p>For more information about maps, see the section called <em>Generics</em> and
the section called <em>Maps</em>.</p>
<h2 id="functions">Functions</h2>
<p>Hereâ€™s an example of implementing a function:</p>
<pre><code>void printNumber(num number) {
  print('The number is $number.');
}
</code></pre>
<p>Although the style guide recommends specifying the parameter and return
types, you donâ€™t have to:</p>
<pre><code>printNumber(number) {          // Omitting types is OK.
  print('The number is $number.');
}
</code></pre>
<p>For functions that contain just one expression, you can use a shorthand
syntax:</p>
<pre><code>printNumber(number) =&gt; print('The number is $number.');
</code></pre>
<p>The <code>â‡’ expr;</code> syntax is a shorthand for <code>{ return expr;}</code>. In the
<code>printNumber()</code> function above, the expression is the call to the
top-level <code>print()</code> function.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Only an expression-not a statement-can appear between the arrow (<code>â‡’</code>)
and the semicolon (<code>;</code>). For example, you canâ€™t put an if statement
there, but you can use a conditional (<code>?:</code>) expression.</p>
</blockquote>
<p>You can use types with <code>â‡’</code>, although the convention is not to do so:</p>
<pre><code>printNumber(num number) =&gt; print('The number is $number.'); // Types are OK.
</code></pre>
<p>Hereâ€™s an example of calling a function:</p>
<pre><code>printNumber(123);
</code></pre>
<p>A function can have two types of parameters: <em>required</em> and <em>optional</em>.
The required parameters are listed first, followed by any optional
parameters.</p>
<h3 id="optional-parameters">Optional Parameters</h3>
<p>Optional parameters can be either positional or named, but not both.</p>
<p>Both kinds of optional parameter can have default values. The default
values must be compile-time constants such as literals. If no default
value is provided, the value is <code>null</code>.</p>
<p>If you need to know whether the caller passed in a value for an optional
parameter, use the syntax <code>?param</code>:</p>
<pre><code>if (?device) {    // Returns true if the caller specified the parameter.
  // ...The user set the value. Do something with it...
}
</code></pre>
<h4 id="optional-named-parameters">Optional named parameters</h4>
<p>When calling a function, you can specify named parameters using
<code>paramName: value</code>. For example:</p>
<pre><code>enableFlags(bold: true, hidden: false);
</code></pre>
<p>When defining a function, use <code>{param1, param2, â€¦}</code> to specify named
parameters:</p>
<pre><code>/// Sets the [bold] and [hidden] flags to the values you specify.
enableFlags({bool bold, bool hidden}) {
  // ...
}
</code></pre>
<p>Use a colon (<code>:</code>) to specify default values:</p>
<pre><code>/**
 * Sets the [bold] and [hidden] flags to the values you specify,
 * defaulting to false.
 */
enableFlags({bool bold: false, bool hidden: false}) {
  // ...
}

enableFlags(bold: true); // bold will be true; hidden will be false.
</code></pre>
<h4 id="optional-positional-parameters">Optional positional parameters</h4>
<p>Wrapping a set of function parameters in <code>[]</code> marks them as optional
positional parameters:</p>
<pre><code>String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}
</code></pre>
<p>Hereâ€™s an example of calling this function without the optional
parameter:</p>
<pre><code>assert(say('Bob', 'Howdy') == 'Bob says Howdy');
</code></pre>
<p>And hereâ€™s an example of calling this function with the third parameter:</p>
<pre><code>assert(say('Bob', 'Howdy', 'smoke signal') ==
  'Bob says Howdy with a smoke signal');
</code></pre>
<p>Use <code>=</code> to specify default values:</p>
<pre><code>String say(String from, String msg,
  [String device='carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');
</code></pre>
<h3 id="functions-as-first-class-objects">Functions as First-Class Objects</h3>
<p>You can pass a function as a parameter to another function. For example:</p>
<pre><code>printElement(element) {
  print(element);
}

var list = [1,2,3];
list.forEach(printElement); // Pass printElement as a parameter.
</code></pre>
<p>You can also assign a function to a variable, such as:</p>
<pre><code>var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');
</code></pre>
<h3 id="lexical-scope">Lexical Scope</h3>
<p>Dart is a lexically scoped language, which means that the scope of
variables is determined statically, simply by the layout of the code.
You can &ldquo;follow the curly braces outwards&rdquo; to see if a variable is in
scope.</p>
<p>Here is an example of nested functions with variables at each scope
level:</p>
<pre><code>var topLevel = true;
main() {
    var insideMain = true;

    myFunction() {
      var insideFunction = true;

      nestedFunction() {
        var insideNestedFunction = true;
        assert(topLevel);
        assert(insideMain);
        assert(insideFunction);
        assert(insideNestedFunction);
      }
    }
}
</code></pre>
<p>Notice how <code>nestedFunction()</code> can use variables from every level, all
the way up to the top level.</p>
<h3 id="lexical-closures">Lexical Closures</h3>
<p>A closure is a function object that has access to variables in its
lexical scope, even when the function is used outside of its original
scope.</p>
<p>Functions can close over variables defined in surrounding scopes. In the
following example, <code>adder()</code> captures the variable <code>addBy</code>. Wherever the
returned function goes, it remembers <code>addBy</code>.</p>
<pre><code>/// Returns a function that adds [addBy] to a number.
Function makeAdder(num addBy) {
  adder(num i) {
    return addBy + i;
  }
  return adder;
}

main() {
  var add2 = makeAdder(2); // Create a function that adds 2.
  var add4 = makeAdder(4); // Create a function that adds 4.

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}
</code></pre>
<h3 id="testing-for-equality">Testing for Equality</h3>
<p>Each time you create a closure, that closure is a new object. This can
cause problems when you want to test whether two functions are
equivalent. For example, consider this code:</p>
<pre><code>var s = 'some string';       // Create a String object.
var splitClosure1 = s.split; // Get a reference to its split() method.
var splitClosure2 = s.split; // Get another reference to its split() method.

// Because each reference to the method creates a separate closure,
// s.split != s.split, and splitClosure1 != splitClosure2.
assert(s.split != s.split);
assert(splitClosure1 != splitClosure2);
</code></pre>
<p>The key to comparing instance methods is to save a reference to the
closure:</p>
<pre><code>splitClosure2 = splitClosure1;
assert(splitClosure1 == splitClosure2);
</code></pre>
<p>Top-level and static methods are different-you can compare them by name:</p>
<pre><code>foo() {}

class SomeClass {
  static void bar() {}
}

main() {
  assert(foo == foo);
  assert(SomeClass.bar == SomeClass.bar);
}
</code></pre>
<h3 id="return-values">Return Values</h3>
<p>All functions return a value. If no return value is specified, the
statement return <code>null</code>; is implicitly appended to the function body.</p>
<h2 id="operators">Operators</h2>
<p>Dart defines the operators shown in Table 2.2, <em>Operators and their
precedence</em>. You can override many of these operators, as described in
the section called <em>Overridable Operators</em>.</p>
<dl>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Description                          | Operator                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| unary postfix and argument           | expr++ expr&ndash; () [] . ?identifier    |</dt>
<dt>| definition test                      |                                      |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| unary prefix                         | -expr !expr ~expr ++expr &ndash;expr     |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| multiplicative                       | * / % ~/                           |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| additive                             | + -                                  |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| shift                                | &lt;&lt; &gt;&gt;                            |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| relational and type test             | &gt;= &gt; &lt;= &lt; as is is!              |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| equality                             | == !=                                |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| bitwise AND                          | &amp;                                    |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| bitwise XOR                          | ^                                   |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| bitwise OR                           | |                                    |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| logical AND                          | &amp;&amp;                                   |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| logical OR                           | ||                                   |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| conditional                          | expr1 ? expr2 : expr3                |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| cascade                              | ..                                   |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| assignment                           | = *= /= ~/= %= += -= &lt;&lt;= &gt;&gt;=   |</dt>
<dt>|                                      | &amp;= ^= |=                            |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Operators and their precedence</p>
</dd>
</dl>
<p>When you use operators, you create expressions. Here are some examples
of operator expressions:</p>
<pre><code>a++
a + b
a = b
a == b
a? b: c
a is T
</code></pre>
<p>In Table 2.2, <em>Operators and their precedence</em>, each operator has higher
precedence than the operators in the rows below it. For example, the
multiplicative operator % has higher precedence than (and thus executes
before) the equality operator ==, which has higher precedence than the
logical AND operator &amp;&amp;. That precedence means that the following two
lines of code execute the same way:</p>
<pre><code>if ((n % i == 0) &amp;&amp; (d % i == 0)) // Parens improve readability.
if (n % i == 0 &amp;&amp; d % i == 0)     // Harder to read, but equivalent.
</code></pre>
<blockquote>
<p><strong>Warning</strong></p>
<p>For operators that work on two operands, the leftmost operand
determines which version of the operator is used. For example, if you
have a Vector object and a Point object, aVector + aPoint uses the
Vector version of +.</p>
</blockquote>
<h3 id="arithmetic-operators">Arithmetic Operators</h3>
<p>Dart supports the usual arithmetic operators, as shown in Table 2.3,
<em>Arithmetic operators</em>.</p>
<dl>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Operator                             | Meaning                              |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| +                                    | Add                                  |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| -                                    | Subtract                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| -expr                                | Unary minus, also known as negation  |</dt>
<dt>|                                      | (reverse the sign of the expression) |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| *                                   | Multiply                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| /                                    | Divide                               |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| ~/                                  | Divide, returning an integer result  |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Arithmetic operators</p>
</dd>
</dl>
<p>Example:</p>
<pre><code>assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5);   // Result is a double
assert(5 ~/ 2 == 2);    // Result is an integer
assert(5 % 2 == 1);     // Remainder

print('5/2 = ${5~/2} remainder ${5%2}'); // 5/2 = 2 remainder 1
</code></pre>
<p>Dart also supports both prefix and postfix increment and decrement
operators.</p>
<dl>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Operator                             | Meaning                              |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| ++var                                | var = var + 1 (expression value is   |</dt>
<dt>|                                      | var + 1)                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| var++                                | var = var + 1 (expression value is   |</dt>
<dt>|                                      | var)                                 |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| &ndash;var                                | var = var - 1 (expression value is   |</dt>
<dt>|                                      | var - 1)                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| var&ndash;                                | var = var - 1 (expression value is   |</dt>
<dt>|                                      | var)                                 |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Increment and decrement operators</p>
</dd>
</dl>
<p>Example:</p>
<pre><code>var a, b;

a = 0;
b = ++a;         // Increment a before b gets its value.
assert(a == b);  // 1 == 1

a = 0;
b = a++;         // Increment a AFTER b gets its value.
assert(a != b);  // 1 != 0

a = 0;
b = --a;         // Decrement a before b gets its value.
assert(a == b);  // -1 == -1

a = 0;
b = a--;         // Decrement a AFTER b gets its value.
assert(a != b) ; // -1 != 0
</code></pre>
<h3 id="equality-and-relational-operators">Equality and Relational Operators</h3>
<dl>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Operator Meaning                                                         |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| ==                                                                       |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Equal; see discussion below                                              |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| !=                                                                       |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Not equal                                                                |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| &gt;                                                                       |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Greater than                                                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| &lt;                                                                       |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Less than                                                                |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| &gt;=                                                                      |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Greater than or equal to                                                 |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| &lt;=                                                                      |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Less than or equal to                                                    |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Equality and relational operators</p>
</dd>
</dl>
<p>To test whether two objects x and y represent the same thing, use the
<code>==</code> operator. Hereâ€™s how the <code>==</code> operator works:</p>
<ul>
<li>
<p>If <code>x</code> or <code>y</code> is <code>null</code>, return <code>true</code> if both are <code>null</code>, and
<code>false</code> if only one is <code>null</code>.</p>
</li>
<li>
<p>Return the result of the method invocation <code>x.==(y)</code>. (Thatâ€™s right,
operators such as <code>==</code> are methods that are invoked on their first
operand. You can even override many operators, including <code>==</code>, as
youâ€™ll see in the section called <em>Overridable Operators</em>.)</p>
</li>
</ul>
<p>Hereâ€™s an example of using each of the equality and relational
operators:</p>
<pre><code>assert(2 == 2);
assert(2 != 3);
assert(3 &gt; 2);
assert(2 &lt; 3);
assert(3 &gt;= 3);
assert(2 &lt;= 3);
</code></pre>
<h3 id="type-test-operators">Type Test Operators</h3>
<p>The <code>as</code>, <code>is</code>, and <code>is!</code> operators are handy for checking types at
runtime.</p>
<dl>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Operator                             | Meaning                              |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| &mdash;-                                 | as                                   |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Typecast                             | is                                   |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| True if the object has the specified | is!                                  |</dt>
<dt>| type                                 |                                      |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Type test operators</p>
</dd>
</dl>
<p>The result of obj is T is true if obj implements the interface specified
by T. For example, <code>obj is Object</code> is always <code>true</code>.</p>
<p>Use the <code>as</code> operator to cast an object to a particular type. In
general, you should use it as a shorthand for an <code>is</code> test on an object
following by an expression using that object. For example, consider the
following code:</p>
<pre><code>if (person is Person) {               // Type check
  person.firstName = 'Bob';
}
</code></pre>
<p>You can make the code shorter using the as operator:</p>
<pre><code>(person as Person).firstName = 'Bob';
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>The code isnâ€™t equivalent. If person is <code>null</code> or not a <code>Person</code>, the
first example (with is) does nothing; the second (with <code>as</code>) throws an
exception.</p>
</blockquote>
<h3 id="assignment-operators">Assignment Operators</h3>
<p>As youâ€™ve already seen, you assign values using the <code>=</code> operator. You
can also use compound assignment operators such as <code>+=</code>, which combine
an operation with an assignment.</p>
<dl>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>=</code>          | <code>?=</code>         | <code>/=</code>         | <code>%=</code>         | <code>&gt;&gt;=</code>        | <code>^=</code>         |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <code>+=</code>         | <code>*=</code>         | <code>~/=</code>        | <code>&lt;&lt;=</code>        | <code>&amp;=</code>         | <code>|=</code>         |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Assignment operators</p>
</dd>
</dl>
<p>Hereâ€™s how compound assignment operators work:</p>
<pre><code>Compound assignment  Equivalent expression
For an operator op:  a op= b  a = a op b
Example:                 a += b   a = a + b
</code></pre>
<p>The following example uses both assignment and compound assignment
operators:</p>
<pre><code>var a = 2;           // Assign using =
a *= 3;              // Assign and multiply: a = a * 3
assert(a == 6);
</code></pre>
<h3 id="logical-operators-1">Logical Operators</h3>
<p>You can invert or combine boolean expressions using the logical
operators.</p>
<pre><code>Operator        Meaning
!expr   inverts the following expression (changes false to true, and vice versa)
||      logical OR
&amp;&amp;      logical AND
</code></pre>
<p>Hereâ€™s an example of using the logical operators:</p>
<pre><code>if (!done &amp;&amp; (col == 0 || col == 3)) {
  // ...Do something...
}
</code></pre>
<h3 id="bitwise-and-shift-operators">Bitwise and Shift Operators</h3>
<p>You can manipulate the individual bits of numbers in Dart. Usually,
youâ€™d use these bitwise and shift operators with integers, as shown in
Table 2.9, <em>Bitwise and shift operators</em>.</p>
<pre><code>Operator        Meaning
&amp;       AND
|       OR
^       XOR
~expr   Unary bitwise complement (0s become 1s; 1s become 0s)
&lt;&lt;      Shift left
&gt;&gt;      Shift right
</code></pre>
<p>Hereâ€™s an example of using bitwise and shift operators:</p>
<pre><code>final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask)  == 0x02);  // AND
assert((value &amp; ~bitmask) == 0x20);  // AND NOT
assert((value | bitmask)  == 0x2f);  // OR
assert((value ^ bitmask)  == 0x2d);  // XOR
assert((value &lt;&lt; 4)       == 0x220); // Shift left
assert((value &gt;&gt; 4)       == 0x02);  // Shift right
</code></pre>
<h3 id="other-operators">Other Operators</h3>
<p>A few operators remain, most of which youâ€™ve already seen in other
examples.</p>
<p>Table 2.10. Other operators</p>
<p>Operator Name Meaning <code>()</code>:: Function application Represents a function
call</p>
<dl>
<dt><code>[]</code></dt>
<dd>List access Refers to the value at the specified index in the list</dd>
<dt><code>expr1 ? expr2 : expr3</code></dt>
<dd>Conditional If expr1 is true, executes expr2; otherwise, executes
expr3</dd>
<dt><code>.</code></dt>
<dd>Member access Refers to a property of an expression; example:
foo.bar selects property bar from expression foo</dd>
<dt><code>..</code></dt>
<dd>Cascade Allows you to perform multiple operations on the members of
a single object; described in the section called <em>Classes</em></dd>
<dt><code>?identifier</code></dt>
<dd>Argument definition test Tests whether the caller specified an
optional parameter; described in the section called <em>Optional
Parameters</em></dd>
</dl>
<h2 id="control-flow-statements">Control Flow Statements</h2>
<p>You can control the flow of your Dart code using any of the following:</p>
<ul>
<li>
<p><code>if</code> and <code>else</code></p>
</li>
<li>
<p><code>for</code> loops</p>
</li>
<li>
<p><code>while</code> and <code>do-while</code> loops</p>
</li>
<li>
<p><code>break</code> and <code>continue</code></p>
</li>
<li>
<p><code>switch</code> and <code>case</code></p>
</li>
<li>
<p><code>assert</code></p>
</li>
</ul>
<p>You can also affect the control flow using try-catch and throw, as
explained in the section called <em>Exceptions</em>.</p>
<h3 id="if-and-else">If and Else</h3>
<p>Dart supports <code>if</code> statements with optional <code>else</code> statements, as the
next sample shows. Also see conditional expressions <code>(?:)</code>, which are
covered in the section called <em>Other Operators</em>.</p>
<pre><code>if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}
</code></pre>
<p>Remember, unlike JavaScript, Dart treats all values other than <code>true</code> as
<code>false</code>. See the section called <em>Booleans</em> for more information.</p>
<h3 id="for-loops">For Loops</h3>
<p>You can iterate with the standard <code>for</code> loop. For example:</p>
<pre><code>var message = new StringBuffer(&quot;Dart is fun&quot;);
for (var i = 0; i &lt; 5; i++) {
  message.write('!');
}
</code></pre>
<p>Closures inside of Dartâ€™s for loops capture the value of the index,
avoiding a common pitfall found in JavaScript. For example, consider:</p>
<pre><code>var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());
</code></pre>
<p>The output is 0 and then 1, as expected. In contrast, the example would
print 2 and then 2 in JavaScript.</p>
<p>If the object that you are iterating over is an <code>Iterable</code>, you can use
the <code>forEach()</code> method. Using <code>forEach()</code> is a good option if you donâ€™t
need to know the current iteration counter:</p>
<pre><code>candidates.forEach((candidate) =&gt; candidate.interview());
</code></pre>
<p><code>Iterable</code> classes such as <code>List</code> and <code>Set</code> also support the <code>for-in</code>
form of iteration, which is described in the section called <em>Iteration</em>:</p>
<pre><code>var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}
</code></pre>
<h3 id="while-and-do-while">While and Do-While</h3>
<p>A <code>while</code> loop evaluates the condition before the loop:</p>
<pre><code>while(!isDone()) {
  doSomething();
}
</code></pre>
<p>A <code>do-while</code> loop evaluates the condition after the loop:</p>
<pre><code>do {
  printLine();
} while (!atEndOfPage());
</code></pre>
<h3 id="break-and-continue">Break and Continue</h3>
<p>Use <code>break</code> to stop looping:</p>
<pre><code>while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}
</code></pre>
<p>Use <code>continue</code> to skip to the next loop iteration:</p>
<pre><code>for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}
</code></pre>
<p>You might write that example differently if youâ€™re using a <code>Iterable</code>
such as a list or set:</p>
<pre><code>candidates.where((c) =&gt; c.yearsExperience &gt;= 5)
          .forEach((c) =&gt; c.interview());
</code></pre>
<h3 id="switch-and-case">Switch and Case</h3>
<p>Switch statements in Dart compare integer, string, or compile-time
constants using <code>==</code>. The compared objects must all be instances of the
same class (and not of any of its subtypes), and the class must not
override <code>==</code>.</p>
<p>Each non-empty case clause ends with a <code>break</code> statement, as a rule.
Other valid ways to end a non-empty case clause are a <code>continue</code>,
<code>throw</code>, or <code>return</code> statement.</p>
<p>Use a <code>default</code> clause to execute code when no <code>case</code> clause matches:</p>
<pre><code>var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}
</code></pre>
<p>The following example omits the <code>break</code> statement in the <code>case</code> clause,
thus generating an error:</p>
<pre><code>var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: Missing break causes an exception to be thrown!!

  case 'CLOSED':
    executeClosed();
    break;
}
</code></pre>
<p>However, Dart does support empty <code>case</code> clauses, allowing a form of
fall-through:</p>
<pre><code>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':     // Empty case falls through.
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}
</code></pre>
<p>If you really want fall-through, you can use a <code>continue</code> statement and
a label:</p>
<pre><code>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed; // Continues executing at the nowClosed label.

nowClosed:
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}
</code></pre>
<p>A <code>case</code> clause can have local variables, which are visible only inside
the scope of that clause.</p>
<h3 id="assert">Assert</h3>
<p>Use an <code>assert</code> statement to disrupt normal execution if a boolean
condition is false. You can find examples of assert statements
throughout this tour. Here are some more:</p>
<pre><code>assert(text != null);  // Make sure the variable has a non-null value.
assert(number &lt; 100);  // Make sure the value is less than 100.
assert(urlString.startsWith('https')); // Make sure this is an HTTPS URL.
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Assert statements work only in checked mode. They have no effect in
production mode.</p>
</blockquote>
<p>Inside the parentheses after <code>assert</code>, you can put any expression that
resolves to a boolean value or to a function. If the expressionâ€™s value
or functionâ€™s return value is true, the assertion succeeds and execution
continues. Otherwise, the assertion fails and an exception (an
<code>AssertionError</code>) is thrown.</p>
<h2 id="exceptions">Exceptions</h2>
<p>Your Dart code can <code>throw</code> and <code>catch</code> exceptions. Exceptions are errors
indicating that something unexpected happened. If the exception isnâ€™t
caught, the isolate that raised the exception is suspended, and
typically the isolate and its program are terminated.</p>
<p>In contrast to Java, all of Dartâ€™s exceptions are unchecked exceptions.
Methods do not declare which exceptions they might throw, and you are
not required to catch any exceptions.</p>
<p>Dart provides <code>Exception</code> and <code>Error</code> types, as well as numerous
predefined subtypes. You can, of course, define your own exceptions.
However, Dart programs can throw any non-null object-not just Exception
and Error objects-as an exception.</p>
<h3 id="throw">Throw</h3>
<p>Hereâ€™s an example of throwing, or raising, an exception:</p>
<pre><code>throw new ExpectException('Value must be greater than zero');
</code></pre>
<p>You can also throw arbitrary objects:</p>
<pre><code>throw 'Out of llamas!';
</code></pre>
<p>Because throwing an exception is an expression, you can throw exceptions
in <code>â‡’</code> statements, as well as anywhere else that allows expressions:</p>
<pre><code>distanceTo(Point other) =&gt; throw new UnimplementedError();
</code></pre>
<h3 id="catch">Catch</h3>
<p>Catching, or capturing, an exception stops the exception from
propagating. Catching an exception gives you a chance to handle it:</p>
<pre><code>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}
</code></pre>
<p>To handle code that can throw more than one type of exception, you can
specify multiple catch clauses. The first catch clause that matches the
thrown objectâ€™s type handles the exception. If the catch clause does not
specify a type, that clause can handle any type of thrown object:</p>
<pre><code>try {
  breedMoreLlamas();
} on OutOfLlamasException {           // A specific exception
  buyMoreLlamas();
} on Exception catch(e) {             // Anything else that is an exception
  print('Unknown exception: $e');
} catch(e) {                          // No specified type, handles all
  print('Something really unknown: $e');
}
</code></pre>
<p>As the preceding code shows, you can use either on or <code>catch</code> or both.
Use on when you need to specify the exception type. Use <code>catch</code> when
your exception handler needs the exception object.</p>
<h3 id="finally">Finally</h3>
<p>To ensure that some code runs whether or not an exception is thrown, use
a <code>finally</code> clause. If no catch clause matches the exception, the
exception is propagated after the finally clause runs:</p>
<pre><code>try {
  breedMoreLlamas();
} finally {
  cleanLlamaStalls();  // Always clean up, even if an exception is thrown.
}
</code></pre>
<p>The <code>finally</code> clause runs after any matching catch clauses:</p>
<pre><code>try {
  breedMoreLlamas();
} catch(e) {
  print('Error: $e');  // Handle the exception first.
} finally {
  cleanLlamaStalls();  // Then clean up.
}
</code></pre>
<p>Learn more by reading the section called <em>Exceptions</em>.</p>
<h2 id="classes">Classes</h2>
<p>Dart is an object-oriented language with classes and single inheritance.
Every object is an instance of a class, and all classes descend from
Object.</p>
<p>To create an object, you can use the <code>new</code> keyword with a constructor
for a class. Constructor names can be either ClassName or
ClassName.identifier. For example:</p>
<pre><code>var jsonData = json.parse('{&quot;x&quot;:1, &quot;y&quot;:2}');

var p1 = new Point(2,2);               // Create a Point using Point().
var p2 = new Point.fromJson(jsonData); // Create a Point using Point.fromJson().
</code></pre>
<p>Objects have members consisting of functions and data (methods and
instance variables, respectively). When you call a method, you invoke it
on an object: the method has access to that objectâ€™s functions and data.</p>
<p>Use a dot (<code>.</code>) to refer to an instance variable or method:</p>
<pre><code>var p = new Point(2,2);

p.y = 3;             // Set the value of the instance variable y.
assert(p.y == 3);    // Get the value of y.

num distance = p.distanceTo(new Point(4,4)); // Invoke distanceTo() on p.
</code></pre>
<p>Use the cascade operator (<code>..</code>) when you want to perform a series of
operations on the members of a single object:</p>
<pre><code>query('#button')
    ..text = 'Click to Confirm'                        // Get an object. Use its
    ..classes.add('important')                         // instance variables
    ..onClick.listen((e) =&gt; window.alert('Confirmed!')); // and methods.
</code></pre>
<p>Some classes provide constant constructors. To create a compile-time
constant using a constant constructor, use <code>const</code> instead of <code>new</code>:</p>
<pre><code>var p = const ImmutablePoint(2,2);
</code></pre>
<p>Constructing two identical compile-time constants results in a single,
canonical instance:</p>
<pre><code>var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a,b)); // They are the same instance!
</code></pre>
<p>The following sections discuss how to implement classes.</p>
<h3 id="instance-variables">Instance Variables</h3>
<p>Hereâ€™s how you declare instance variables:</p>
<pre><code>class Point {
  num x;      // Declare an instance variable (x), initially null.
  num y;      // Declare y, initially null.
  num z = 0;  // Declare z, initially 0.
}
</code></pre>
<p>All uninitialized instance variables have the value null.</p>
<p>All instance variables generate an implicit getter method. Non-final,
non-const instance variables also generate an implicit setter method.
For details, see the section called <em>Getters and setters</em>.</p>
<pre><code>class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // Use the setter method for x.
  assert(point.x == 4);    // Use the getter method for x.
  assert(point.y == null); // Values default to null.
}
</code></pre>
<p>If you initialize an instance variable where it is declared (instead of
in a constructor or method), the value is set when the instance is
created, which is before the constructor and its initializer list
execute.</p>
<h3 id="constructors">Constructors</h3>
<p>Declare a constructor by creating a function with the same name as its
class (plus, optionally, an additional identifier as described in the
section called <em>Named constructors</em>). The most common form of
constructor, the generative constructor, creates a new instance of a
class:</p>
<pre><code>class Point {
  num x;
  num y;

  Point(num x, num y) {
    // There's a better way to do this, stay tuned.
    this.x = x;
    this.y = y;
  }
}
</code></pre>
<p>The this keyword refers to the current instance.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Use this only when there is a name conflict. Otherwise, Dart style
omits the this.</p>
</blockquote>
<p>The pattern of assigning a constructor argument to an instance variable
is so common, Dart has syntactic sugar to make it easy:</p>
<pre><code>class Point {
  num x;
  num y;

  // Syntactic sugar for setting x and y before the constructor body runs.
  Point(this.x, this.y);
}
</code></pre>
<h4 id="default-constructors">Default constructors</h4>
<p>If you donâ€™t declare a constructor, a default constructor is provided
for you. The default constructor has no arguments and invokes the
no-argument constructor in the superclass.</p>
<p>====== Constructors arenâ€™t inherited</p>
<p>Subclasses donâ€™t inherit constructors from their superclass. A subclass
that declares no constructors has only the default (no argument, no
name) constructor.</p>
<h4 id="named-constructors">Named constructors</h4>
<p>Use a named constructor to implement multiple constructors for a class
or to provide extra clarity:</p>
<pre><code>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Named constructor
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}
</code></pre>
<p>Remember that constructors are not inherited, which means that a
superclassâ€™s named constructor is not inherited by a subclass. If you
want a subclass to be created with a named constructor defined in the
superclass, you must implement that constructor in the subclass.</p>
<h4 id="invoking-a-non-default-superclass-constructor">Invoking a non-default superclass constructor</h4>
<p>By default, a constructor in a subclass calls the superclassâ€™s unnamed,
no-argument constructor. If the superclass doesnâ€™t have such a
constructor, then you must manually call one of the constructors in the
superclass. Specify the superclass constructor after a colon (<code>:</code>), just
before the constructor body (if any).</p>
<pre><code>class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Prints:
  // in Person
  // in Employee
}
</code></pre>
<h4 id="initializer-list">Initializer list</h4>
<p>Besides invoking a superclass constructor, you can also initialize
instance variables before the constructor body runs. Separate
initializers with commas.</p>
<pre><code>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Initializer list sets instance variables before the constructor body runs.
  Point.fromJson(Map json) : x = json['x'], y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}
</code></pre>
<blockquote>
<p><strong>Warning</strong></p>
<p>The right-hand side of an initializer does not have access to this.</p>
</blockquote>
<h4 id="redirecting-constructors">Redirecting constructors</h4>
<p>Sometimes a constructorâ€™s only purpose is to redirect to another
constructor in the same class. A redirecting constructorâ€™s body is
empty, with the constructor call appearing after a colon (<code>:</code>).</p>
<pre><code>class Point {
  num x;
  num y;

  Point(this.x, this.y);                // The main constructor for this class.
  Point.alongXAxis(num x) : this(x, 0); // Delegates to the main constructor.
}
</code></pre>
<h4 id="constant-constructors">Constant constructors</h4>
<p>If your class produces objects that never change, you can make these
objects compile-time constants. To do this, define a <code>const</code> constructor
and make sure that all instance variables are <code>final</code> or <code>const</code>.</p>
<pre><code>class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}
</code></pre>
<h4 id="factory-constructors">Factory constructors</h4>
<p>Use the factory keyword when implementing a constructor that doesnâ€™t
always create a new instance of its class. For example, a factory
constructor might return an instance from a cache, or it might return an
instance of a subtype.</p>
<p>The following example demonstrates a factory constructor returning
objects from a cache:</p>
<pre><code>class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};

  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Factory constructors have no access to this.</p>
</blockquote>
<p>To invoke a factory constructor, you use the new keyword:</p>
<pre><code>var logger = new Logger('UI');
logger.log('Button clicked');
</code></pre>
<h3 id="methods">Methods</h3>
<p>Methods are functions that provide behavior for an object.</p>
<h4 id="instance-methods">Instance methods</h4>
<p>Instance methods on objects can access instance variables and this. The
<code>distanceTo()</code> method in the following sample is an example of an
instance method:</p>
<pre><code>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}
</code></pre>
<h4 id="getters-and-setters">Getters and setters</h4>
<p>Getters and setters are special methods that provide read and write
access to an objectâ€™s properties. Recall that each instance variable has
an implicit getter, plus a setter if appropriate. You can create
additional properties by implementing getters and setters, using the get
and set keywords:</p>
<pre><code>class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}
</code></pre>
<p>With getters and setters, you can start with instance variables, later
wrapping them with methods, all without changing client code.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Operators such as increment (++) work in the expected way, whether or
not a getter is explicitly defined. To avoid any unexpected side
effects, the operator calls the getter exactly once, saving its value
in a temporary variable.</p>
</blockquote>
<h4 id="abstract-methods">Abstract methods</h4>
<p>Instance, getter, and setter methods can be abstract, defining an
interface but leaving its implementation up to other classes. To make a
method abstract, use a semicolon (<code>;</code>) instead of a method body:</p>
<pre><code>abstract class Doer {
  // ...Define instance variables and methods...

  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Provide an implementation, so the method is not abstract here...
  }
}
</code></pre>
<p>Calling an abstract method results in a run-time error.</p>
<p>Also see the section called <em>Abstract Classes</em>.</p>
<h4 id="overridable-operators">Overridable Operators</h4>
<p>You can override the operators shown in Table 2.11, <em>Operators that can
be overridden</em>. For example, if you define a <code>Vector</code> class, you might
define a + method to add two vectors.</p>
<p>Table 2.11. Operators that can be overridden</p>
<pre><code>&lt;       +       |       []
&gt;       /       ^       []=
&lt;=      ~/      &amp;       ~
&gt;=      *       &lt;&lt;      ==
-       %       &gt;&gt;
</code></pre>
<p>Hereâ€™s an example of a class that overrides the + and - operators:</p>
<pre><code>class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Overrides + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Overrides - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2,3);
  final w = new Vector(2,2);

  assert(v.x == 2 &amp;&amp; v.y == 3);         // v   == (2,3)
  assert((v+w).x == 4 &amp;&amp; (v+w).y == 5); // v+w == (4,5)
  assert((v-w).x == 0 &amp;&amp; (v-w).y == 1); // v-w == (0,1)
}
</code></pre>
<p>For an example of overriding <code>==</code>, see the section called <em>Implementing
map keys</em>.</p>
<h3 id="abstract-classes">Abstract Classes</h3>
<p>Use the <code>abstract</code> modifier to define an abstract class-a class that
canâ€™t be instantiated. Abstract classes are useful for defining
interfaces, often with some implementation. If you want your abstract
class to appear to be instantiable, define a factory constructor.</p>
<p>Abstract classes often have abstract methods. Hereâ€™s an example of
declaring an abstract class that has an abstract method:</p>
<pre><code>// This class is declared abstract and thus can't be instantiated.
abstract class AbstractContainer {
  // ...Define constructors, fields, methods...

  void updateChildren(); // Abstract method.
}
</code></pre>
<p>The following class isnâ€™t abstract, and thus can be instantiated even
though it defines an abstract method:</p>
<pre><code>class SpecializedContainer extends AbstractContainer {
  // ...Define more constructors, fields, methods...

  void updateChildren() {
    // ...Implement updateChildren()...
  }
// Abstract method causes a warning but doesn't prevent instantiatation.
  void doSomething();
}
</code></pre>
<h3 id="implicit-interfaces">Implicit Interfaces</h3>
<p>Every class implicitly defines an interface containing all the instance
members of the class and of any interfaces it implements. If you want to
create a class A that supports class Bâ€™s API without inheriting Bâ€™s
implementation, class A should implement the B interface.</p>
<p>A class implements one or more interfaces by declaring them in an
implements clause and then providing the APIs required by the
interfaces. For example:</p>
<pre><code>// A person. The implicit interface contains greet().
class Person {
  final _name;          // In the interface, but visible only in this library,
  Person(this._name);   // Not in the interface, since this is a constructor.
  String greet(who) =&gt; 'Hello, $who. I am $_name.'; // In the interface.
}

// An implementation of the Person interface.
class Imposter implements Person {
  final _name = &quot;&quot;;      // We have to define this, but we don't use it.
  String greet(who) =&gt; 'Hi $who. Do you know who I am?';
}

greetBob(Person person) =&gt; person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}
</code></pre>
<p>Hereâ€™s an example of specifying that a class implements multiple
interfaces:</p>
<pre><code>class Point implements Comparable, Location {
  // ...
}
</code></pre>
<h2 id="extending-a-class">Extending a Class</h2>
<p>Use <code>extends</code> to create a subclass, and super to refer to the
superclass:</p>
<pre><code>class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  ...
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  ...
}
</code></pre>
<p>Subclasses can override instance methods, getters, and setters. Hereâ€™s
an example of overriding the <code>Object</code> classâ€™s <code>noSuchMethod()</code> method,
which is called whenever code attempts to use a non-existent method or
instance variable:</p>
<pre><code>class A {
  // Unless you override noSuchMethod, using a non-existent member
  // results in a NoSuchMethodError.
  void noSuchMethod(Invocation mirror) {
    print('You tried to use a non-existent member: ${mirror.memberName}');
  }
}
</code></pre>
<h3 id="class-variables-and-methods">Class Variables and Methods</h3>
<p>Use the <code>static</code> keyword to implement class-wide variables and methods.</p>
<h4 id="static-variables">Static variables</h4>
<p>Static variables (class variables) are useful for class-wide state and
constants:</p>
<pre><code>class Color {
  static const RED = const Color('red'); // A constant static variable.
  final String name;                     // An instance variable.
  const Color(this.name);                // A constant constructor.
}

main() {
  assert(Color.RED.name == 'red');
}
</code></pre>
<p>Static variables arenâ€™t initialized until theyâ€™re used.</p>
<h4 id="static-methods">Static methods</h4>
<p>Static methods (class methods) do not operate on an instance, and thus
do not have access to this. For example:</p>
<pre><code>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a,b);
  assert(distance &lt; 2.9 &amp;&amp; distance &gt; 2.8);
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Consider using top-level functions, instead of static methods, for
common or widely used utilities and functionality.</p>
</blockquote>
<p>You can use static methods as compile-time constants. For example, you
can pass a static method as a parameter to a constant constructor.</p>
<h2 id="generics">Generics</h2>
<p>If you look at the API documentation for the basic array type, <code>List</code>,
youâ€™ll see that the type is actually <code>List&lt;E&gt;</code>. The &lt;â€¦&gt; notation marks
List as a generic (or parameterized) type-a type that has formal type
parameters. By convention, type variables have single-letter names, such
as E, T, S, K, and V.</p>
<h3 id="why-use-generics">Why Use Generics?</h3>
<p>Because types are optional in Dart, you never have to use generics. You
might want to, though, for the same reason you might want to use other
types in your code: types (generic or not) let you document and annotate
your code, making your intent clearer.</p>
<p>For example, if you intend for a list to contain only strings, you can
declare it as <code>List&lt;String&gt;</code> (read that as <em>list of string</em>). That way
you, your fellow programmers, and your tools (such as Dart Editor and
the Dart VM in checked mode) can detect that assigning a non-string to
the list is probably a mistake. Hereâ€™s an example:</p>
<pre><code>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
// ...
names.add(42); // Fails in checked mode (succeeds in production mode).

Another reason for using generics is to reduce code duplication. Generics let you share a single interface and implementation between many types, while still taking advantage of checked mode and static analysis early warnings. For example, say you create an interface for caching an object:

abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}
</code></pre>
<p>You discover that you want a string-specific version of this interface,
so you create another interface:</p>
<pre><code>abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}
</code></pre>
<p>Later, you decide you want a number-specific version of this interfaceâ€¦
You get the idea.</p>
<p>Generic types can save you the trouble of creating all these interfaces.
Instead, you can create a single interface that takes a type parameter:</p>
<pre><code>abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  setByKey(String key, T value);
}
</code></pre>
<p>In this code, <code>T</code> is the stand-in type. Itâ€™s a placeholder that you can
think of as a type that a developer will define later.</p>
<h3 id="using-collection-literals">Using Collection Literals</h3>
<p>List and map literals can be parameterized. Parameterized literals are
just like the literals youâ€™ve already seen, except that you add &lt;type&gt;
(for lists) or &lt;keyType, valueType&gt; (for maps) before the opening
bracket. You might use parameterized literals when you want type
warnings in checked mode. Here is example of using typed literals:</p>
<pre><code>var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];
var pages = &lt;String, String&gt;{
    'index.html':'Homepage',
    'robots.txt':'Hints for web robots',
    'humans.txt':'We are people, not machines' };
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p><code>Map</code> literals always have string keys, so their type is always
<code>&lt;String, SomeType&gt;</code>.</p>
</blockquote>
<h3 id="using-constructors">Using Constructors</h3>
<p>To specify one or more types when using a constructor, put the types in
angle brackets (<code>&lt;â€¦&gt;</code>) just after the class name. For example:</p>
<pre><code>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set&lt;String&gt;.from(names);
</code></pre>
<p>The following code creates a map that has integer keys and values of
type View:</p>
<pre><code>var views = new Map&lt;int, View&gt;();
</code></pre>
<h3 id="generic-collections-and-the-types-they-contain">Generic Collections and the Types they Contain</h3>
<p>Dart generic types are reified, which means that they carry their type
information around at runtime. For example, you can test the type of a
collection, even in production mode:</p>
<pre><code>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List&lt;String&gt;); // true
</code></pre>
<p>However, the is expression checks the type of the collection only-not of
the objects inside it. In production mode, a <code>List&lt;String&gt;</code> might have
some non-string items in it. The solution is to either check each itemâ€™s
type or wrap item-manipulation code in an exception handler (see the
section called ?Exceptions?).</p>
<blockquote>
<p><strong>Note</strong></p>
<p>In contrast, generics in Java use erasure, which means that generic
type parameters are removed at runtime. In Java, you can test whether
an object is a <code>List</code>, but you canâ€™t test whether itâ€™s a
<code>List&lt;String&gt;</code>.</p>
</blockquote>
<p>For more information about generics, see Optional Types in Dart.</p>
<h2 id="libraries-and-visibility">Libraries and Visibility</h2>
<p>The import, part, and library directives can help you create a modular
and shareable code base. Libraries not only provide APIs, but are a unit
of privacy: identifiers that start with an underscore (<code>_</code>) are visible
only inside the library. Every Dart app is a library, even if it doesnâ€™t
use a library directive.</p>
<p>Libraries can be distributed using packages. See the section called
<em>pub: The Dart Package Manager</em> for information about pub, a package
manager included in the SDK.</p>
<h3 id="using-libraries">Using Libraries</h3>
<p>Use import to specify how a namespace from one library is used in the
scope of another library.</p>
<p>For example, Dart web apps generally use the <code>dart:html</code> library, which
they can import like this:</p>
<pre><code>import 'dart:html';
</code></pre>
<p>The only required argument to import is a URI[1] specifying the library.
For built-in libraries, the URI has the special dart: scheme. For other
libraries, you can use a file system path or the package: scheme. The
package: scheme specifies libraries provided by a package manager such
as the pub tool. For example:</p>
<pre><code>import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';
</code></pre>
<p>Specifying a library prefix</p>
<p>If you import two libraries that have conflicting identifiers, then you
can specify a prefix for one or both libraries. For example, if library1
and library2 both have an <code>Element</code> class, then you might have code like
this:</p>
<pre><code>import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
// ...
var element1 = new Element();      // Uses Element from lib1.
var element2 = new lib2.Element(); // Uses Element from lib2.
</code></pre>
<p>Importing only part of a library</p>
<p>If you want to use only part of a library, you can selectively import
the library. For example:</p>
<pre><code>import 'package:lib1/lib1.dart' show foo, bar; // Import only foo and bar.
import 'package:lib2/lib2.dart' hide foo;      // Import all names EXCEPT foo.
</code></pre>
<h3 id="implementing-libraries">Implementing Libraries</h3>
<p>Use library to name a library, and part to specify additional files in
the library.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>You donâ€™t have to use library in an app (a file that has a top-level
<code>main()</code> function), but doing so lets you implement the app in
multiple files.</p>
</blockquote>
<h4 id="declaring-a-library">Declaring a library</h4>
<p>Use library identifier to specify the name of the current library:</p>
<pre><code>library ballgame;   // Declare that this is a library named ballgame.

import 'dart:html'; // This app uses the HTML library.
// ...Code goes here...
</code></pre>
<h4 id="associating-a-file-with-a-library">Associating a file with a library</h4>
<p>To add an implementation file, put part fileUri in the file that has the
library statement, where fileUri is the path to the implementation file.
Then in the implementation file, put part of identifier, where
identifier is the name of the library. The following example uses part
and part of to implement a library in three files.</p>
<p>The first file, <code>ballgame.dart</code>, declares the ballgame library, imports
other libraries it needs, and specifies that <code>ball.dart</code> and <code>util.dart</code>
are parts of this library:</p>
<pre><code>library ballgame;

import 'dart:html';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

// ...Code might go here...
</code></pre>
<p>The second file, <code>ball.dart</code>, implements part of the ballgame library:</p>
<pre><code>part of ballgame;

// ...Code goes here...
</code></pre>
<p>The third file, <code>util.dart</code>, implements the rest of the ballgame
library:</p>
<pre><code>part of ballgame;

// ...Code goes here...
</code></pre>
<h4 id="re-exporting-libraries">Re-exporting libraries</h4>
<p>You can combine or repackage libraries by re-exporting part or all of
them. For example, you might have a huge library that you implement as a
set of smaller libraries. Or you might create a library that provides a
subset of methods from another library.</p>
<pre><code>// In french.dart:
library french;
hello() =&gt; print('Bonjour!');
goodbye() =&gt; print('Au Revoir!');

// In togo.dart:
library togo;
import 'french.dart';
export 'french.dart' show hello;

// In another .dart file:
import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}
</code></pre>
<h2 id="isolates">Isolates</h2>
<p>Modern web browsers, even on mobile platforms, run on multi-core CPUs.
To take advantage of all those cores, developers traditionally use
shared-memory threads running concurrently. However, shared-state
concurrency is error prone and can lead to complicated code.</p>
<p>Instead of threads, all Dart code runs inside of isolates. Each isolate
has its own memory heap, ensuring that no isolateâ€™s state is accessible
from any other isolate.</p>
<p>Learn more about isolates in the section called <em>dart:isolate -
Concurrency with Isolates</em>.</p>
<h2 id="typedefs">Typedefs</h2>
<p>In Dart, functions are objects, just like strings and numbers are
objects. A <code>typedef</code>, or function-type alias, gives a function type a
name that you can use when declaring fields and return types. A typedef
retains type information when a function type is assigned to a variable.</p>
<p>Consider the following code, which does not use a <code>typedef</code>:</p>
<pre><code>class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);

  // All we know is that compare is a function, but what type of function?
  assert(collection.compare is Function);
}
</code></pre>
<p>Type information is lost when assigning <code>f</code> to compare. The type of <code>f</code>
is <code>(Object, Object) â†’ int</code> (where <code>â†’</code> means returns), yet the type of
compare is Function. If we change the code to use explicit names and
retain type information, both developers and tools can use that
information.</p>
<pre><code>typedef int Compare(Object a, Object b);

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);
  assert(collection.compare is Function);
  assert(collection.compare is Compare);
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Currently, typedefs are restricted to function types. We expect this
to change.</p>
</blockquote>
<p>Because typedefs are simply aliases, they offer a way to check the type
of any function. For example:</p>
<pre><code>typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare);  // True!
}
</code></pre>
<h2 id="metadata">Metadata</h2>
<p>Use metadata to give additional information about your code. A metadata
annotation begins with the character <code>@</code>, followed by either a reference
to a compile-time constant (such as deprecated) or a call to a constant
constructor.</p>
<p>The meta package defines the API for two common annotations:
<code>@deprecated</code> and <code>@overrides</code>. Hereâ€™s an example of using the
<code>@deprecated</code> annotation:</p>
<pre><code>import 'package:meta/meta.dart'; // Defines deprecated.

class Television {
  /// _Deprecated: Use [turnOn] instead._
  @deprecated      // Metadata; makes Dart Editor warn about using activate().
  void activate() {
    turnOn();
  }

  /// Turns the TV's power on.
  void turnOn() {
    print('on!');
  }
}
</code></pre>
<p>You can define your own metadata annotations. For example, hereâ€™s how
the meta package defines the deprecated constant:</p>
<pre><code>const deprecated = const _Deprecated();

class _Deprecated {
  const _Deprecated();
}
</code></pre>
<p>Hereâ€™s an example of defining a <code>@todo</code> annotation that takes two
arguments:</p>
<pre><code>library todo;

class todo {
  final String who;
  final String what;

  const todo(this.who, this.what);
}
</code></pre>
<p>And hereâ€™s an example of using that @todo annotation:</p>
<pre><code>import 'todo.dart';

@todo('seth', 'make this do something')
void doSomething() {
  print('do something');
}
</code></pre>
<p>Metadata can appear before a library, class, typedef, type parameter,
constructor, factory, function, field, parameter, or variable
declaration and before an import or export directive. In the future,
youâ€™ll be able to retrieve metadata at runtime using reflection.</p>
<h2 id="comments">Comments</h2>
<p>Dart supports single-line comments, multi-line comments, and
documentation comments.</p>
<h3 id="single-line-comments">Single-Line Comments</h3>
<p>A single-line comment begins with <code>//</code>. Everything between <code>//</code> and the
end of line is ignored by the Dart compiler.</p>
<pre><code>main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}
</code></pre>
<h3 id="multi-line-comments">Multi-Line Comments</h3>
<p>A multi-line comment begins with /* and ends with <strong>/. Everything
between /</strong> and */ is ignored by the Dart compiler (unless the comment
is a documentation comment; see the next section). Multi-line comments
can nest.</p>
<pre><code>main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = new Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}
</code></pre>
<h3 id="documentation-comments">Documentation Comments</h3>
<p>Documentation comments are multi-line or single-line comments that begin
with <code>/**</code> or <code>///</code>. Using <code>///</code> on consecutive lines has the same
effect as a multi-line doc comment.</p>
<p>Inside a documentation comment, the Dart compiler ignores all text
unless it is enclosed in brackets. Using brackets, you can refer to
classes, methods, fields, top-level variables, functions, and
parameters. The names in brackets are resolved in the lexical scope of
the documented program element.</p>
<p>Here is an example of documentation comments with references to other
classes and arguments:</p>
<pre><code>/**
 * The llama (Lama glama) is a domesticated South American
 * camelid, widely used as a meat and pack animal by Andean
 * cultures since pre-Hispanic times.
 */
class Llama {
  String name;

  /**
   * Feeds your llama [Food].
   *
   * The typical llama eats one bale of hay per week.
   */
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}
</code></pre>
<p>In the generated documentation, [Food] becomes a link to the API docs
for the Food class.</p>
<p>To parse Dart code and generate HTML documentation, you can use Dart
Editor, which in turn uses the SDKâ€™s dartdoc package. For an example of
generated documentation, see the Dart API documentation.</p>
<h1 id="ocaml">OCaml</h1>
<p>De programmeertaal OCaml.</p>
<h1 id="go">Go</h1>
<p>De programmeertaal Go.</p>
<h1 id="rust">Rust</h1>
<p>De programmeertaal Rust.</p>
<h1 id="clojure">Clojure</h1>
<p>De programmeertaal Clojure.</p>
<h1 id="scheme">Scheme</h1>
<p>De programmeertaal Scheme.</p>
<h1 id="coloru">Coloru</h1>
<p>De programmeertaal Coloru.</p>
<h1 id="scala">Scala</h1>
<p>De programmeertaal Scala.</p>
<h1 id="haskell">Haskell</h1>
<p>De programmeertaal Haskell.</p>
<h1 id="xsl">XSL</h1>
<p>De programmeertaal XSL.</p>
<h1 id="prolog">Prolog</h1>
<p>De programmeertaal Prolog.</p>
<h1 id="erlang">Erlang</h1>
<h2 id="inleiding-1">Inleiding</h2>
<p>De programmeertaal Erlang is ontworpen door Ericsson.</p>
<h2 id="de-shell">De shell</h2>
<p>De shell start je met:</p>
<pre><code>erl
Erlang R14B02 (erts-5.8.3) [source] [smp:2:2] [rq:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.8.3  (abort with ^G)
1&gt;
User switch command
 --&gt;
 --&gt; h
  c [nn]           - connect to job
  i [nn]           - interrupt job
  k [nn]           - kill job
  j                - list all jobs
  s [shell]        - start local shell
  r [node [shell]] - start remote shell
  q                - quit erlang
  ? | h            - this message
 --&gt;
</code></pre>
<p>Met <code>^g</code> kan je onderbreken. Bij de prompt die dan verschijnt kan je
user switch commands gebruiken. Met <code>h</code> wordt een overzicht gegeven van
de commandoâ€™s.</p>
<p>Bij <code>^C</code> kan jee ook commandoâ€™s gebruiken:</p>
<pre><code>BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
</code></pre>
<p>Je kan bij de gewone prompt ook stoppen met <code>q()</code> of <code>init:stop()</code>.</p>
<p><code>erl</code> verstaat het gebruik van TAB. Type <code>li</code> gevolgd door TAB en je
ziet dat dit uigebreid wordt tot <code>lists:</code>. Nog een TAB geeft een
overzicht van alle methoden in de module <code>lists</code>.</p>
<h2 id="datatypes">Datatypes</h2>
<h3 id="integer">Integer</h3>
<pre><code>123               gewone integer
1234567899999999  bigint
</code></pre>
<p>Getallen in een andere basis gaat ook:</p>
<pre><code>2#1010
8#377
</code></pre>
<p>Karaktercodes krijg je zo:</p>
<pre><code>$9
$A
$\n
</code></pre>
<h3 id="floats">Floats</h3>
<p>Worden zo geschreven:</p>
<pre><code>1e10
</code></pre>
<p>De bewerkingen zijn *, -, * en /. Voor de deling kan je / en <code>div</code>
gebruiken. Het laatste is voor gehele getallen. Voor de rest heb je
<code>rem</code>.</p>
<h3 id="bitbewerkingen">Bitbewerkingen</h3>
<p>Deze zijn:</p>
<pre><code>bsl  shift left
bsr  shift right
band en
bor  of
bxor exclusive of
bnot niet
</code></pre>
<h3 id="binaries">Binaries</h3>
<p>Stellen een aantal unsigned 8 bit waarden voor:</p>
<pre><code>&lt;&lt;1, 2, 3 &gt;&gt;
&lt;&lt;&quot;hallo&quot;, 78, 98&gt;&gt;
</code></pre>
<h3 id="atomen">Atomen</h3>
<p>Hebben altijd als eerste teken een kleine letter. De rest mag groot,
underscore, cijfer of <code>@</code> zijn.</p>
<pre><code>punt
vlak
n66
</code></pre>
<p>Bij spaties moet je single quotes gebruiken.</p>
<pre><code>'Dit is een atom'
</code></pre>
<p>De maximale lengte is 255.</p>
<p>Deze woorden zijn verboden als atom:</p>
<pre><code>after and andalso band begin
bnot bor bsl bsr bxor case catch cond div
end fun if let not of or orelse query
receive rem try when xor
</code></pre>
<h3 id="tuples">Tuples</h3>
<pre><code>{4, 5}
{punt, 6, 7}
</code></pre>
<h3 id="lists-1">Lists</h3>
<p>Voorbeelden:</p>
<pre><code>[]
[1, 2, 3]
</code></pre>
<p>Een element en een lijst samenvoegen doe je zo:</p>
<pre><code>[1 | [2,3]] geeft [1, 2, 3]
</code></pre>
<p>Lijsten samenvoegen gaat ook:</p>
<pre><code>[1,2] ++ [3,4] geeft [1, 2, 3, 4]
</code></pre>
<p>Er zijn BIFâ€™s die head en tail van een lijst leveren:</p>
<pre><code>hd([1,2,3]) geeft 1
tl([1,2,3]) geeft [2,3]
length([1,2,3,4]) geeft 4
</code></pre>
<h3 id="strings-2">Strings</h3>
<p>Strings worden naar lijsten omgezet.</p>
<pre><code>&quot;ABC&quot; geeft [65, 66, 67]
</code></pre>
<h3 id="pids-poorten-en-referenties">Pids, Poorten en referenties</h3>
<p>Een pid krijg je terug als je een proces maakt.</p>
<pre><code>&lt;0.35.0&gt;
</code></pre>
<p>Een poort is zoals een pid maar je kan ermee met niet-Erlang software
communiceren.</p>
<pre><code>#Port&lt;1.6&gt;
</code></pre>
<p>Referenties zijn unieke labels. Je maakt ze met <code>make_ref()</code>.</p>
<pre><code>#Ref&lt;0.0.0.39&gt;
</code></pre>
<h3 id="vergelijken">Vergelijken</h3>
<p>Doe je met:</p>
<pre><code>==  rekenkundige gelijkheid
/=  rekenkundige ongelijkheid
&lt;
&gt;
=&lt;
&gt;=
</code></pre>
<p>Je hebt nog exacte gelijkheid en exacte ongelijkheid:</p>
<pre><code>=:=
=/=
</code></pre>
<p>Hierbij worden de waarden als boom vergeleken.</p>
<p>Je kan ook samenstellingen maken:</p>
<pre><code>and
or
not
</code></pre>
<p>Om te groeperen gebruik je de haken <code>(</code> en <code>)</code>. Voor short-circuit
testen heb je:</p>
<pre><code>andalso
orelse
</code></pre>
<p>Je kan alles met alles vergelijken:</p>
<pre><code>number &lt; atom &lt; reference &lt; fun
&lt; port &lt; pid &lt; tuple &lt; list &lt; bit string
</code></pre>
<h2 id="modules">Modules</h2>
<p>Roep de functie op met modulenaam:</p>
<pre><code>module:methode(5).
</code></pre>
<p>Dit is een module:</p>
<pre><code>%% This is a simple Erlang module
-module(my_module).
-export([pie/0]).
pie() -&gt;
  3.14.
</code></pre>
<p>Dit is nog een module.</p>
<pre><code>-module(vb1).
-export([double/1, start/0]).
-vsn([1.0]).
-author(&quot;Leo Rutten&quot;).

double(X) -&gt;
   2 * X.

start() -&gt;
   G = double(5),
   io:format(&quot;getal is ~B~n&quot;, [G]).
</code></pre>
<p>En dit is de <code>Makfile</code> om te compileren en uit te voeren.</p>
<pre><code>all: run

vb1.beam: vb1.erl
        erlc vb1.erl

run: vb1.beam
        erl -noshell -s vb1 start

clean:
        rm -vf *.dump
        rm -vf *.beam
        rm -vf *~
</code></pre>
<h2 id="variabelen-en-patronen">Variabelen en patronen</h2>
<p>Beginnen met een hoofdletter. Als dummy variabele kan je <code>_</code> gebruiken.</p>
<p>Het <code>=</code> teken werkt als patroonherkenning.</p>
<pre><code>{A,B,C} = {1,2,3}
</code></pre>
<h2 id="functies-en-clauses">Functies en clauses</h2>
<p>In functies kan je guards inbouwen.</p>
<pre><code>oud_genoeg(X) when X &gt;= 16 -&gt; true;
oud_genoeg(_) -&gt; false.
</code></pre>
<p>Meerdere guards mogen ook:</p>
<pre><code>oud_genoeg(X) when X &gt;= 16, X =&lt; 116 -&gt; true;
oud_genoeg(_) -&gt; false.
</code></pre>
<p>De komma werkt hier als een <code>andalso</code> samenstelling. En de puntkomma
werkt hier als een <code>orelse</code> samenstelling.</p>
<pre><code>niet_oud_genoeg(X) when X &lt; 16; X &gt; 116 -&gt; true;
niet_oud_genoeg(_) -&gt; false.
</code></pre>
<h2 id="ingebouwde-functies">Ingebouwde functies</h2>
<p>Deze bevinden zich in de <code>erlang</code> module. Met de TAB toets kan je ze
zichtbaar maken in <code>erl</code>.</p>
<pre><code>1&gt; erlang:
'!'/2                           '*'/2
'+'/1                           '+'/2
'++'/2                          '-'/1
'-'/2                           '--'/2
'/'/2                           '/='/2
'&lt;'/2                           '=/='/2
'=:='/2                         '=&lt;'/2
'=='/2                          '&gt;'/2
'&gt;='/2                          'and'/2
'band'/2                        'bnot'/1
'bor'/2                         'bsl'/2
'bsr'/2                         'bxor'/2
'div'/2                         'not'/1
'or'/2                          'rem'/2
'xor'/2                         abs/1
adler32/1                       adler32/2
adler32_combine/3               append/2
append_element/2                apply/2
apply/3                         atom_to_binary/2
atom_to_list/1                  await_proc_exit/3
binary_part/2                   binary_part/3
binary_to_atom/2                binary_to_existing_atom/2
binary_to_list/1                binary_to_list/3
binary_to_term/1                binary_to_term/2
bit_size/1                      bitstring_to_list/1
bump_reductions/1               byte_size/1
call_on_load_function/1         cancel_timer/1
check_process_code/2            concat_binary/1
crasher/6                       crc32/1
crc32/2                         crc32_combine/3
date/0                          decode_packet/3
delay_trap/2                    delete_module/1
demonitor/1                     demonitor/2
dexit/2                         dgroup_leader/2
disconnect_node/1               display/1
display_nl/0                    display_string/1
dist_exit/3                     dlink/1
dmonitor_node/3                 dmonitor_p/2
dsend/2                         dsend/3
dunlink/1                       element/2
erase/0                         erase/1
error/1                         error/2
exit/1                          exit/2
external_size/1                 finish_after_on_load/2
float/1                         float_to_list/1
flush_monitor_message/2         format_cpu_topology/1
fun_info/1                      fun_info/2
fun_to_list/1                   function_exported/3
garbage_collect/0               garbage_collect/1
garbage_collect_message_area/0  get/0
get/1                           get_cookie/0
get_keys/1                      get_module_info/1
get_module_info/2               get_stacktrace/0
group_leader/0                  group_leader/2
halt/0                          halt/1
hash/2                          hd/1
hibernate/3                     integer_to_list/1
integer_to_list/2               iolist_size/1
iolist_to_binary/1              is_alive/0
is_atom/1                       is_binary/1
is_bitstring/1                  is_boolean/1
is_builtin/3                    is_float/1
is_function/1                   is_function/2
is_integer/1                    is_list/1
is_number/1                     is_pid/1
is_port/1                       is_process_alive/1
is_record/2                     is_record/3
is_reference/1                  is_tuple/1
length/1                        link/1
list_to_atom/1                  list_to_binary/1
list_to_bitstring/1             list_to_existing_atom/1
list_to_float/1                 list_to_integer/1
list_to_integer/2               list_to_pid/1
list_to_tuple/1                 load_module/2
load_nif/2                      loaded/0
localtime/0                     localtime_to_universaltime/1
localtime_to_universaltime/2    make_fun/3
make_ref/0                      make_tuple/2
make_tuple/3                    match_spec_test/3
max/2                           md5/1
md5_final/1                     md5_init/0
md5_update/2                    memory/0
memory/1                        min/2
module_info/0                   module_info/1
module_loaded/1                 monitor/2
monitor_node/2                  monitor_node/3
nif_error/1                     nif_error/2
node/0                          node/1
nodes/0                         nodes/1
now/0                           open_port/2
phash/2                         phash2/1
phash2/2                        pid_to_list/1
port_call/2                     port_call/3
port_close/1                    port_command/2
port_command/3                  port_connect/2
port_control/3                  port_get_data/1
port_info/1                     port_info/2
port_set_data/2                 port_to_list/1
ports/0                         pre_loaded/0
process_display/2               process_flag/2
process_flag/3                  process_info/1
process_info/2                  processes/0
purge_module/1                  put/2
raise/3                         read_timer/1
ref_to_list/1                   register/2
registered/0                    resume_process/1
round/1                         self/0
send/2                          send/3
send_after/3                    send_nosuspend/2
send_nosuspend/3                seq_trace/2
seq_trace_info/1                seq_trace_print/1
seq_trace_print/2               set_cookie/2
set_cpu_topology/1              setelement/3
setnode/2                       setnode/3
size/1                          spawn/1
spawn/2                         spawn/3
spawn/4                         spawn_link/1
spawn_link/2                    spawn_link/3
spawn_link/4                    spawn_monitor/1
spawn_monitor/3                 spawn_opt/1
spawn_opt/2                     spawn_opt/3
spawn_opt/4                     spawn_opt/5
split_binary/2                  start_timer/3
statistics/1                    subtract/2
suspend_process/1               suspend_process/2
system_flag/2                   system_info/1
system_monitor/0                system_monitor/1
system_monitor/2                system_profile/0
system_profile/2                term_to_binary/1
term_to_binary/2                throw/1
time/0                          tl/1
trace/3                         trace_delivered/1
trace_info/2                    trace_pattern/2
trace_pattern/3                 trunc/1
tuple_size/1                    tuple_to_list/1
universaltime/0                 universaltime_to_localtime/1
unlink/1                        unregister/1
whereis/1                       yield/0
</code></pre>
<h2 id="case-en-if">Case en if</h2>
<p>Bij de if hoort een voorwaarde en aan actie. Een <code>else</code> bestaat niet; je
moet een <code>true</code> gebruiken. Bij de voorwaarden mag je een komma of
puntkomma gebruiken.</p>
<pre><code>doe_test(X) -&gt;
   if X&gt;0  -&gt; io:format(&quot;positief~n&quot;);
      true -&gt; io:format(&quot;niet positief~n&quot;)
   end.
</code></pre>
<p>Dit is een voorbeeld met een <code>case</code>.</p>
<pre><code>insert(X,[]) -&gt;
   [X];
insert(X,Set) -&gt;
   case lists:member(X,Set) of
      true  -&gt; Set;
      false -&gt; [X|Set]
   end.
</code></pre>
<p>Je kan bij de waarden ook guards bijvoegen.</p>
<pre><code>beach(Temperature) -&gt;
   case Temperature of
      {celsius, N} when N &gt;= 20, N =&lt; 45 -&gt;
         'favorable';
      {kelvin, N} when N &gt;= 293, N =&lt; 318 -&gt;
         'scientifically favorable';
      {fahrenheit, N} when N &gt;= 68, N =&lt; 113 -&gt;
         'favorable in the US';
       _ -&gt;
          'avoid beach'
   end.
</code></pre>
<h2 id="recursie">Recursie</h2>
<p>Het eerste voorbeeld gebruikt geen staartrecursie.</p>
<pre><code>lengte([]) -&gt;
   0;
lengte([_X | Rest]) -&gt;
   1 + lengte(Rest).
</code></pre>
<p>Het tweede voorbeeld wel.</p>
<pre><code>lengtetail(L) -&gt;
   lengtetail(L, 0).

lengtetail([], Acc) -&gt;
   Acc;
lengtetail([_X | Rest], Acc) -&gt;
   L = 1 + Acc,
   lengtetail(Rest, L).
</code></pre>
<h2 id="funs">Funs</h2>
<p>Een anonieme functie schrijf je zo:</p>
<pre><code>F = fun(A, B) -&gt; A + B end.
</code></pre>
<p>Hier is een voorbeeld waarin de anonieme functie als parameter wordt
meegegeven.</p>
<pre><code>map(_F, []) -&gt;
   [];
map(F, [X|Rest]) -&gt;
   [F(X) | map(F, Rest)].

map(fun(X) -&gt; 2*X end, [1,2,3]).
</code></pre>
<p>Er zijn ingebouwde functies die anonymieme functies als parameter
verwachten.</p>
<pre><code>map/2
filter/2
foldr/3
foldl/3
all/2
any/2
dropwhile/2
takewhile/2
partition/2
flatten/1
flatlength/1
flatmap/2
merge/1
nth/2
nthtail/2
split/2
</code></pre>
<h2 id="exceptions-try-en-catch">Exceptions, try en catch</h2>
<h3 id="errors">Errors</h3>
<p>Dit zijn de run-time fouten.</p>
<pre><code>function_clause
case_clause
if_clause
badarg
undef
badarith
badfun
badarity
</code></pre>
<p>Er zijn 3 soorten exceptions: <code>errors</code>, <code>throws</code> en <code>exits</code>.</p>
<p>Je kan een programma zelf stilleggen met:</p>
<pre><code>erlang:error(badarid).
</code></pre>
<h3 id="exits">Exits</h3>
<p><code>exit/1</code> is een interne exit en <code>exit/2</code> is een externe exit.</p>
<h3 id="throws">Throws</h3>
<p>Dit is zoals Java en C++.</p>
<pre><code>throws(F) -&gt;
   try F() of
      _ -&gt; ok
   catch
      Throw -&gt; {throw, caught, Throw}
   end.
</code></pre>
<h3 id="catch-1">Catch</h3>
<p>Dit is een alternatieve manier om exceptions op te vangen.</p>
<pre><code>catch uitdrukking.
</code></pre>
<h2 id="list-comprehensions">List comprehensions</h2>
<p>Dit is een verkorte schrijfwijze op lijsten op te bouwen.</p>
<pre><code>Lijst = [2*N || N &lt;- [1,2,3,4]].
Lijst2 = [2*N || N &lt;- [1,2,3,4,5,6,7], N rem 2 =:= 0].
[{A,B}||{A,B}&lt;-[{7,3}, {6,3}, {8,4}, {9,4}],A rem B =:= 0].
[{X,Y}||X&lt;-[1, 2, 3],Y&lt;-[4,5,6]].
</code></pre>
<h2 id="datastructuren">Datastructuren</h2>
<h3 id="records">Records</h3>
<p>Records worden intern bijgehouden als tuples.</p>
<pre><code>-record(punt, {x=0, y=0}).

doe_test(P = #punt{}) -&gt;
   io:format(&quot;P is een punt~n&quot;),
   io:format(&quot;   x is ~p~n&quot;, [P#punt.x]),
   io:format(&quot;   y is ~p~n&quot;, [P#punt.y]);
doe_test(P) -&gt;
   io:format(&quot;P is geen punt~n&quot;).

P1 = #punt{x=5, y=7},
io:format(&quot;P1 ~p~n&quot;, [P1]),
doe_test(P1),
doe_test(56),
</code></pre>
<h3 id="proplist">Proplist</h3>
<p>Een <code>proplist</code> is een lijst van key/value tuples.</p>
<pre><code>L = proplists:delete(2, [{1,&quot;een&quot;}, {2,&quot;twee&quot;}, {3,&quot;drie&quot;}]),
io:format(&quot;L is ~p~n&quot;, [L]),
io:format(&quot;2 in ~p~n&quot;, [proplists:is_defined(2, L)]),
io:format(&quot;3 in ~p~n&quot;, [proplists:is_defined(3, L)]).
</code></pre>
<h3 id="orddict">Orddict</h3>
<p>Een <code>orddict</code> is gelijkaardig. Een sleutel wordt slechts eenmaal
opgeslagen.</p>
<pre><code>O = orddict:new(),
O2 = orddict:append(10,&quot;een&quot;, O),
O3 = orddict:store(2,&quot;twee&quot;, O2),
io:format(&quot;O is ~p~n&quot;, [O3]).
</code></pre>
<h3 id="general-balanced-tree">General balanced tree</h3>
<p>Dit is een gebalanceerde boom.</p>
<pre><code>T = gb_trees:empty(),
io:format(&quot;T is ~p~n&quot;, [T]),
T2 = gb_trees:enter(10,&quot;een&quot;, T),
T3 = gb_trees:enter(2,&quot;twee&quot;, T2),
io:format(&quot;T3 is ~p~n&quot;, [T3]).
</code></pre>
<p>Verder bestaan er nog <code>ordsets</code>, <code>sets</code>, <code>gb_sets</code> en <code>sofs</code>. Voor
grafen bestaan de modules <code>digraph</code> en <code>digraph_utils</code>. Er zijn ook nog
de <code>queue</code> en de <code>array</code> modules.</p>
<h2 id="bitsyntax-en-bitstring-comprehensions">Bitsyntax en bitstring comprehensions</h2>
<h2 id="preprocessing-en-include">Preprocessing en include</h2>
<hr>
<h2 id="processen">Processen</h2>
<p>Zo start je een proces met een anonieme functie.</p>
<pre><code>F = fun() -&gt; 2+2 end.
spawn(F).
</code></pre>
<p>Of rechtstreeks:</p>
<pre><code>spawn(fun()-&gt;io:format(&quot;hallo~n&quot;) end).
</code></pre>
<p>Meerdere processen met een list comprehension.</p>
<pre><code>[spawn(fun()-&gt;io:format(&quot;hallo ~p~n&quot;, [X]) end) || X &lt;- lists:seq(1,10)].
</code></pre>
<p><code>self()</code> geeft de id van een proces terug.</p>
<p>Processen kunnen berichten versturen.</p>
<pre><code>self() ! hallo.
</code></pre>
<p>Hier wordt een bericht naar zichzelf gestuurd. Met <code>flush()</code> kan je ze
allemaal ophalen.</p>
<p>Met <code>receive</code> kan je berichten ontvangen. In het volgende voorbeeld
stopt het proces telkens na het ontvangen van een bericht.</p>
<pre><code>-module(conc).
-compile(export_all).

ontvanger() -&gt;
   receive
      hallo -&gt;
         io:format(&quot;hallo~n&quot;);
      bericht -&gt;
         io:format(&quot;bericht~n&quot;);
      _ -&gt;
         io:format(&quot;onbekend bericht~n&quot;)
   end.

main() -&gt;
   io:format(&quot;start~n&quot;),
   Pid = spawn(conc, ontvanger, []),
   Pid ! hallo,
   Pid2 = spawn(conc, ontvanger, []),
   Pid2 ! bericht,
   Pid3 = spawn(conc, ontvanger, []),
   Pid3 ! hello,
   io:format(&quot;einde~n&quot;),
   erlang:halt().
</code></pre>
<p>Met recursie blijft de ontvanger draaien na het ontvangen van berichten.
Door de staartrecursie goeit de stack niet.</p>
<pre><code>-module(conc).
-compile(export_all).

ontvanger() -&gt;
   receive
      hallo -&gt;
         io:format(&quot;hallo~n&quot;);
      bericht -&gt;
         io:format(&quot;bericht~n&quot;);
      _ -&gt;
         io:format(&quot;onbekend bericht~n&quot;)
   end,
   ontvanger().

main() -&gt;
   io:format(&quot;start~n&quot;),
   Pid = spawn(conc, ontvanger, []),
   Pid ! hallo,
   %%Pid2 = spawn(conc, ontvanger, []),
   Pid ! bericht,
   %%Pid3 = spawn(conc, ontvanger, []),
   Pid ! hello,
   io:format(&quot;einde~n&quot;),
   erlang:halt().
</code></pre>
<p>De volgende versie van <code>koelkast</code> is aangepast zodat de toestand kan
bijgehouden. Dit is een lijst van alle objecten in de koelkast.</p>
<pre><code>-module(koelkast).
-compile(export_all).

koelkast(Voedsellijst) -&gt;
   io:format(&quot;koelkast start ~p~n&quot;, [Voedsellijst]),
   receive
      {Van, {plaats, Voedsel}} -&gt;
         io:format(&quot;plaats ~p~n&quot;, [Voedsel]),
         Van ! {self(), ok},
         koelkast([Voedsel | Voedsellijst]);

      {Van, {neem, Voedsel}} -&gt;
         io:format(&quot;neem ~p~n&quot;, [Voedsel]),
         case lists:member(Voedsel, Voedsellijst) of
            true -&gt;
               Van ! {self(), {ok, Voedsel}},
               koelkast(lists:delete(Voedsel, Voedsellijst));
            false -&gt;
               Van ! {self(), niet_gevonden},
               koelkast(Voedsellijst)
         end;

      stop -&gt;
         io:format(&quot;stop~n&quot;),
         ok;

      _ -&gt;
         io:format(&quot;onbekend~n&quot;),
         ok
   end.

antwoord() -&gt;
   receive
      A -&gt; io:format(&quot;antwoord ~p~n&quot;, [A])
   end.

main() -&gt;
   io:format(&quot;start~n&quot;),
   Pid = spawn(koelkast, koelkast, [[appel, tomaat]]),
   Pid ! {self(), {plaats, melk}},
   antwoord(),
   Pid ! {self(), {neem, tomaat}},
   antwoord(),
   Pid ! verkeerd,
   Pid ! stop,

   %% Deze sleep van 5 s is nodig omdat anders
   %% de halt te snel gebeurt.
   timer:sleep(5000),

   io:format(&quot;einde~n&quot;),
   erlang:halt().
</code></pre>
<h2 id="fouten-en-processen">Fouten en processen</h2>
<h3 id="links">Links</h3>
<h3 id="traps">Traps</h3>
<h3 id="monitors">Monitors</h3>
<h3 id="processen-met-naam">Processen met naam</h3>
<h2 id="ets-tabellen">ETS tabellen</h2>
<h1 id="elixir">Elixir</h1>
<h2 id="introduction-1">Introduction</h2>
<p>Welcome! In this tutorial we are going to show you how to get started
with Elixir. We will start with how to install Elixir, how to use its
interactive shell, and basic data types and operators. In later
chapters, we are even going to discuss more advanced subjects such as
macros, protocols and other features provided by Elixir.</p>
<p>To see Elixir in action, check out these introductory screencasts by
Dave Thomas. The first one, <a href="http://www.youtube.com/watch?v=hht9s6nAAx8">Nine Minutes of
Elixir</a>, provides a brief
tour of the language. The second one is a 30-minute <a href="http://www.youtube.com/watch?v=a-off4Vznjs">introduction to
Elixir</a> that&rsquo;ll help you get
started with writing your first functions and creating your first
processes in Elixir. Be sure to follow the next section of this guide to
install Elixir on your machine and then follow along with the videos.</p>
<p>PeepCode also has a two hour video with JosÃ© Valim called <a href="https://peepcode.com/products/elixir">Meet
Elixir</a>.</p>
<p>Keep in mind that Elixir is still in development so if at any point you
receive an error message and you are not sure how to proceed, <a href="https://github.com/elixir-lang/elixir/issues">please
let us know in the issues
tracker</a>. Having
explanative and consistent error messages is one of the many features we
aim for Elixir.</p>
<h3 id="installation">Installation</h3>
<p>The only prerequisite for Elixir is Erlang, version R16B or later. You
can find the source code for <a href="http://www.erlang.org/download.html">Erlang
here</a> or use one of the
<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp">precompiled
packages</a>.</p>
<p>For Windows developers, we recommend the precompiled package. Those on
the UNIX platform can probably get Erlang installed via one of the many
package management tools.</p>
<p>After Erlang is installed, you should be able to open up the command
line (or command prompt) and check the Erlang version by typing <code>erl</code>.
You will see some information as follows:</p>
<pre><code>Erlang R16B (erts-5.10.1) [source] [64-bit] [smp:2:2] [rq:2] [async-threads:0] [hipe] [kernel-poll:false]
</code></pre>
<p>Notice that depending on how you installed Erlang, it will not add
Erlang binaries to your environment. Be sure to have Erlang binaries in
your <a href="http://en.wikipedia.org/wiki/Environment_variable">PATH</a>,
otherwise Elixir won&rsquo;t work!</p>
<p>After Erlang is up and running, it is time to install Elixir. You can do
that via Distributions, Precompiled package or Compiling from Source.</p>
<h4 id="distributions">Distributions</h4>
<p>This tutorial requires Elixir v0.9.0 or later and it may be available in
some distributions:</p>
<ul>
<li>
<p>Homebrew for Mac OS X</p>
<ul>
<li>
<p>Since Elixir requires Erlang R16B, first call
<code>brew tap homebrew/versions</code> and then <code>brew install erlang-r16</code></p>
</li>
<li>
<p>If you have a previous Erlang version installed, unlink it with
<code>brew uninstall erlang</code> and link the new one with
<code>brew link erlang-r16</code></p>
</li>
<li>
<p>Update your homebrew to latest: <code>brew update</code></p>
</li>
<li>
<p>Install Elixir: <code>brew install elixir</code></p>
</li>
</ul>
</li>
<li>
<p>Fedora 17+ and Fedora Rawhide: <code>sudo yum -y install elixir</code></p>
</li>
<li>
<p>Arch Linux : Elixir is available on AUR via <code>yaourt -S elixir</code></p>
</li>
</ul>
<p>If you don&rsquo;t use any of the distributions above, don&rsquo;t worry, we also
provide a precompiled package!</p>
<h4 id="compiling-from-source-unix-and-mingw">Compiling from source (Unix and MinGW)</h4>
<p>You can download and compile Elixir in few steps. You can get the
<a href="https://github.com/elixir-lang/elixir/tags">latest stable release
here</a>, unpack it and then
run <code>make</code> inside the unpacked directory. After that, you are ready to
run the <code>elixir</code> and <code>iex</code> commands from the <code>bin</code> directory. It is
recommended that you add Elixir&rsquo;s <code>bin</code> path to your PATH environment
variable to ease development:</p>
<pre><code>$ export PATH=&quot;$PATH:/path/to/elixir/bin&quot;
</code></pre>
<p>In case you are feeling a bit more adventurous, you can also compile
from master:</p>
<pre><code>$ git clone https://github.com/elixir-lang/elixir.git
$ cd elixir
$ make test
</code></pre>
<p>If the tests pass, you are ready to go. Otherwise, feel free to open an
issue <a href="https://github.com/elixir-lang/elixir">in the issues tracker on
Github</a>.</p>
<h4 id="precompiled-package">Precompiled package</h4>
<p>Elixir provides a <a href="/packages.html">precompiled package for every
release</a>. Precompiled packages are the best option if
you are developing on Windows.</p>
<p>After downloading and unzip-ing the package, you are ready to run the
<code>elixir</code> and <code>iex</code> commands from the <code>bin</code> directory. It is recommended
that you also add Elixir&rsquo;s <code>bin</code> path to your PATH environment variable
to ease development.</p>
<h3 id="interactive-mode">Interactive mode</h3>
<p>When you install Elixir, you will have three new executables: <code>iex</code>,
<code>elixir</code> and <code>elixirc</code>. If you compiled Elixir from source or you are
using a packaged version, you can find these inside the <code>bin</code> directory.</p>
<p>For now, let&rsquo;s start by running <code>iex</code> which stands for Interactive
Elixir. In interactive mode, we can type any Elixir expression and get
its result straight away. Let&rsquo;s warm up with some basic arithmetic
expressions:</p>
<pre><code>iex&gt; 1 + 1
2
iex&gt; 10 - 5
5
iex&gt; 10 / 2
5.0
</code></pre>
<p>Notice <code>10 / 2</code> returned a float <code>5.0</code> instead of an integer. This is
expected. In Elixir the operator <code>/</code> always returns a float. In case you
want to do integer division or get the division remainder, you can
invoke the <code>div</code> and <code>rem</code> functions:</p>
<pre><code>iex&gt; div(10, 2)
5
iex&gt; div 10, 2
5
iex&gt; rem 10, 3
1
</code></pre>
<p>In the example above, we called two functions called <code>div</code> and <code>rem</code>.
Notice that parentheses are not required in order to invoke a function.
We are going to discuss more about it later. Let&rsquo;s move forward and see
which other data types we have in Elixir:</p>
<h3 id="basic-types">Basic types</h3>
<p>Some basic types are:</p>
<pre><code>iex&gt; 1          # integer
iex&gt; 0x1F       # integer
iex&gt; 1.0        # float
iex&gt; :atom      # atom / symbol
iex&gt; {1,2,3}    # tuple
iex&gt; [1,2,3]    # list
iex&gt; &lt;&lt;1,2,3&gt;&gt;  # binary
</code></pre>
<p>Elixir by default provides many functions to work on those types:</p>
<pre><code>iex&gt; size { 1, 2, 3 }
3

iex&gt; length [ 1, 2, 3 ]
3
</code></pre>
<p>Elixir also provides functions (note the dot between the variable and
arguments when calling a function):</p>
<pre><code># function
iex&gt; x = fn(a, b) -&gt; a + b end
#Fun&lt;erl_eval.12.111823515&gt;
iex&gt; x.(1, 2)
3
</code></pre>
<p>Elixir also supports strings and they are all encoded in UTF-8:</p>
<pre><code>iex&gt; &quot;hellÃ¶&quot;
&quot;hellÃ¶&quot;
</code></pre>
<p>Strings support interpolation too:</p>
<pre><code>iex&gt; name = &quot;world&quot;
iex&gt; &quot;hello #{name}&quot;
&quot;hello world&quot;
</code></pre>
<p>At the end of the day, strings are nothing more than binaries. We can
check it using the <code>is_binary</code> function:</p>
<pre><code>iex&gt; is_binary(&quot;hello&quot;)
true
</code></pre>
<p>Note a single-quoted expression in Elixir is a char list and it is not
the same as a double-quoted one:</p>
<pre><code>iex&gt; is_binary('hello')
false
</code></pre>
<p>We will go into more details about char lists in the next chapter.
Finally, Elixir also provides <code>true</code> and <code>false</code> as booleans:</p>
<pre><code>iex&gt; true
true
iex&gt; is_boolean false
true
</code></pre>
<p>Booleans are represented internally as atoms:</p>
<pre><code>iex&gt; is_atom(true)
true
</code></pre>
<p>Elixir also provides <code>Port</code>, <code>Reference</code>s and <code>PID</code>s as data types
(usually used in process communication) but they are out of the scope of
a getting started tutorial. For now, let&rsquo;s take a look at the basic
operators in Elixir before we move on to the next chapter.</p>
<h3 id="operators-1">Operators</h3>
<p>As we saw earlier, Elixir provides <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> as arithmetic
operators.</p>
<p>Elixir also provides <code>++</code> and <code>--</code> to manipulate lists:</p>
<pre><code>iex&gt; [1,2,3] ++ [4,5,6]
[1,2,3,4,5,6]
iex&gt; [1,2,3] -- [2]
[1,3]
</code></pre>
<p>String concatenation is done via <code>&lt;&gt;</code>:</p>
<pre><code>iex&gt; &quot;foo&quot; &lt;&gt; &quot;bar&quot;
&quot;foobar&quot;
</code></pre>
<p>Elixir also provides three boolean operators: <code>or</code>, <code>and</code> and <code>not</code>.
These operators are strict in the sense they expect a boolean (true or
false) as their first argument:</p>
<pre><code>iex&gt; true and true
true
iex&gt; false or is_atom(:example)
true
</code></pre>
<p>Giving a non-boolean will raise an exception:</p>
<pre><code>iex&gt; 1 and true
** (ArgumentError) argument error
</code></pre>
<p><code>or</code> and <code>and</code> are short-circuit operators. They just execute the right
side in case the left side is not enough to determine the result:</p>
<pre><code>iex&gt; false and error(&quot;This error will never be raised&quot;)
false

iex&gt; true or error(&quot;This error will never be raised&quot;)
true
</code></pre>
<blockquote>
<p>Note: If you are an Erlang developer, <code>and</code> and <code>or</code> in Elixir
actually map to the <code>andalso</code> and <code>orelse</code> operators in Erlang.</p>
</blockquote>
<p>Besides those boolean operators, Elixir also provides <code>||</code>, <code>&amp;&amp;</code> and <code>!</code>
which accept arguments of any type. For these operators, all values
except <code>false</code> and <code>nil</code> will evaluate to true:</p>
<pre><code># or
iex&gt; 1 || true
1
iex&gt; false || 11
11

# and
iex&gt; nil &amp;&amp; 13
nil
iex&gt; true &amp;&amp; 17
17

# !
iex&gt; !true
false
iex&gt; !1
false
iex&gt; !nil
true
</code></pre>
<p>As a rule of thumb, use <code>and</code>, <code>or</code> and <code>not</code> when you are expecting a
booleans. If any of the arguments are non-booleans, use <code>&amp;&amp;</code>, <code>||</code> and
<code>!</code>.</p>
<p>Elixir also provides <code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code> and <code>&gt;</code>
as comparison operators:</p>
<pre><code>iex&gt; 1 == 1
true
iex&gt; 1 != 2
true
iex&gt; 1 &lt; 2
true
</code></pre>
<p>The difference between <code>==</code> and <code>===</code> is that the latter is more strict
when comparing integers and floats:</p>
<pre><code>iex&gt; 1 == 1.0
true
iex&gt; 1 === 1.0
false
</code></pre>
<p>In Elixir, we can compare two different data types:</p>
<pre><code>iex&gt; 1 &lt; :atom
true
</code></pre>
<p>The reason we can compare different data types is for pragmatism.
Sorting algorithms don&rsquo;t need to worry about different data types in
order to sort. The overall sorting order is defined below:</p>
<pre><code>number &lt; atom &lt; reference &lt; functions &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string
</code></pre>
<p>You actually don&rsquo;t need to memorize this ordering, but it is important
just to know an order exists.</p>
<p>Well, that is it for the introduction. In the next chapter, we are going
to discuss some basic functions, data types conversions and a bit of
control-flow.</p>
<h2 id="diving-in">Diving in</h2>
<p>In this chapter we&rsquo;ll go a bit deeper into the basic data-types, learn
some control flow mechanisms and talk about anonymous functions.</p>
<h3 id="lists-and-tuples">Lists and tuples</h3>
<p>Elixir provides both lists and tuples:</p>
<pre><code>iex&gt; is_list [1,2,3]
true
iex&gt; is_tuple {1,2,3}
true
</code></pre>
<p>While both are used to store items, they differ on how those items are
stored in memory. Lists are implemented as linked lists (where each item
in the list points to the next item) while tuples are stored
contiguously in memory.</p>
<p>This means that accessing a tuple element is very fast (constant time)
and can be achieved using the <code>elem</code> function:</p>
<pre><code>iex&gt; elem { :a, :b, :c }, 0
:a
</code></pre>
<p>On the other hand, updating a tuple is expensive as it needs to
duplicate the tuple contents in memory. Updating a tuple can be done
with the <code>set_elem</code> function:</p>
<pre><code>iex&gt; set_elem { :a, :b, :c }, 0, :d
{:d,:b,:c}
</code></pre>
<blockquote>
<p>Note: If you are an Erlang developer, you will notice that we used the
<code>elem</code> and <code>set_elem</code> functions instead of Erlang&rsquo;s <code>element</code> and
<code>setelement</code>. The reason for this choice is that Elixir attempts to
normalize Erlang API&rsquo;s to always receive the <code>subject</code> of the function
as the first argument and employ zero-based access.</p>
</blockquote>
<p>Since updating a tuple is expensive, when we want to add or remove
elements, we use lists. Since lists are linked, it means accessing the
first element of the list is very cheap. Accessing the n-th element,
however, will require the algorithm to pass through n-1 nodes before
reaching the n-th. We can access the <code>head</code> of the list as follows:</p>
<pre><code># Match the head and tail of the list
iex&gt; [head | tail] = [1,2,3]
[1,2,3]
iex&gt; head
1
iex&gt; tail
[2,3]

# Put the head and the tail back together
iex&gt; [head | tail]
[1,2,3]
iex&gt; length [head | tail]
3
</code></pre>
<p>In the example above, we have matched the head of the list to the
variable <code>head</code> and the tail of the list to the variable <code>tail</code>. This is
called <em>pattern matching</em>. We can also pattern match tuples:</p>
<pre><code>iex&gt; { a, b, c } = { :hello, &quot;world&quot;, 42 }
{ :hello, &quot;world&quot;, 42 }
iex&gt; a
:hello
iex&gt; b
&quot;world&quot;
</code></pre>
<p>A pattern match will error in case the sides can&rsquo;t match. This is, for
example, the case when the tuples have different sizes:</p>
<pre><code>iex&gt; { a, b, c } = { :hello, &quot;world&quot; }
** (MatchError) no match of right hand side value: {:hello,&quot;world&quot;}
</code></pre>
<p>And also when comparing different types:</p>
<pre><code>iex&gt; { a, b, c } = [:hello, &quot;world&quot;, '!']
** (MatchError) no match of right hand side value: [:hello,&quot;world&quot;]
</code></pre>
<p>More interestingly, we can match on specific values. The example below
asserts that the left side will only match the right side in case that
the right side is a tuple that starts with the atom <code>:ok</code> as a key:</p>
<pre><code>iex&gt; { :ok, result } = { :ok, 13 }
{:ok,13}
iex&gt; result
13

iex&gt; { :ok, result } = { :error, :oops }
** (MatchError) no match of right hand side value: {:error,:oops}
</code></pre>
<p>Pattern matching allows developers to easily destruct data types such as
tuples and lists. As we will see in following chapters, it is one of the
foundations of recursion in Elixir. However, in case you can&rsquo;t wait to
iterate through and manipulate your lists, the <a href="/docs/stable/Enum.html"><code>Enum</code>
module</a> provides several helpers to manipulate
lists (and other enumerables in general) while the <a href="/docs/stable/List.html"><code>List</code>
module</a> provides several helpers specific to
lists:</p>
<pre><code>iex&gt; Enum.at [1,2,3], 0
1
iex&gt; List.flatten [1,[2],3]
[1,2,3]
</code></pre>
<h3 id="keyword-lists">Keyword lists</h3>
<p>Elixir also provides a special syntax to create a list of keywords. They
can be created as follows:</p>
<pre><code>iex&gt; [a: 1, b: 2]
[a: 1, b: 2]
</code></pre>
<p>Keyword lists are nothing more than a list of two element tuples where
the first element of the tuple is an atom:</p>
<pre><code>iex&gt; [head | tail] = [a: 1, b: 2]
[a: 1, b: 2]
iex&gt; head
{ :a, 1 }
</code></pre>
<p>The <a href="/docs/stable/Keyword.html"><code>Keyword</code> module</a> contains several
functions that allow you to manipulate a keyword list ignoring
duplicated entries or not. For example:</p>
<pre><code>iex&gt; keywords = [foo: 1, bar: 2, foo: 3]
iex&gt; Keyword.get keywords, :foo
1
iex&gt; Keyword.get_values keywords, :foo
[1,3]
</code></pre>
<p>Since keyword lists are very frequently passed as arguments, they do not
require brackets when given as the last argument in a function call. For
instance, the examples below are valid and equivalent:</p>
<pre><code>iex&gt; if(2 + 2 == 4, [do: &quot;OK&quot;])
&quot;OK&quot;
iex&gt; if(2 + 2 == 4, do: &quot;OK&quot;)
&quot;OK&quot;
iex&gt; if 2 + 2 == 4, do: &quot;OK&quot;
&quot;OK&quot;
</code></pre>
<h2 id="strings-and-char-lists">Strings and char lists</h2>
<p>In Elixir, a double-quoted string is not the same as a single-quoted
one:</p>
<pre><code>iex&gt; &quot;hello&quot; == 'hello'
false
iex&gt; is_binary &quot;hello&quot;
true
iex&gt; is_list 'hello'
true
</code></pre>
<p>As shown above, double-quoted returns a binary while single-quoted
returns a list. In fact, both double-quoted and single-quoted
representations are just a shorter representation of binaries and lists
respectively. Given that <code>?a</code> in Elixir returns the ASCII integer for
the letter <code>a</code>, we could also write:</p>
<pre><code>iex&gt; &lt;&lt;?a, ?b, ?c&gt;&gt;
&quot;abc&quot;
iex&gt; [?a, ?b, ?c]
'abc'
</code></pre>
<p>In such cases, Elixir detects that all characters in the binary and in
the list are printable and returns the quoted representation. However,
adding a non-printable character forces them to be printed differently:</p>
<pre><code>iex&gt; &lt;&lt;?a, ?b, ?c, 1&gt;&gt;
&lt;&lt;97,98,99,1&gt;&gt;

iex&gt; [?a, ?b, ?c, 1]
[97,98,99,1]
</code></pre>
<p>Since lists are implemented as linked lists, it means a char list
usually takes a lot of space in memory (one word for each character and
another word to point to the next character). For this reason,
double-quoted is preferred unless you want to explicitly iterate over a
char list (which is sometimes common when interfacing with Erlang code
from Elixir).</p>
<p>Although a bit more verbose, it is also possible to do head/tail style
pattern matching with binaries. A binary is made up of a number of parts
which must be tagged with their type. Most of the time, Elixir will
figure out the part&rsquo;s type and won&rsquo;t require any work from you:</p>
<pre><code>iex&gt; &lt;&lt;102, &quot;oo&quot;&gt;&gt;
&quot;foo&quot;
</code></pre>
<p>In the example, we have two parts: the first is an integer and the
second is a binary. If we use an Elixir expression, Elixir will default
its type to an integer:</p>
<pre><code>iex&gt; rest = &quot;oo&quot;
iex&gt; &lt;&lt;102, rest&gt;&gt;
** (ArgumentError) argument error
</code></pre>
<p>In the example above, since we haven&rsquo;t specified a type for <code>rest</code>,
Elixir expected an integer but we passed a binary, resulting in
<code>ArgumentError</code>. We can solve this by explicitly tagging it as a binary:</p>
<pre><code>iex&gt; &lt;&lt;102, rest :: binary&gt;&gt;
</code></pre>
<p>The type can be <code>integer</code>, <code>float</code>, <code>binary</code>, <code>bytes</code>, <code>bitstring</code>,
<code>bits</code>, <code>utf8</code>, <code>utf16</code> or <code>utf32</code>. We can pass endianness and
signedness too, when passing more than one option, we use a list:</p>
<pre><code>iex&gt; &lt;&lt;102, rest :: [binary, signed]&gt;&gt;
</code></pre>
<p>Not only that, we can also specify the bit size for each part:</p>
<pre><code>iex&gt; &lt;&lt;102, rest :: size(16)&gt;&gt; = &quot;foo&quot;
&quot;foo&quot;
iex&gt; &lt;&lt;102, rest :: size(32)&gt;&gt; = &quot;foo&quot;
** (MatchError) no match of right hand side value: &quot;foo&quot;
</code></pre>
<p>In the example above, the first expression matches because the right
string &ldquo;foo&rdquo; takes 24 bits and we are matching against a binary of 24
bits as well, 8 of which are taken by the integer 102 and the remaining
16 bits are specified on the <code>rest</code>. On the second example, we expect a
<code>rest</code> with size 32, which won&rsquo;t match.</p>
<p>If at any moment, you would like to match the top of a binary against
any other binary without caring about the size of the rest, you can use
binary (which has an unspecified size):</p>
<pre><code>iex&gt; &lt;&lt;102, rest :: binary&gt;&gt; = &quot;foobar&quot;
&quot;foobar&quot;
iex&gt; rest
&quot;oobar&quot;
</code></pre>
<p>This is equivalent to the head and tail pattern matching we saw in
lists. There is much more to binaries and pattern matching in Elixir
that allows great flexibility when working with such structures, but
they are beyond the scope of a getting started guide.</p>
<h3 id="utf-8-strings">UTF-8 Strings</h3>
<p>A String in Elixir is a binary which is encoded in UTF-8. For example,
the string &ldquo;Ã©&rdquo; is a UTF-8 binary containing two bytes:</p>
<pre><code>iex&gt; string = &quot;Ã©&quot;
&quot;Ã©&quot;
iex&gt; size(string)
2
</code></pre>
<p>In order to easily manipulate strings, Elixir provides a <a href="http://elixir-lang.org/docs/stable/String.html">String
module</a>:</p>
<pre><code># returns the number of bytes
iex&gt; size &quot;hÃ©llÃ²&quot;
7

# returns the number of characters as perceived by humans
iex&gt; String.length &quot;hÃ©llÃ²&quot;
5
</code></pre>
<blockquote>
<p>Note: to retrieve the number of elements in a data structure, you will
use a function named <code>length</code> or <code>size</code>. Their usage is not arbitrary.
The first is used when the number of elements needs to be calculated.
For example, calling <code>length(list)</code> will iterate the whole list to
find the number of elements in that list. <code>size</code> is the opposite, it
means the value is pre-calculated and stored somewhere and therefore
retrieving its value is a cheap operation. That said, we use <code>size</code> to
get the size of a binary, which is cheap, but retrieving the number of
unicode characters uses <code>String.length</code>, since the whole string needs
to be iterated.</p>
</blockquote>
<p>Each character in the string &ldquo;hÃ©llÃ²&rdquo; above is a Unicode codepoint. One
may use <code>String.codepoints</code> to split a string into smaller strings
representing its codepoints:</p>
<pre><code>iex&gt; String.codepoints &quot;hÃ©llÃ²&quot;
[&quot;h&quot;, &quot;Ã©&quot;, &quot;l&quot;, &quot;l&quot;, &quot;Ã³&quot;]
</code></pre>
<p>The Unicode standard assigns an integer value to each character. Elixir
allows a developer to retrieve or insert a character based on its
integer codepoint value as well:</p>
<pre><code># Gettng the integer codepoint
iex&gt; ?h
104
iex&gt; ?Ã©
233

# Inserting a codepoint based on its hexadecimal value
iex&gt; &quot;h\xE9ll\xF2&quot;
&quot;hÃ©llÃ²&quot;
</code></pre>
<p>UTF-8 also plays nicely with pattern matching. In the exemple below, we
are extracting the first UTF-8 codepoint of a String and assigning the
rest of the string to the variable <code>rest</code>:</p>
<pre><code>iex&gt; &lt;&lt; eacute :: utf8, rest :: binary &gt;&gt; = &quot;Ã©pa&quot;
&quot;Ã©pa&quot;
iex&gt; eacute
233
iex&gt; &lt;&lt; eacute :: utf8 &gt;&gt;
&quot;Ã©&quot;
iex&gt; rest
&quot;pa&quot;
</code></pre>
<p>In general, you will find working with binaries and strings in Elixir a
breeze. Whenever you want to work with raw binaries, one can use
<a href="http://www.erlang.org/doc/man/binary.html">Erlang&rsquo;s binary module</a>, and
use <a href="http://elixir-lang.org/docs/stable/String.html">Elixir&rsquo;s String
module</a> when you want to
work on strings, which are simply UTF-8 encoded binaries. Finally, there
are a bunch of conversion functions, that allows you to convert a binary
to integer, atom and vice-versa <a href="http://elixir-lang.org/docs/stable/Kernel.html">in the Kernel
module</a>.</p>
<h3 id="blocks">Blocks</h3>
<p>One of the first control flow constructs we usually learn is the
conditional <code>if</code>. In Elixir, we could write <code>if</code> as follow:</p>
<pre><code>iex&gt; if true, do: 1 + 2
3
</code></pre>
<p>The <code>if</code> expression can also be written using the block syntax:</p>
<pre><code>iex&gt; if true do
...&gt;   a = 1 + 2
...&gt;   a + 10
...&gt; end
13
</code></pre>
<p>You can think of <code>do</code>/<code>end</code> blocks as a convenience for passing a group
of expressions to <code>do:</code>. It is exactly the same as:</p>
<pre><code>iex&gt; if true, do: (
...&gt;   a = 1 + 2
...&gt;   a + 10
...&gt; )
13
</code></pre>
<p>We can pass an <code>else</code> clause in the block syntax:</p>
<pre><code>if false do
  :this
else
  :that
end
</code></pre>
<p>It is important to notice that <code>do</code>/<code>end</code> always binds to the farthest
function call. For example, the following expression:</p>
<pre><code>is_number if true do
  1 + 2
end
</code></pre>
<p>Would be parsed as:</p>
<pre><code>is_number(if true) do
  1 + 2
end
</code></pre>
<p>Which is not what we want since <code>do</code> is binding to the farthest function
call, in this case <code>is_number</code>. Adding explicit parenthesis is enough to
resolve the ambiguity:</p>
<pre><code>is_number(if true do
  1 + 2
end)
</code></pre>
<h3 id="control-flow-structures">Control flow structures</h3>
<p>In this section we&rsquo;ll describe Elixir&rsquo;s main control flow structures.</p>
<h4 id="revisiting-pattern-matching">Revisiting pattern matching</h4>
<p>At the beginning of this chapter we have seen some pattern matching
examples:</p>
<pre><code>iex&gt; [h | t] = [1,2,3]
[1, 2, 3]
iex&gt; h
1
iex&gt; t
[2, 3]
</code></pre>
<p>In Elixir, <code>=</code> is not an assignment operator as in programming languages
like Java, Ruby, Python, etc. <code>=</code> is actually a match operator which
will check if the expressions on both left and right side match.</p>
<p>Many control-flow structures in Elixir rely extensively on pattern
matching and the ability for different clauses too match. In some cases,
you may want to match against the value of a variable, which can be
achieved by with the <code>^</code> operator:</p>
<pre><code>iex&gt; x = 1
1
iex&gt; ^x = 1
1
iex&gt; ^x = 2
** (MatchError) no match of right hand side value: 2
iex&gt; x = 2
2
</code></pre>
<p>In Elixir, it is a common practice to assign a value to underscore <code>_</code>
if we don&rsquo;t intend to use it. For example, if only the head of the list
matters to us, we can assign the tail to underscore:</p>
<pre><code>iex&gt; [h | _] = [1,2,3]
[1, 2, 3]
iex&gt; h
1
</code></pre>
<p>The variable <code>_</code> in Elixir is special in that it can never be read from.
Trying to read from it gives an unbound variable error:</p>
<pre><code>iex&gt; _
** (ErlangError) erlang error {:unbound_var, :_}
</code></pre>
<p>Although pattern matching allows us to build powerful constructs, its
usage is limited. For instance, you cannot make function calls on the
left side of a match. The following example is invalid:</p>
<pre><code>iex&gt; length([1,[2],3]) = 3
** (ErlangError) erlang error :illegal_pattern
</code></pre>
<h4 id="case">Case</h4>
<p>A <code>case</code> allows us to compare a value against many patterns until we
find a matching one:</p>
<pre><code>case { 1, 2, 3 } do
  { 4, 5, 6 } -&gt;
    &quot;This won't match&quot;
  { 1, x, 3 } -&gt;
    &quot;This will match and assign x to 2&quot;
  _ -&gt;
    &quot;This will match any value&quot;
end
</code></pre>
<p>As in the <code>=</code> operator, any assigned variable will be overridden in the
match clause. If you want to pattern match against a variable, you need
to use the <code>^</code> operator:</p>
<pre><code>x = 1
case 10 do
  ^x -&gt; &quot;Won't match&quot;
  _  -&gt; &quot;Will match&quot;
end
</code></pre>
<p>Each match clause also supports special conditions specified via guards:</p>
<pre><code>case { 1, 2, 3 } do
  { 4, 5, 6 } -&gt;
    &quot;This won't match&quot;
  { 1, x, 3 } when x &gt; 0 -&gt;
    &quot;This will match and assign x&quot;
  _ -&gt;
    &quot;No match&quot;
end
</code></pre>
<p>In the example above, the second clause will only match when x is
positive. The Erlang VM only allows a limited set of expressions as
guards:</p>
<ul>
<li>
<p>comparison operators (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;=</code>);</p>
</li>
<li>
<p>boolean operators (<code>and</code>, <code>or</code>) and negation operators (<code>not</code>, <code>!</code>);</p>
</li>
<li>
<p>arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>);</p>
</li>
<li>
<p><code>&lt;&gt;</code> and <code>++</code> as long as the left side is a literal;</p>
</li>
<li>
<p>the <code>in</code> operator;</p>
</li>
<li>
<p>all the following type check functions:</p>
<ul>
<li>
<p>is_atom/1</p>
</li>
<li>
<p>is_binary/1</p>
</li>
<li>
<p>is_bitstring/1</p>
</li>
<li>
<p>is_boolean/1</p>
</li>
<li>
<p>is_float/1</p>
</li>
<li>
<p>is_function/1</p>
</li>
<li>
<p>is_function/2</p>
</li>
<li>
<p>is_integer/1</p>
</li>
<li>
<p>is_list/1</p>
</li>
<li>
<p>is_number/1</p>
</li>
<li>
<p>is_pid/1</p>
</li>
<li>
<p>is_port/1</p>
</li>
<li>
<p>is_record/2</p>
</li>
<li>
<p>is_record/3</p>
</li>
<li>
<p>is_reference/1</p>
</li>
<li>
<p>is_tuple/1</p>
</li>
<li>
<p>is_exception/1</p>
</li>
</ul>
</li>
<li>
<p>plus these functions:</p>
<ul>
<li>
<p>abs(Number)</p>
</li>
<li>
<p>bit_size(Bitstring)</p>
</li>
<li>
<p>byte_size(Bitstring)</p>
</li>
<li>
<p>div(Number, Number)</p>
</li>
<li>
<p>elem(Tuple, n)</p>
</li>
<li>
<p>float(Term)</p>
</li>
<li>
<p>hd(List)</p>
</li>
<li>
<p>length(List)</p>
</li>
<li>
<p>node()</p>
</li>
<li>
<p>node(Pid|Ref|Port)</p>
</li>
<li>
<p>rem(Number, Number)</p>
</li>
<li>
<p>round(Number)</p>
</li>
<li>
<p>self()</p>
</li>
<li>
<p>size(Tuple|Bitstring)</p>
</li>
<li>
<p>tl(List)</p>
</li>
<li>
<p>trunc(Number)</p>
</li>
<li>
<p>tuple_size(Tuple)</p>
</li>
</ul>
</li>
</ul>
<p>Many independent guard clauses can also be given at the same time. For
example, consider a function that checks if the first element of a tuple
or a list is zero. It could be written as:</p>
<pre><code>def first_is_zero?(tuple_or_list) when
  elem(tuple_or_list, 1) == 0 or hd(tuple_or_list) == 0 do
  true
end
</code></pre>
<p>However, the example above will always fail. If the argument is a list,
calling <code>elem</code> on a list will raise an error. If the element is a tuple,
calling <code>hd</code> on a tuple will also raise an error. To fix this, we can
rewrite it to become two different clauses:</p>
<pre><code>def first_is_zero?(tuple_or_list)
    when elem(tuple_or_list, 1) == 0
    when hd(tuple_or_list) == 0 do
  true
end
</code></pre>
<p>In such cases, if there is an error in one of the guards, it won&rsquo;t
affect the next one.</p>
<h4 id="functions-1">Functions</h4>
<p>In Elixir, anonymous functions can accept many clauses and guards,
similar to the <code>case</code> mechanism we have just seen:</p>
<pre><code>f = fn
  x, y when x &gt; 0 -&gt; x + y
  x, y -&gt; x * y
end

f.(1, 3)  #=&gt; 4
f.(-1, 3) #=&gt; -3
</code></pre>
<p>As Elixir is an immutable language, the binding of the function is also
immutable. This means that setting a variable inside the function does
not affect its outer scope:</p>
<pre><code>x = 1
(fn -&gt; x = 2 end).()
x #=&gt; 1
</code></pre>
<h4 id="receive">Receive</h4>
<p>This next control-flow mechanism is essential to Elixir&rsquo;s and Erlang&rsquo;s
actor mechanism. In Elixir, the code is run in separate processes that
exchange messages between them. Those processes are not Operating System
processes (they are actually quite light-weight) but are called so since
they do not share state with each other.</p>
<p>In order to exchange messages, each process has a mailbox where the
received messages are stored. The <code>receive</code> mechanism allows us to go
through this mailbox searching for a message that matches the given
pattern. Here is an example that uses the arrow operator <code>&lt;-</code> to send a
message to the current process and then collects this message from its
mailbox:</p>
<pre><code># Get the current process id
iex&gt; current_pid = self

# Spawn another process that will send a message to current_pid
iex&gt; spawn fn -&gt;
  current_pid &lt;- { :hello, self }
end
&lt;0.36.0&gt;


# Collect the message
iex&gt; receive do
...&gt;   { :hello, pid } -&gt;
...&gt;     IO.puts &quot;Hello from #{inspect(pid)}&quot;
...&gt; end
Hello from &lt;0.36.0&gt;
</code></pre>
<p>You may not see exactly <code>&lt;0.36.0&gt;</code> back, but something similar. If there
are no messages in the mailbox, the current process will hang until a
matching message arrives unless an after clause is given:</p>
<pre><code>iex&gt; receive do
...&gt;   :waiting -&gt;
...&gt;     IO.puts &quot;This may never come&quot;
...&gt; after
...&gt;   1000 -&gt; # 1 second
...&gt;     IO.puts &quot;Too late&quot;
...&gt; end
Too late
</code></pre>
<p>Notice we spawned a new process using the <code>spawn</code> function passing
another function as argument. We will talk more about those processes
and even how to exchange messages in between different nodes in a later
chapter.</p>
<h4 id="try">Try</h4>
<p><code>try</code> in Elixir is used to catch values that are thrown. Let&rsquo;s start
with an example:</p>
<pre><code>iex&gt; try do
...&gt;   throw 13
...&gt; catch
...&gt;   number -&gt; number
...&gt; end
13
</code></pre>
<p><code>try/catch</code> is a control-flow mechanism, useful in rare situations where
your code has complex exit strategies and it is easier to <code>throw</code> a
value back up in the stack. <code>try</code> also supports guards in <code>catch</code> and an
<code>after</code> clause that is invoked regardless of whether or not the value
was caught:</p>
<pre><code>iex&gt; try do
...&gt;   throw 13
...&gt; catch
...&gt;   nan when not is_number(nan) -&gt; nan
...&gt; after
...&gt;   IO.puts &quot;Didn't catch&quot;
...&gt; end
Didn't catch
** throw 13
    erl_eval:expr/3
</code></pre>
<p>Notice that a thrown value which hasn&rsquo;t been caught halts the software.
For this reason, Elixir considers such clauses unsafe (since they may or
may not fail) and does not allow variables defined inside
<code>try/catch/after</code> to be accessed from the outer scope:</p>
<pre><code>iex&gt; try do
...&gt;   new_var = 1
...&gt; catch
...&gt;   value -&gt; value
...&gt; end
1
iex&gt; new_var
** error :undef
</code></pre>
<p>The common strategy is to explicitly return all arguments from <code>try</code>:</p>
<pre><code>{ x, y } = try do
  x = calculate_some_value()
  y = some_other_value()
  { x, y }
catch
  _ -&gt; { nil, nil }
end

x #=&gt; returns the value of x or nil for failures
</code></pre>
<h4 id="if-and-unless">If and Unless</h4>
<p>Besides the four main control-flow structures above, Elixir provides
some extra control-flow structures to help on our daily work. For
example, <code>if</code> and <code>unless</code>:</p>
<pre><code>iex&gt; if true do
iex&gt;   &quot;This works!&quot;
iex&gt; end
&quot;This works!&quot;

iex&gt; unless true do
iex&gt;   &quot;This will never be seen&quot;
iex&gt; end
nil
</code></pre>
<p>Remember that <code>do/end</code> blocks in Elixir are simply a shortcut to the
keyword notation. So one could also write:</p>
<pre><code>iex&gt; if true, do: &quot;This works!&quot;
&quot;This works!&quot;
</code></pre>
<p>Or even more complex examples like:</p>
<pre><code># This is equivalent...
if false, do: 1 + 2, else: 10 + 3

# ... to this
if false do
  1 + 2
else
  10 + 3
end
</code></pre>
<p>In Elixir, all values except <code>false</code> and <code>nil</code> evaluate to <code>true</code>.
Therefore there is no need to explicitly convert the <code>if</code> argument to a
boolean. If you want to check if one of many conditions are true, you
can use the <code>cond</code> macro.</p>
<h4 id="cond">Cond</h4>
<p>Whenever you want to check for many conditions at the same time, Elixir
allows developers to use <code>cond</code> insted of nesting many <code>if</code> expressions:</p>
<pre><code>cond do
  2 + 2 == 5 -&gt;
    &quot;This will never match&quot;
  2 * 2 == 3 -&gt;
    &quot;Nor this&quot;
  1 + 1 == 2 -&gt;
    &quot;But this will&quot;
end
</code></pre>
<p>If none of the conditions return true, an error will be raised. For this
reason, it is common to see a last condition equal to <code>true</code>, which will
always match:</p>
<pre><code>cond do
  2 + 2 == 5 -&gt;
    &quot;This will never match&quot;
  2 * 2 == 3 -&gt;
    &quot;Nor this&quot;
  true -&gt;
    &quot;This will always match (equivalent to else)&quot;
end
</code></pre>
<h3 id="built-in-functions">Built-in functions</h3>
<p>Elixir ships with many built-in functions automatically available in the
current scope. In addition to the control flow expressions seen above,
Elixir also adds: <code>elem</code> and <code>set_elem</code> to read and set values in
tuples, <code>inspect</code> that returns the representation of a given data type
as a binary, and many others. All of these functions imported by default
are available in <a href="/docs/stable/Kernel.html"><code>Kernel</code></a> and <a href="/docs/stable/Kernel.SpecialForms.html">Elixir
special forms are available in
<code>Kernel.SpecialForms</code></a>.</p>
<p>All of these functions and control flow expressions are essential for
building Elixir programs. In some cases though, one may need to use
functions available from Erlang, let&rsquo;s see how.</p>
<h3 id="calling-erlang-functions">Calling Erlang functions</h3>
<p>One of Elixir&rsquo;s assets is easy integration with the existing Erlang
ecosystem. Erlang ships with a group of libraries called OTP (Open
Telecom Platform). Besides being a standard library, OTP provides
several facilities to build OTP applications with supervisors that are
robust, distributed and fault-tolerant.</p>
<p>Since an Erlang module is nothing more than an atom, invoking those
libraries from Elixir is quite straight-forward. For example, we can
call the <a href="http://www.erlang.org/doc/man/lists.html#flatten-1">function <code>flatten</code> from the module
<code>lists</code></a> or interact
with <a href="http://www.erlang.org/doc/man/math.html">the math module</a> as
follows:</p>
<pre><code>iex&gt; :lists.flatten [1,[2],3]
[1,2,3]
iex&gt; :math.sin :math.pi
1.2246467991473532e-16
</code></pre>
<p>Erlang&rsquo;s OTP is very well documented and we will learn more about
building OTP applications in the Mix chapters:</p>
<ul>
<li>
<p><a href="http://www.erlang.org/doc/">OTP docs</a></p>
</li>
<li>
<p><a href="http://www.erlang.org/doc/man/STDLIB_app.html">Standard library
docs</a></p>
</li>
</ul>
<p>That&rsquo;s all for now. The next chapter will discuss how to organize our
code into modules so it can be easily reused between different
applications.</p>
<h3 id="modules-1">Modules</h3>
<p>In Elixir, you can group several functions into a module. In the
previous chapter, for example, we invoked functions from the
<a href="/docs/stable/List.html"><code>module List</code></a>:</p>
<pre><code>iex&gt; List.flatten [1,[2],3]
[1, 2, 3]
</code></pre>
<p>In order to create our own modules in Elixir, all we have to do is to
call the <code>defmodule</code> function and use <code>def</code> to define our functions:</p>
<pre><code>iex&gt; defmodule Math do
...&gt;   def sum(a, b) do
...&gt;     a + b
...&gt;   end
...&gt; end

iex&gt; Math.sum(1, 2)
3
</code></pre>
<p>Before diving into modules, let&rsquo;s first have a brief overview about
compilation.</p>
<h3 id="compilation">Compilation</h3>
<p>Most of the time it is convenient to write modules into files so they
can be compiled and reused. Let&rsquo;s assume we have a file named <code>math.ex</code>
with the following contents:</p>
<pre><code>defmodule Math do
  def sum(a, b) do
    a + b
  end
end
</code></pre>
<p>This file can be compiled using <code>elixirc</code> (remember, if you installed
Elixir from a package or compiled it, <code>elixirc</code> will be inside the bin
directory):</p>
<pre><code>elixirc math.ex
</code></pre>
<p>This will generate a file named <code>Elixir.Math.beam</code> containing the
bytecode for the defined module. Now, if we start <code>iex</code> again, our
module definition will be available (considering <code>iex</code> is being started
in the same directory the bytecode file is):</p>
<pre><code>iex&gt; Math.sum(1, 2)
3
</code></pre>
<p>Elixir projects are usually organized into three directories:</p>
<ul>
<li>
<p>ebin - contains the compiled bytecode</p>
</li>
<li>
<p>lib - contains elixir code (usually <code>.ex</code> files)</p>
</li>
<li>
<p>test - contains tests (usually <code>.exs</code> files)</p>
</li>
</ul>
<p>Whenever interacting with an existing library, you may need to
explicitly tell Elixir to look for bytecode in the <code>ebin</code> directory:</p>
<pre><code>iex -pa ebin
</code></pre>
<p>Where <code>-pa</code> stands for <code>path append</code>. The same option can also be passed
to <code>elixir</code> and <code>elixirc</code> executables. You can execute <code>elixir</code> and
<code>elixirc</code> without arguments to get a list of options.</p>
<h3 id="scripted-mode">Scripted mode</h3>
<p>In addition to the Elixir file <code>.ex</code>, Elixir also supports <code>.exs</code> files
for scripting. Elixir treats both files exactly the same way, the only
difference is in intention. <code>.ex</code> files are meant to be compiled while
<code>.exs</code> files are used for scripting, without the need for compilation.
For instance, one can create a file called <code>math.exs</code>:</p>
<pre><code>defmodule Math do
  def sum(a, b) do
    a + b
  end
end

IO.puts Math.sum(1, 2)
</code></pre>
<p>And execute it as:</p>
<pre><code>elixir math.exs
</code></pre>
<p>The file will be compiled in memory and executed, printing 3 as the
result. No bytecode file will be created.</p>
<h3 id="functions-and-private-functions">Functions and private functions</h3>
<p>Inside a module, we can define functions with <code>def</code> and private
functions with <code>defp</code>. A function defined with <code>def</code> is available to be
invoked from other modules while a private function can only be invoked
locally.</p>
<pre><code>defmodule Math do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end
end

Math.sum(1, 2)    #=&gt; 3
Math.do_sum(1, 2) #=&gt; ** (UndefinedFunctionError)
</code></pre>
<p>Function declarations also support guards and multiple clauses. If a
function has several clauses, Elixir will try each clause until it finds
one that matches. Here is the implementation of a function that checks
if the given number is zero or not:</p>
<pre><code>defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_number(x) do
    false
  end
end

Math.zero?(0)  #=&gt; true
Math.zero?(1)  #=&gt; false

Math.zero?([1,2,3])
#=&gt; ** (FunctionClauseError)
</code></pre>
<p>Giving an argument that does not match any of the clauses raises an
error.</p>
<p>Named functions also support default arguments:</p>
<pre><code>defmodule Concat do
  def join(a, b, sep // &quot; &quot;) do
    a &lt;&gt; sep &lt;&gt; b
  end
end

IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;)      #=&gt; Hello world
IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;, &quot;_&quot;) #=&gt; Hello_world
</code></pre>
<p>Any expression is allowed to serve as a default value, but it won&rsquo;t be
evaluated during the function definition; it will simply be stored for
later use. Every time the function is invoked and any of its default
values have to be used, the expression for that default value will be
evaluated:</p>
<pre><code>defmodule DefaultTest do
  def dowork(x // IO.puts &quot;hello&quot;) do
    x
  end
end

iex&gt; DefaultTest.dowork 123
123
iex&gt; DefaultTest.dowork
hello
:ok
</code></pre>
<p>If a function with default values has multiple clauses, it is
recommended to create a separate clause without an actual body, just for
declaring defaults:</p>
<pre><code>defmodule Concat do
  def join(a, b // nil, sep // &quot; &quot;)

  def join(a, b, _sep) when nil?(b) do
    a
  end

  def join(a, b, sep) do
    a &lt;&gt; sep &lt;&gt; b
  end
end

IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;)      #=&gt; Hello world
IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;, &quot;_&quot;) #=&gt; Hello_world
IO.puts Concat.join(&quot;Hello&quot;)               #=&gt; Hello
</code></pre>
<p>When using default values, one must be careful to avoid overlapping
function definitions. Consider the following example:</p>
<pre><code>defmodule Concat do
  def join(a, b) do
    IO.puts &quot;***First join&quot;
    a &lt;&gt; b
  end

  def join(a, b, sep // &quot; &quot;) do
    IO.puts &quot;***Second join&quot;
    a &lt;&gt; sep &lt;&gt; b
  end
end
</code></pre>
<p>If we save the code above in a file named &ldquo;concat.ex&rdquo; and compile it,
Elixir will emit the following warning:</p>
<pre><code>test_funs.ex:7: this clause cannot match because a previous clause at line 2 always matches
</code></pre>
<p>The compiler is telling us that invoking the <code>join</code> function with two
arguments will always choose the first definition of <code>join</code> whereas the
second one will only be invoked when three arguments are passed:</p>
<pre><code>$ iex test_funs.ex

iex&gt; Concat.join &quot;Hello&quot;, &quot;world&quot;
***First join
&quot;Helloworld&quot;

iex&gt; Concat.join &quot;Hello&quot;, &quot;world&quot;, &quot;_&quot;
***Second join
&quot;Hello_world&quot;
</code></pre>
<h4 id="recursion">Recursion</h4>
<p>Due to immutability, loops in Elixir (and in functional programming
languages) are written differently from conventional imperative
languages. For example, in an imperative language, one would write:</p>
<pre><code>for(i = 0; i &lt; array.length; i++) {
  array[i] = array[i] * 2
}
</code></pre>
<p>In the example above, we are mutating the array which is not possible in
Elixir. Therefore, functional languages rely on recursion: a function is
called recursively until a condition is reached. Consider the example
below that manually sums all the items in the list:</p>
<pre><code>defmodule Math do
  def sum_list([h|t], acc) do
    sum_list(t, h + acc)
  end

  def sum_list([], acc) do
    acc
  end
end

Math.sum_list([1,2,3], 0) #=&gt; 6
</code></pre>
<p>In the example above, we invoke <code>sum_list</code> giving a list <code>[1,2,3]</code> and
the initial value <code>0</code> as arguments. When a function has many clauses, we
will try each clause until we find one that matches according to the
pattern matching rules. In this case, the list <code>[1,2,3]</code> matches against
<code>[h|t]</code> which assigns <code>h = 1</code> and <code>t = [2,3]</code> while <code>acc</code> is set to 0.</p>
<p>Then, we add the head of the list to the accumulator <code>h + acc</code> and call
<code>sum_list</code> again, recursively, passing the tail of the list as argument.
The tail will once again match <code>[h|t]</code> until the list is empty, as seen
below:</p>
<pre><code>sum_list [1,2,3], 0
sum_list [2,3], 1
sum_list [3], 3
sum_list [], 6
</code></pre>
<p>When the list is empty, it will match the final clause which returns the
final result of <code>6</code>. In imperative languages, such implementation would
usually fail for large lists because the stack (in which our execution
path is kept) would grow until it reaches a limit. Elixir, however, does
last call optimization in which the stack does not grow when a function
exits by calling another function.</p>
<p>Recursion and last call optimization are an important part of Elixir and
are commonly used to create loops, especially in cases where a process
needs to wait and respond to messages (using the <code>receive</code> macro we saw
in the previous chapter). However, recursion as above is rarely used to
manipulate lists, since <a href="/docs/stable/Enum.html">the <code>Enum</code> module</a>
already abstracts such use cases. For instance, the example above could
be simply written as:</p>
<pre><code>Enum.reduce([1,2,3], 0, fn(x, acc) -&gt; x + acc end)
</code></pre>
<h3 id="directives">Directives</h3>
<p>In order to facilitate software reuse, Elixir supports three directives.
As we are going to see below, they are called directives because they
have <em>lexical scope</em>.</p>
<h4 id="alias">alias</h4>
<p><code>alias</code> allows you to setup aliases for any given module name. Imagine
our <code>Math</code> module has a special list for doing math specific operations:</p>
<pre><code>defmodule Math do
  alias Math.List, as: List
end
</code></pre>
<p>From now on, any reference to <code>List</code> will automatically expand to
<code>Math.List</code>. In case one wants to access the original <code>List</code>, it can be
done by accessing the module via <code>Elixir</code>:</p>
<pre><code>List.values             #=&gt; uses Math.List.values
Elixir.List.values      #=&gt; uses List.values
Elixir.Math.List.values #=&gt; uses Math.List.values
</code></pre>
<blockquote>
<p>Note: All modules defined in Elixir are defined inside a main Elixir
namespace. However, for convenience, you can omit the Elixir main
namespace.</p>
</blockquote>
<p>Calling <code>alias</code> without an <code>as</code> option sets the alias automatically to
the last part of the module name, for example:</p>
<pre><code>alias Math.List
</code></pre>
<p>Is the same as:</p>
<pre><code>alias Math.List, as: List
</code></pre>
<p>Notice that <code>alias</code> is <em>lexically scoped</em>, which allows you to set
aliases inside specific functions:</p>
<pre><code>defmodule Math do
  def add(a, b) do
    alias Math.List
    # ...
  end

  def minus(a, b) do
    # ...
  end
end
</code></pre>
<p>In the example above, since we are invoking <code>alias</code> inside the function
<code>add</code>, the alias will just be valid inside the function <code>add</code>. <code>minus</code>
won&rsquo;t be affected at all.</p>
<h4 id="require">require</h4>
<p>In general, a module does not need to be required before usage, except
if we want to use the macros available in that module. For instance,
suppose we created our own <code>my_if</code> implementation in a module named
<code>MyMacros</code>. If we want to invoke it, we need to first explicitly require
<code>MyMacros</code>:</p>
<pre><code>defmodule Math do
  require MyMacros
  MyMacros.my_if do_something, it_works
end
</code></pre>
<p>An attempt to call a macro that was not loaded will raise an error. Note
that like the <code>alias</code> directive, <code>require</code> is also lexically scoped. We
will talk more about macros in chapter 5.</p>
<h4 id="import">import</h4>
<p>We use <code>import</code> whenever we want to easily access functions or macros
from other modules without using the qualified name. For instance, if we
want to use the <code>duplicate</code> function from <code>List</code> several times in a
module and we don&rsquo;t want to always type <code>List.duplicate</code>, we can simply
import it:</p>
<pre><code>defmodule Math do
  import List, only: [duplicate: 2]

  def some_function do
    # call duplicate
  end
end
</code></pre>
<p>In this case, we are importing only the function <code>duplicate</code> (with arity
2) from <code>List</code>. Although <code>only:</code> is optional, its usage is recommended.
<code>except</code> could also be given as an option.</p>
<p><code>import</code> also supports selectors, to filter what you want to import. We
have four selectors:</p>
<ul>
<li>
<p><code>:default</code> - imports all functions and macros, except the ones
starting by underscore;</p>
</li>
<li>
<p><code>:all</code> - imports all functions and macros;</p>
</li>
<li>
<p><code>:functions</code> - imports all functions;</p>
</li>
<li>
<p><code>:macros</code> - imports all macros;</p>
</li>
</ul>
<p>For example, to import all macros, one could write:</p>
<pre><code>import :macros, MyMacros
</code></pre>
<p>Note that <code>import</code> is also <em>lexically scoped</em>, this means we can import
specific macros inside specific functions:</p>
<pre><code>defmodule Math do
  def some_function do
    import List, only: [duplicate: 2]
    # call duplicate
  end
end
</code></pre>
<p>In the example above, the imported <code>List.duplicate</code> is only visible
within that specific function. <code>duplicate</code> won&rsquo;t be available in any
other function in that module (or any other module for that matter).</p>
<p>Note that importing a module automatically requires it. Furthermore,
<code>import</code> also accepts the <code>as:</code> option which is automatically passed to
<code>alias</code> in order to create an alias.</p>
<h3 id="module-attributes">Module attributes</h3>
<p>Elixir brings the concept of module attributes from Erlang. For example:</p>
<pre><code>defmodule MyServer do
  @vsn 2
end
</code></pre>
<p>In the example above, we are explicitly setting the version attribute
for that module. <code>@vsn</code> is used by the code reloading mechanism in the
Erlang VM to check if a module has been updated or not. If no version is
specified, the version is set to the MD5 checksum of the module
functions.</p>
<p>Elixir has a handful of reserved attributes. Here are just a few of
them, the most commonly used ones. Take a look at the docs for
<a href="http://elixir-lang.org/docs/stable/Module.html">Module</a> for a complete
list of supported attributes.</p>
<ul>
<li>
<p><code>@moduledoc</code> - provides documentation for the current module;</p>
</li>
<li>
<p><code>@doc</code> - provides documentation for the function or macro that
follows the attribute;</p>
</li>
<li>
<p><code>@behaviour</code> - (notice the British spelling) used for specifying an
OTP or user-defined behaviour;</p>
</li>
<li>
<p><code>@before_compile</code> - provides a hook that will be invoked before the
module is compiled. This makes it possible to inject functions
inside the module exactly before compilation;</p>
</li>
</ul>
<p>The following attributes are part of
<a href="http://www.erlang.org/doc/reference_manual/typespec.html">typespecs</a>
and are also supported by Elixir:</p>
<ul>
<li>
<p><code>@spec</code> - provides a specification for a function;</p>
</li>
<li>
<p><code>@callback</code> - provides a specification for the behavior callback;</p>
</li>
<li>
<p><code>@type</code> - defines a type to be used in <code>@spec</code>;</p>
</li>
<li>
<p><code>@typep</code> - defines a private type to be used in <code>@spec</code>;</p>
</li>
<li>
<p><code>@opaque</code> - defines an opaque type to be used in <code>@spec</code>;</p>
</li>
</ul>
<p>In addition to the built-in attributes outlined above, custom attributes
may also be added:</p>
<pre><code>defmodule MyServer do
  @my_data 13
  IO.inspect @my_data #=&gt; 13
end
</code></pre>
<p>Unlike Erlang, user defined attributes are not stored in the module by
default since it is common in Elixir to use such attributes to store
temporary data. A developer can configure an attribute to behave closer
to Erlang by calling
<a href="/docs/stable/Module.html#register_attribute/3"><code>Module.register_attribute/3</code></a>.</p>
<p>Finally, notice that attributes can also be read inside functions:</p>
<pre><code>defmodule MyServer do
  @my_data 11
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=&gt; 11
MyServer.second_data #=&gt; 13
</code></pre>
<p>Notice that reading an attribute inside a function takes a snapshot of
its current value. In other words, the value is read at compilation time
and not at runtime. Check <a href="/docs/stable/Module.html">the documentation for the module <code>Module</code>
documentation</a> for other functions to
manipulate module attributes.</p>
<h3 id="nesting">Nesting</h3>
<p>Modules in Elixir can be nested too:</p>
<pre><code>defmodule Foo do
  defmodule Bar do
  end
end
</code></pre>
<p>The example above will define two modules <code>Foo</code> and <code>Foo.Bar</code>. The
second can be accessed as <code>Bar</code> inside <code>Foo</code> as long as they are in the
same scope. If later the developer decides to move <code>Bar</code> to another
file, it will need to be referenced by its full name (<code>Foo.Bar</code>) or an
alias needs to be set using the <code>alias</code> directive discussed above.</p>
<h3 id="aliases">Aliases</h3>
<p>In Erlang (and consequently in the Erlang VM), modules and functions are
represented by atoms. For instance, this is valid Erlang code:</p>
<pre><code>Mod = lists,
Mod:flatten([1,[2],3]).
</code></pre>
<p>In the example above, we store the atom <code>lists</code> in the variable <code>Mod</code>
and then invoke the function <code>flatten</code> in it. In Elixir, the same idiom
is allowed:</p>
<pre><code>iex&gt; mod = :lists
:lists
iex&gt; mod.flatten([1,[2],3])
[1,2,3]
</code></pre>
<p>In other words, we are simply calling the function <code>flatten</code> on the atom
<code>:lists</code>. This mechanism is exactly what empowers Elixir aliases. An
alias in Elixir is a capitalized identifier (like <code>List</code>, <code>Keyword</code>,
etc) which is converted to an atom representing a module during
compilation. For instance, the <code>List</code> alias translates by default to the
atom <code>Elixir.List</code>:</p>
<pre><code>iex&gt; is_atom(List)
true
iex&gt; to_binary(List)
&quot;Elixir.List&quot;
</code></pre>
<h2 id="records-protocols--exceptions">Records, Protocols &amp; Exceptions</h2>
<p>Elixir provides both records and protocols. This chapter will outline
the main features of both and provide some examples. More specifically,
we will learn how to use <code>defrecord</code>, <code>defprotocol</code> and <code>defimpl</code>. At
the end, we will briefly talk about exceptions in Elixir.</p>
<h3 id="records-1">Records</h3>
<p>Records are simple structures that hold values. For example, we can
define a <code>FileInfo</code> record that is supposed to store information about
files as follows:</p>
<pre><code>defrecord FileInfo, atime: nil, accesses: 0
</code></pre>
<p>The line above will define a module named <code>FileInfo</code> which contains a
function named <code>new</code> that returns a new record and other functions to
read and set the values in the record:</p>
<pre><code>file_info = FileInfo.new(atime: { 2010, 4, 17 })
file_info.atime                   #=&gt; Returns the value of atime

file_info = file_info.atime({ 2012, 10, 13 }) #=&gt; Updates the value of atime
file_info
</code></pre>
<p>Notice that when we change the <code>atime</code> field of the record, we re-store
the record in the <code>file_info</code> variable. This is because as almost
everything else in Elixir, records are immutable. So changing the
<code>atime</code> field does not update the record in place. Instead, it returns a
new record with the new value set.</p>
<p>A record is simply a tuple where the first element is the record module
name. We can get the record raw representation as follows:</p>
<pre><code>inspect FileInfo.new, raw: true
#=&gt; &quot;{ FileInfo, nil, 0 }&quot;
</code></pre>
<p>Besides defining readers and writers for each attribute, Elixir records
also define an <code>update_#{attribute}</code> function to update values. Such
functions expect a function as argument that receives the current value
and must return the new one. For example, every time the file is
accessed, the accesses counter can be incremented with:</p>
<pre><code>file_info = FileInfo.new(accesses: 10)
file_info = file_info.update_accesses(fn(x) -&gt; x + 1 end)
file_info.accesses #=&gt; 11
</code></pre>
<h4 id="pattern-matching">Pattern matching</h4>
<p>Elixir also allows one to pattern match against records. For example,
imagine we want to check if a file was accessed or not based on the
<code>FileInfo</code> record above, we could implement it as follows:</p>
<pre><code>defmodule FileAccess do
  def was_accessed?(FileInfo[accesses: 0]), do: true
  def was_accessed?(FileInfo[]),            do: false
end
</code></pre>
<p>The first clause will only match if a <code>FileInfo</code> record is given and the
<code>accesses</code> field is equal to zero. The second clause will match any
<code>FileInfo</code> record and nothing more. We can also like the value of
<code>accesses</code> to a variable as follows:</p>
<pre><code>def was_accessed?(FileInfo[accesses: accesses]), do: accesses == 0
</code></pre>
<p>The pattern matching syntax can also be used to create new records:</p>
<pre><code>file_info = FileInfo[accesses: 0]
</code></pre>
<p>Whenever using the bracket syntax above, Elixir expands the record to a
tuple at compilation time. That said, the clause above:</p>
<pre><code>def was_accessed?(FileInfo[accesses: 0]), do: true
</code></pre>
<p>Is effectively the same as:</p>
<pre><code>def was_accessed?({ FileInfo, _, 0 }), do: true
</code></pre>
<p>Using the bracket syntax is a powerful mechanism not only due to pattern
matching but also regarding performance, since it provides faster times
compared to <code>FileInfo.new</code> and <code>file_info.accesses</code>. The downside is
that we hardcode the record name. For this reason, Elixir allows you to
mix and match both styles as you may find fit.</p>
<p>For more information on records, <a href="http://elixir-lang.org/docs/master/Kernel.html#defrecord/4">check out the documentation for the
<code>defrecord</code>
macro</a></p>
<h3 id="protocols">Protocols</h3>
<p>Protocols is a mechanism to achieve polymorphism in Elixir. Dispatching
a protocol is available to any data type as long as it implements the
protocol. Let&rsquo;s consider a practical example.</p>
<p>In Elixir, only <code>false</code> and <code>nil</code> are considered falsy values.
Everything else evaluates to true. Depending on the application, it may
be important to specify a <code>blank?</code> protocol that returns a boolean for
other data types that should be considered blank. For instance, an empty
list or an empty binary could be considered blanks.</p>
<p>We could define this protocol as follows:</p>
<pre><code>defprotocol Blank do
  @doc &quot;Returns true if data is considered blank/empty&quot;
  def blank?(data)
end
</code></pre>
<p>The protocol expects a function called <code>blank?</code> that receives one
argument to be implemented. We can implement this protocol for some
Elixir data types in the following way:</p>
<pre><code># Numbers are never blank
defimpl Blank, for: Number do
  def blank?(number), do: false
end

# Just empty list is blank
defimpl Blank, for: List do
  def blank?([]), do: true
  def blank?(_),  do: false
end

# Just the atoms false and nil are blank
defimpl Blank, for: Atom do
  def blank?(false), do: true
  def blank?(nil),   do: true
  def blank?(_),     do: false
end
</code></pre>
<p>And we would do so for all native data types. The types available are:</p>
<ul>
<li>
<p>Record</p>
</li>
<li>
<p>Tuple</p>
</li>
<li>
<p>Atom</p>
</li>
<li>
<p>List</p>
</li>
<li>
<p>BitString</p>
</li>
<li>
<p>Number</p>
</li>
<li>
<p>Function</p>
</li>
<li>
<p>PID</p>
</li>
<li>
<p>Port</p>
</li>
<li>
<p>Reference</p>
</li>
<li>
<p>Any</p>
</li>
</ul>
<p>Now, with the protocol defined and implementations in hand, we can
invoke it:</p>
<pre><code>Blank.blank?(0)       #=&gt; false
Blank.blank?([])      #=&gt; true
Blank.blank?([1,2,3]) #=&gt; false
</code></pre>
<p>Notice however that passing a data type that does not implement the
protocol raises an error:</p>
<pre><code>Blank.blank?(&quot;hello&quot;)
** (UndefinedFunctionError) undefined function: Blank.BitString.blank?/1
</code></pre>
<p>Implementing the protocol for all 9 types above can be cumbersome. So
Elixir gives us some tools to select which protocols we want to
implement explicitly.</p>
<h4 id="selecting-implementations">Selecting implementations</h4>
<p>Implementing the protocol for all types can be a bit of work and in some
cases, even unnecessary. Going back to our <code>Blank</code> protocol, the types
Number, Function, PID, Port and Reference are never going to be blank.
To make things easier, Elixir allows us to declare the fact that we are
going to implement the protocol just for some types, as follows:</p>
<pre><code>defprotocol Blank do
  @only [Atom, Record, Tuple, List, BitString, Any]
  def blank?(data)
end
</code></pre>
<p>Since we also specified <code>Any</code> as a data type, if the data type is not
any of <code>Atom</code>, <code>Record</code>, <code>Tuple</code>, <code>List</code> or <code>BitString</code>, it will
automatically fall back to <code>Any</code>:</p>
<pre><code>defimpl Blank, for: Any do
  def blank?(_), do: false
end
</code></pre>
<p>Now all data types that we have not specified will be automatically
considered non-blank.</p>
<h4 id="using-protocols-with-records">Using protocols with records</h4>
<p>The power of Elixir extensibility comes when protocols and records are
mixed.</p>
<p>For instance, Elixir provides a <code>HashDict</code> implementation that is an
efficient data structure to store many keys. Let&rsquo;s take a look at how it
works:</p>
<pre><code>dict = HashDict.new
dict = HashDict.put(dict, :hello, &quot;world&quot;)
HashDict.get(dict, :hello) #=&gt; &quot;world&quot;
</code></pre>
<p>If we inspect our <code>HashDict</code>, we can see it is a simple tuple:</p>
<pre><code>inspect(dict, raw: true)
#=&gt; { HashDict, 1, [{:hello,&quot;world&quot;}] }
</code></pre>
<p>Since <code>HashDict</code> is a data structure that contains values, it would be
convenient to implement the <code>Blank</code> protocol for it too:</p>
<pre><code>defimpl Blank, for: HashDict do
  def blank?(dict), do: HashDict.size(dict) == 0
end
</code></pre>
<p>And now we can test it:</p>
<pre><code>dict = HashDict.new(hello: &quot;world&quot;)
Blank.blank?(dict)         #=&gt; false
Blank.blank?(HashDict.new) #=&gt; true
</code></pre>
<p>Excellent! The best of all is that we implemented the <code>Blank</code> protocol
for an existing data structure (<code>HashDict</code>) without a need to wrap it or
recompile it, which allows developers to easily extend previously
defined protocols. Note this only worked because, when we defined the
protocol, we have added <code>Record</code> to the list of types supported by the
protocol:</p>
<pre><code>@only [Atom, Record, Tuple, List, BitString, Any]
</code></pre>
<p>Keep in mind that <code>Record</code> needs to come before <code>Tuple</code>, since all
records are tuples (but not all tuples are records). For this reason, in
case a record does not implement a given protocol, Elixir will fall back
to the tuple implementation of that protocol if one exists. So one can
add a default protocol implementation for all records by simply defining
a default implementation for tuples.</p>
<h4 id="built-in-protocols">Built-in protocols</h4>
<p>Elixir ships with some built-in protocols, let&rsquo;s take a look at a couple
of those:</p>
<ul>
<li>
<p><code>Access</code> - specifies how to access an element. This is the protocol
that empowers bracket access in Elixir, for example:</p>
<pre><code>  iex&gt; x = [a: 1, b: 2]
  [{:a, 1}, {:b, 2}]
  iex&gt; x[:a]
  1
  iex&gt; x[:b]
  2
</code></pre>
</li>
<li>
<p><code>Enumerable</code> - any data structured that can be enumerated must
implement this protocol. This protocol is consumed by the <code>Enum</code>
module which provides functions like <code>map</code>, <code>reduce</code> and others:</p>
<pre><code>  iex&gt; Enum.map [1,2,3], fn(x) -&gt; x * 2 end
  [2,4,6]
  iex&gt; Enum.reduce 1..3, 0, fn(x, acc) -&gt; x + acc end
  6
</code></pre>
</li>
<li>
<p><code>Binary.Inspect</code> - this protocol is used to transform any data
structure into a readable textual representation. That&rsquo;s what tools
like IEx uses to print results:</p>
<pre><code>  iex&gt; { 1, 2, 3 }
  {1,2,3}
  iex&gt; HashDict.new
  #HashDict&lt;[]&gt;
</code></pre>
<p>Keep in mind that whenever the inspected value starts with <code>#</code>, it
is representing a data structure in non-valid Elixir syntax. For
those, the true representation can be retrieved by calling <code>inspect</code>
directly and passing <code>raw</code> as an option:</p>
<pre><code>  iex&gt; inspect HashDict.new, raw: true
  &quot;{HashDict,0,[]}&quot;
</code></pre>
</li>
<li>
<p><code>Binary.Chars</code> - specifies how to convert a data structure with
characters to binary. It&rsquo;s exposed via the <code>to_binary</code> function:</p>
<pre><code>  iex&gt; to_binary :hello
  &quot;hello&quot;
</code></pre>
<p>Notice that string interpolation in Elixir calls the <code>to_binary</code>
function:</p>
<pre><code>  iex&gt; &quot;age: #{25}&quot;
  &quot;age: 25&quot;
</code></pre>
<p>The example above only works because numbers implement the
<code>Binary.Chars</code> protocol. Passing a tuple, for example, will lead to
an error:</p>
<pre><code>  iex&gt; tuple = { 1, 2, 3 }
  {1,2,3}
  iex&gt; &quot;tuple: #{tuple}&quot;
  ** (Protocol.UndefinedError) protocol Binary.Chars not implemented for {1,2,3}
</code></pre>
<p>When there is a need to &ldquo;print&rdquo; a more complex data structure, one
can simply use the <code>inspect</code> function:</p>
<pre><code>  iex&gt; &quot;tuple: #{inspect tuple}&quot;
  &quot;tuple: {1,2,3}&quot;
</code></pre>
</li>
</ul>
<p>Elixir defines other protocols which can be verified in Elixir&rsquo;s
documentation. Frameworks and libraries that you use may define a couple
of specific protocols as well. Use them wisely to write code that is
easy to maintain and extend.</p>
<h3 id="exceptions-1">Exceptions</h3>
<p>The <code>try</code> mechanism in Elixir is also used to handle exceptions. In many
languages, exceptions would have its own chapter in a getting started
guide but here they play a much lesser role.</p>
<p>An exception can be rescued inside a <code>try</code> block with the <code>rescue</code>
keyword:</p>
<pre><code># rescue only runtime error
try do
  raise &quot;some error&quot;
rescue
  RuntimeError -&gt; &quot;rescued&quot;
end

# rescue runtime and argument errors
try do
  raise &quot;some error&quot;
rescue
  [RuntimeError, ArgumentError] -&gt; &quot;rescued&quot;
end

# rescue and assign to x
try do
  raise &quot;some error&quot;
rescue
  x in [RuntimeError] -&gt;
    # all exceptions have a message
    x.message
end
</code></pre>
<p>Notice that <code>rescue</code> works with exception names and it doesn&rsquo;t allow
guards nor pattern matching. This limitation is on purpose: developers
should not use exception values to drive their software. In fact,
<em>exceptions in Elixir should not be used for control-flow but only under
exceptional circumstances</em>.</p>
<p>For example, if you write a software that does log partitioning and log
rotation over the network, you may face network issues or an eventual
instability when accessing the file system. These scenarios are not
exceptional in this particular software and must be handled accordingly.
Therefore, a developer can read some file using <code>File.read</code>:</p>
<pre><code>case File.read(file) do
  { :ok, contents }  -&gt;
    # we could access the file
    # proceed as expected
  { :error, reason } -&gt;
    # Oops, something went wrong
    # We need to handle the error accordingly
end
</code></pre>
<p>Notice <code>File.read</code> does not raise an exception in case something goes
wrong, it returns a tuple containing <code>{ :ok, contents }</code> in case of
success and <code>{ :error, reason }</code> in case of failures. This allows us to
use Elixir&rsquo;s pattern matching constructs to control how our application
should behave.</p>
<p>On the other hand, a CLI interface that needs to access or manipulate a
file given by the user may necessarily expect a file to be there. If the
given file does not exist, there is nothing you can do but fail. Then
you may use <code>File.read!</code> which raises an exception:</p>
<pre><code>contents = File.read!(file)
</code></pre>
<p>This pattern is common throughout Elixir standard library. Many
libraries have both function definitions followed by their &ldquo;bang!&rdquo;
variation, with exclamation mark. This showcases well Elixir&rsquo;s
philosophy of not using exceptions for control-flow. If you feel like
you need to rescue an exception in order to change how your code works,
you should probably return an atom or tuple instead, allowing your
developers to rely on pattern matching.</p>
<p>Finally, exceptions are simply records and they can be defined with
<code>defexception</code> which has a similar API to <code>defrecord</code>. But remember, in
Elixir you will use those sparingly. Next, let&rsquo;s take a look at how
Elixir tackles productivity by building some macros using <code>defmacro</code> and
<code>defmacrop</code>!</p>
<blockquote>
<p>Note: In order to ease integration with Erlang APIs, Elixir also
supports &ldquo;catching errors&rdquo; coming from Erlang with <code>try/catch</code>, as it
works in Erlang:</p>
<pre><code>try do
  :erlang.error(:oops)
catch
  :error, :oops -&gt;
    &quot;Got Erlang error&quot;
end
</code></pre>
<p>The first atom can be one of <code>:error</code>, <code>:throw</code> or <code>:exit</code>. Keep in
mind catching errors is as discouraged as rescuing exceptions in
Elixir.</p>
</blockquote>
<h2 id="macros">Macros</h2>
<p>An Elixir program can be represented by its own data structures. This
chapter will describe what those structures look like and how to
manipulate them to create your own macros.</p>
<h3 id="building-blocks-of-an-elixir-program">Building blocks of an Elixir program</h3>
<p>The building block of Elixir is a tuple with three elements. The
function call <code>sum(1,2,3)</code> is represented in Elixir as:</p>
<pre><code>{ :sum, [], [1, 2, 3] }
</code></pre>
<p>You can get the representation of any expression by using the <code>quote</code>
macro:</p>
<pre><code>iex&gt; quote do: sum(1, 2, 3)
{ :sum, [], [1, 2, 3] }
</code></pre>
<p>Operators are also represented as such tuples:</p>
<pre><code>iex&gt; quote do: 1 + 2
{ :+, [], [1, 2] }
</code></pre>
<p>Even a tuple is represented as a call to <code>{}</code>:</p>
<pre><code>iex&gt; quote do: { 1, 2, 3 }
{ :{}, [], [1, 2, 3] }
</code></pre>
<p>Variables are also represented using tuples, except the last element is
an atom, instead of a list:</p>
<pre><code>iex&gt; quote do: x
{ :x, [], Elixir }
</code></pre>
<p>When quoting more complex expressions, we can see the representation is
composed of such tuples, which are nested on each other resembling a
tree where each tuple is a node:</p>
<pre><code>iex&gt; quote do: sum(1, 2 + 3, 4)
{ :sum, [], [1, { :+, [], [2, 3] }, 4] }
</code></pre>
<p>In general, each node (tuple) above follows the following format:</p>
<pre><code>{ tuple | atom, list, list | atom }
</code></pre>
<ul>
<li>
<p>The first element of the tuple is an atom or another tuple in the
same representation;</p>
</li>
<li>
<p>The second element of the tuple is an list of metadata, it may hold
information like the node line number;</p>
</li>
<li>
<p>The third element of the tuple is either a list of arguments for the
function call or an atom. When an atom, it means the tuple
represents a variable.</p>
</li>
</ul>
<p>Besides the node defined above, there are also five Elixir literals that
when quoted return themselves (and not a tuple). They are:</p>
<pre><code>:sum         #=&gt; Atoms
1.0          #=&gt; Numbers
[1,2]        #=&gt; Lists
&quot;binaries&quot;   #=&gt; Strings
{key, value} #=&gt; Tuples with two elements
</code></pre>
<p>With those basic structures in mind, we are ready to define our own
macro.</p>
<h3 id="defining-our-own-macro">Defining our own macro</h3>
<p>A macro can be defined using <code>defmacro</code>. For instance, in just a few
lines of code we can define a macro called <code>unless</code> which does the
opposite of <code>if</code>:</p>
<pre><code>defmodule MyMacro do
  defmacro unless(clause, options) do
    quote do: if(!unquote(clause), unquote(options))
  end
end
</code></pre>
<p>Similarly to <code>if</code>, <code>unless</code> expects two arguments: a <code>clause</code> and
<code>options</code>:</p>
<pre><code>require MyMacro
MyMacro.unless var, do: IO.puts &quot;false&quot;
</code></pre>
<p>However, since <code>unless</code> is a macro, its arguments are not evaluated when
it&rsquo;s invoked but are instead passed literally. For example, if one
calls:</p>
<pre><code>unless 2 + 2 == 5, do: call_function()
</code></pre>
<p>Our <code>unless</code> macro will receive the following:</p>
<pre><code>unless({:==, [], [{:+, [], [2, 2]}, 5]}, { :call_function, [], [] })
</code></pre>
<p>Then our <code>unless</code> macro will call <code>quote</code> to return a tree
representation of the <code>if</code> clause. This means we are transforming our
<code>unless</code> into an <code>if</code>!</p>
<p>There is a common mistake when quoting expressions which is that
developers usually forget to <code>unquote</code> the proper expression. In order
to understand what <code>unquote</code> does, let&rsquo;s simply remove it:</p>
<pre><code>defmacro unless(clause, options) do
  quote do: if(!clause, options)
end
</code></pre>
<p>When called as <code>unless 2 + 2 == 5, do: call_function()</code>, our <code>unless</code>
would then literally return:</p>
<pre><code>if(!clause, options)
</code></pre>
<p>Which would fail because the clause and options variables are not
defined in the current scope. If we add <code>unquote</code> back:</p>
<pre><code>defmacro unless(clause, options) do
  quote do: if(!unquote(clause), unquote(options))
end
</code></pre>
<p><code>unless</code> will then return:</p>
<pre><code>if(!(2 + 2 == 5), do: call_function())
</code></pre>
<p>In other words, <code>unquote</code> is a mechanism to inject expressions into the
tree being quoted and it is an essential tool for meta-programming.
Elixir also provides <code>unquote_splicing</code> allowing us to inject many
expressions at once.</p>
<p>We can define any macro we want, including ones that override the
built-in macros provided by Elixir. For instance, you can redefine
<code>case</code>, <code>receive</code>, <code>+</code>, etc. The only exceptions are Elixir special
forms that cannot be overridden, <a href="/docs/stable/Kernel.SpecialForms.html">the full list of special forms is
available in
<code>Kernel.SpecialForms</code></a>.</p>
<h3 id="macros-hygiene">Macros hygiene</h3>
<p>Elixir macros have late resolution. This guarantees that a variable
defined inside a quote won&rsquo;t conflict with a variable defined in the
context where that macro is expanded. For example:</p>
<pre><code>defmodule Hygiene do
  defmacro no_interference do
    quote do: a = 1
  end
end

defmodule HygieneTest do
  def go do
    require Hygiene
    a = 13
    Hygiene.no_interference
    a
  end
end

HygieneTest.go
# =&gt; 13
</code></pre>
<p>In the example above, even if the macro injects <code>a = 1</code>, it does not
affect the variable <code>a</code> defined by the <code>go</code> function. In case the macro
wants to explicitly affect the context, it can use <code>var!</code>:</p>
<pre><code>defmodule Hygiene do
  defmacro interference do
    quote do: var!(a) = 1
  end
end

defmodule HygieneTest do
  def go do
    require Hygiene
    a = 13
    Hygiene.interference
    a
  end
end

HygieneTest.go
# =&gt; 1
</code></pre>
<p>Variables hygiene only works because Elixir annotates variables with
their context. For example, a variable <code>x</code> defined at the line 3 of a
module, would be represented as:</p>
<pre><code>{ :x, [line: 3], nil }
</code></pre>
<p>However, a quoted variable is represented as:</p>
<pre><code>defmodule Sample do
  def quoted do
    quote do: x
  end
end

Sample.quoted #=&gt; { :x, [line: 3], Sample }
</code></pre>
<p>Notice that the third element in the quoted variable is the atom
<code>Sample</code>, instead of <code>nil</code>, which marks the variable as coming from the
<code>Sample</code> module. Therefore, Elixir considers those two variables come
from different contexts and handle them accordingly.</p>
<p>Elixir provides similar mechanisms for imports and aliases too. This
guarantees macros will behave as specified by its source module rather
than conflicting with the target module.</p>
<h3 id="private-macros">Private macros</h3>
<p>Elixir also supports private macros via <code>defmacrop</code>. As private
functions, these macros are only available inside the module that
defines them, and only at compilation time. A common use case for
private macros is to define guards that are frequently used in the same
module:</p>
<pre><code>defmodule MyMacros do
  defmacrop is_even?(x) do
    quote do
      rem(unquote(x), 2) == 0
    end
  end

  def add_even(a, b) when is_even?(a) and is_even?(b) do
    a + b
  end
end
</code></pre>
<p>It is important that the macro is defined before its usage. Failing to
define a macro before its invocation will raise an error at runtime,
since the macro won&rsquo;t be expanded and will be translated to a function
call:</p>
<pre><code>defmodule MyMacros do
  def four, do: two + two
  defmacrop two, do: 2
end

MyMacros.four #=&gt; ** (UndefinedFunctionError) undefined function: two/0
</code></pre>
<h3 id="code-execution">Code execution</h3>
<p>To finish our discussion about macros, we are going to briefly discuss
how code execution works in Elixir. Code execution in Elixir is done in
two steps:</p>
<p>â€‹1) All the macros in the code are expanded recursively;</p>
<p>â€‹2) The expanded code is compiled to Erlang bytecode and executed</p>
<p>This behavior is important to understand because it affects how we think
about our code structure. Consider the following code:</p>
<pre><code>defmodule Sample do
  case System.get_env(&quot;FULL&quot;) do
    &quot;true&quot; -&gt;
      def full?(), do: true
    _ -&gt;
      def full?(), do: false
  end
end
</code></pre>
<p>The code above will define a function <code>full?</code> which will return true or
false depending on the value of the environment variable <code>FULL</code> at
<em>compilation time</em>. In order to execute this code, Elixir will first
expand all macros. Considering that <code>defmodule</code> and <code>def</code> are macros,
the code will expand to something like:</p>
<pre><code>:elixir_module.store Sample, fn -&gt;
  case System.get_env(&quot;FULL&quot;) do
    &quot;true&quot; -&gt;
      :elixir_def.store(Foo, :def, :full?, [], true)
    _ -&gt;
      :elixir_def.store(Foo, :def, :full?, [], false)
end
</code></pre>
<p>This code will then be executed, define a module <code>Foo</code> and store the
appropriate function based on the value of the environment variable
<code>FULL</code>. We achieve this by using the modules <code>:elixir_module</code> and
<code>:elixir_def</code>, which are Elixir internal modules written in Erlang.</p>
<p>There are two lessons to take away from this example:</p>
<p>â€‹1) a macro is always expanded, regardless if it is inside a <code>case</code>
branch that won&rsquo;t actually match when executed;</p>
<p>â€‹2) we cannot invoke a function or macro just after it is defined in a
module. For example, consider:</p>
<pre><code>defmodule Sample do
  def full?, do: true
  IO.puts full?
end
</code></pre>
<p>The example above will fail because it translates to:</p>
<pre><code>:elixir_module.store Sample, fn -&gt;
  :elixir_def.store(Foo, :def, :full?, [], true)
  IO.puts full?
end
</code></pre>
<p>At the moment the module is being defined, there isn&rsquo;t <em>yet</em> a function
named <code>full?</code> defined in the module, so <code>IO.puts full?</code> will cause the
compilation to fail.</p>
<h3 id="dont-write-macros">Don&rsquo;t write macros</h3>
<p>Although macros are a powerful construct, the first rule of the macro
club is <em>don&rsquo;t write macros</em>. Macros are harder to write than ordinary
Elixir functions, and it&rsquo;s considered to be bad style to use them when
they&rsquo;re not necessary. Elixir already provides elegant mechanisms to
write your every day code and macros should be saved as last resort.</p>
<p>With those lessons, we finish our introduction to macros. Next, let&rsquo;s
move to the next chapter which will discuss several topics such as
documentation, partial application and others.</p>
<h2 id="other-topics">Other topics</h2>
<p>This chapter contains different small topics that are part of Elixir&rsquo;s
day to day work. We will learn about writing documentation, list and
binary comprehensions, partial function application and more!</p>
<h3 id="string-sigils">String sigils</h3>
<p>Elixir provides string sigils via the token <code>%</code>:</p>
<pre><code>%b(Binary with escape codes \x26 interpolation)
%B(Binary without escape codes and without #{interpolation})
</code></pre>
<p>Sigils starting with an uppercase letter never escape characters or do
interpolation. Notice the separators are not necessarily parenthesis,
but any non-alphanumeric character:</p>
<pre><code>%b-another binary-
</code></pre>
<p>Internally, <code>%b</code> is translated as a function call to <code>__b__</code>. For
instance, the docs for <code>%b</code> are available <a href="/docs/stable/Kernel.html#__b__/2">in the function <code>__b__/2</code>
defined in <code>Kernel</code> module</a>.</p>
<p>The sigils defined in Elixir by default are:</p>
<ul>
<li>
<p><code>%b</code> and <code>%B</code> - Returns a binary;</p>
</li>
<li>
<p><code>%c</code> and <code>%C</code> - Returns a char list;</p>
</li>
<li>
<p><code>%r</code> and <code>%R</code> - Returns a regular expression;</p>
</li>
</ul>
<h3 id="heredocs">Heredocs</h3>
<p>Elixir supports heredocs as a way to define long strings. Heredocs are
delimited by triple double-quotes for binaries or triple single-quotes
for char lists:</p>
<pre><code>&quot;&quot;&quot;
Binary heredoc
&quot;&quot;&quot;

'''
Charlist heredoc
'''
</code></pre>
<p>The heredoc ending must be in a line on its own, otherwise it is part of
the heredoc:</p>
<pre><code>&quot;&quot;&quot;
Binary heredocs in Elixir use &quot;&quot;&quot;
&quot;&quot;&quot;
</code></pre>
<p>Notice the sigils discussed in the previous section are also available
as heredocs:</p>
<pre><code>%B&quot;&quot;&quot;
A heredoc without escaping or interpolation
&quot;&quot;&quot;
</code></pre>
<h3 id="documentation">Documentation</h3>
<p>Elixir uses module attributes described in chapter 3 to drive its
documentation system. For instance, consider the following example:</p>
<pre><code>defmodule MyModule do
  @moduledoc &quot;It does X&quot;

  @doc &quot;Returns the version&quot;
  def version, do: 1
end
</code></pre>
<p>In the example above, we are adding a module documentation to <code>MyModule</code>
via <code>@moduledoc</code> and using <code>@doc</code> to document each function. When
compiled, we are able to inspect the documentation attributes at runtime
(remember to start iex in the same directory in which you compiled the
module):</p>
<pre><code>$ elixirc my_module.ex
$ iex
iex&gt; MyModule.__info__(:docs)
[{ { :version, 0 }, 5, :def, [], &quot;Returns the version&quot; }]
iex&gt; MyModule.__info__(:moduledoc)
{1,&quot;It does X&quot;}
</code></pre>
<p><code>__info__(:docs)</code> returns a list of tuples where each tuple contains a
function/arity pair, the line the function was defined on, the kind of
the function (<code>def</code> or <code>defmacro</code>, private functions cannot be
documented), the function arguments and its documentation. The comment
will be either a binary or <code>nil</code> (not given) or <code>false</code> (explicit no
doc).</p>
<p>Similarly, <code>__info__(:moduledoc)</code> returns a tuple with the line the
module was defined on and its documentation.</p>
<p>Elixir promotes the use of markdown with heredocs to write readable
documentation:</p>
<pre><code>defmodule Math do
  @moduledoc &quot;&quot;&quot;
  This module provides mathematical functions
  as sin, cos and constants like pi.

  ## Examples

      Math.pi
      #=&gt; 3.1415...

  &quot;&quot;&quot;
end
</code></pre>
<h3 id="iex-helpers">IEx Helpers</h3>
<p>Elixir&rsquo;s interactive console (IEx) ships with many functions to make the
developer&rsquo;s life easier. One of these functions is called <code>h</code>, which
shows documentation directly at the command line:</p>
<pre><code>iex&gt; h()
# IEx.Helpers
...
:ok
</code></pre>
<p>As you can see, invoking <code>h()</code> prints the documentation of
<code>IEx.Helpers</code>. From there, we can navigate to any of the other helpers
by giving its name and arity to get more information:</p>
<pre><code>iex&gt; h(c/2)
* def c(files, path // &quot;.&quot;)
...
:ok
</code></pre>
<p>This functionality can also be used to print the documentation for any
Elixir module in the system:</p>
<pre><code>iex&gt; h(Enum)
...
iex&gt; h(Enum.each/2)
...
</code></pre>
<p>The documentation for built-in functions can also be accessed directly
or indirectly from the <code>Kernel</code> module:</p>
<pre><code>iex&gt; h(is_atom/1)
...
iex&gt; h(Kernel.is_atom/1)
...
</code></pre>
<h3 id="function-retrieval-and-partial-application">Function retrieval and partial application</h3>
<p>Elixir supports a convenient syntax for retrieving functions. Let&rsquo;s
suppose we have a list of binaries and we want to calculate the size of
each of them. We could do it in the following way:</p>
<pre><code>iex&gt; list = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]
[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
iex&gt; Enum.map list, fn(x) -&gt; size(x) end
[3,3,3]
</code></pre>
<p>We could also write this as:</p>
<pre><code>iex&gt; Enum.map list, size(&amp;1)
[3,3,3]
</code></pre>
<p>The example above works as if <code>size(&amp;1)</code> translates directly to
<code>fn(x) -&gt; size(x) end</code>. Since operators are also function calls, they
can also benefit of the same syntax:</p>
<pre><code>iex&gt; Enum.reduce [1,2,3], 1, &amp;1 * &amp;2
6
</code></pre>
<p>In this case, <code>&amp;1 * &amp;2</code> translates to <code>fn(x, y) -&gt; x * y end</code>. The
values <code>&amp;1</code> and <code>&amp;2</code> map to the argument order in the generated
function.</p>
<p>Keep in mind that <code>&amp;N</code> binds only to the closest function call. For
example, the following syntax is invalid:</p>
<pre><code>iex&gt; foo(&amp;1, 1 + &amp;2)
** (SyntaxError) iex:1: partial variable &amp;2 cannot be defined without &amp;1
</code></pre>
<p>This is because we have two functions calls in the example above, <code>foo</code>
and <code>+</code>, and <code>&amp;1</code> binds to <code>foo</code> while <code>&amp;2</code> binds to <code>+</code>. Let&rsquo;s add some
parenthesis to make it explicit:</p>
<pre><code>iex&gt; foo(&amp;1, (1 + &amp;2))
** (SyntaxError) iex:1: partial variable &amp;2 cannot be defined without &amp;1
</code></pre>
<p>In such cases, you need to use the usual function syntax:</p>
<pre><code>iex&gt; fn(x, y) -&gt; foo(x, 1 + y) end
#Function&lt;erl_eval.12.82930912&gt;
</code></pre>
<p>Finally, notice this syntax can also be used to do partial application
in Elixir. For instance, if we want to multiply each item in a list per
two, we could write it as:</p>
<pre><code>iex&gt; Enum.map [1,2,3], &amp;1 * 2
[2,4,6]
</code></pre>
<p>All functions and macros can be retrieved and partially applied, except
<a href="/docs/stable/Kernel.SpecialForms.html">Elixir&rsquo;s special forms</a>.</p>
<h3 id="use">Use</h3>
<p><code>use</code> is a macro that provides a common API for extension. For instance,
in order to use the <code>ExUnit</code> test framework that ships with Elixir, you
simply need to use <code>ExUnit.Case</code> in your module:</p>
<pre><code>defmodule AssertionTest do
  use ExUnit.Case, async: true

  test &quot;always pass&quot; do
    true = true
  end
end
</code></pre>
<p>This allows <code>ExUnit.Case</code> to configure and set up the module for
testing, for example, by making the <code>test</code> macro used above available.</p>
<p>The implementation of the <code>use</code> macro is actually quite trivial. When
you invoke <code>use</code> with a module, it invokes a hook called <code>__using__</code> in
this module. For example, the <code>use</code> call above is simply a translation
to:</p>
<pre><code>defmodule AssertionTest do
  require ExUnit.Case
  ExUnit.Case.__using__(async: true)

  test &quot;always pass&quot; do
    true = true
  end
end
</code></pre>
<p>In general, we recommend APIs to provide a <code>__using__</code> hook in case they
want to expose functionality to developers.</p>
<h3 id="comprehensions">Comprehensions</h3>
<p>Elixir also provides list and bit comprehensions. List comprehensions
allow you to quickly build a list from another list:</p>
<pre><code>iex&gt; lc n inlist [1,2,3,4], do: n * 2
[2,4,6,8]
</code></pre>
<p>Or, using keywords blocks:</p>
<pre><code>lc n inlist [1,2,3,4] do
  n * 2
end
</code></pre>
<p>A comprehension accepts many generators (given by <code>inlist</code> or <code>inbits</code>
operators) as well as filters:</p>
<pre><code># A comprehension with a generator and a filter
iex&gt; lc n inlist [1,2,3,4,5,6], rem(n, 2) == 0, do: n
[2,4,6]

# A comprehension with two generators
iex&gt; lc x inlist [1,2], y inlist [2,3], do: x*y
[2,3,4,6]
</code></pre>
<p>Elixir provides generators for both lists and bitstrings:</p>
<pre><code># A list generator:
iex&gt; lc n inlist [1,2,3,4], do: n * 2
[2,4,6,8]

# A bit string generator:
iex&gt; lc &lt;&lt;n&gt;&gt; inbits &lt;&lt;1,2,3,4&gt;&gt;, do: n * 2
[2,4,6,8]
</code></pre>
<p>Bit string generators are quite useful when you need to organize
streams:</p>
<pre><code>iex&gt; pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
iex&gt; lc &lt;&lt;r :: size(8), g :: size(8), b :: size(8)&gt;&gt; inbits pixels, do: {r,g,b}
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
</code></pre>
<p>Remember, as strings are binaries and a binary is a bitstring, we can
also use strings in comprehensions. For instance, the example below
removes all white space characters from a string via bit comprehensions:</p>
<pre><code>iex&gt; bc &lt;&lt;c&gt;&gt; inbits &quot; hello world &quot;, c != ?\s, do: &lt;&lt;c&gt;&gt;
&quot;helloworld&quot;
</code></pre>
<h3 id="pseudo-variables">Pseudo variables</h3>
<p>Elixir provides a set of pseudo-variables. These variables can only be
read and never assigned to. They are:</p>
<ul>
<li>
<p><code>__MODULE__</code> - Returns an atom representing the current module or
nil;</p>
</li>
<li>
<p><code>__FILE__</code> - Returns a string representing the current file;</p>
</li>
<li>
<p><code>__DIR__</code> - Returns a string representing the current directory;</p>
</li>
<li>
<p><code>__ENV__</code> - Returns a <a href="/docs/stable/Macro.Env.html">Macro.Env</a>
record with information about the compilation environment. Here we
can access the current module, function, line, file and others;</p>
</li>
<li>
<p><code>__CALLER__</code> - Also returns a
<a href="/docs/stable/Macro.Env.html">Macro.Env</a> record but with information
of the calling site. <code>__CALLER__</code> is available only inside macros;</p>
</li>
</ul>
<h2 id="where-to-go-next">Where To Go Next</h2>
<h3 id="applications">Applications</h3>
<p>In order to get your first project started, Elixir ships with a build
tool called <a href="/getting_started/mix/1.html"><code>Mix</code></a>. You can get your new
project started by simply running:</p>
<pre><code>mix new path/to/new/project
</code></pre>
<p>You can learn more about Elixir and other applications in the links
below:</p>
<ul>
<li>
<p><a href="/getting_started/mix/1.html">Mix - a build tool for Elixir</a></p>
</li>
<li>
<p><a href="/getting_started/ex_unit/1.html">ExUnit - a unit test framework</a></p>
</li>
</ul>
<h3 id="a-byte-of-erlang">A Byte of Erlang</h3>
<p>As the main page of this site puts it:</p>
<blockquote>
<p>Elixir is a programming language built on top of the Erlang VM.</p>
</blockquote>
<p>Sooner than later, an Elixir developer will want to interface with
existing Erlang libraries. Here&rsquo;s a list of online resources that cover
Erlang&rsquo;s fundamentals and its more advanced features:</p>
<ul>
<li>
<p>This <a href="http://elixir-lang.org/crash-course.html">Erlang Syntax: A Crash
Course</a> provides a concise
intro to Erlang&rsquo;s syntax. Each code snippet is accompanied by
equivalent code in Elixir. This is an opportunity for you to not
only get some exposure to the Erlang&rsquo;s syntax but also review some
of the things you have learned in the present guide.</p>
</li>
<li>
<p>Erlang&rsquo;s official website has a short
<a href="http://www.erlang.org/course/concurrent_programming.html">tutorial</a>
with pictures that briefly describe Erlang&rsquo;s primitives for
concurrent programming.</p>
</li>
<li>
<p><a href="http://learnyousomeerlang.com/">Learn You Some Erlang for Great
Good!</a> is an excellent introduction
to Erlang, its design principles, standard library, best practices
and much more. If you are serious about Elixir, you&rsquo;ll want to get a
solid understanding of Erlang principles. Once you have read through
the crash course mentioned above, you&rsquo;ll be able to safely skip the
first couple of chapters in the book that mostly deal with the
syntax. When you reach <a href="http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency">The Hitchhiker&rsquo;s Guide to
Concurrency</a>
chapter, that&rsquo;s where the real fun starts.</p>
</li>
</ul>
<h3 id="reference-manual">Reference Manual</h3>
<p><a href="https://github.com/elixir-lang/elixir">You can also check the source code of Elixir
itself</a>, which is mainly written
in Elixir (mainly the <code>lib</code> directory), or <a href="http://elixir-lang.org/docs/">explore Elixir&rsquo;s
documentation</a>.</p>
<h3 id="join-the-community">Join The Community</h3>
<p>Remember that in case of any difficulties, you can always visit the
<em>#elixir-lang</em> channel on <em>irc.freenode.net</em> or send a message to the
<a href="http://groups.google.com/group/elixir-lang-talk">mailing list</a>. You can
be sure that there will be someone willing to help. And to keep posted
on the latest news and announcements, follow the
<a href="http://elixir-lang.org/blog/">blog</a> and join <a href="http://groups.google.com/group/elixir-lang-core">elixir-core mailing
list</a>.</p>
<h2 id="introduction-to-mix">Introduction to Mix</h2>
<p>Elixir ships with a few applications to make building and deploying
projects with Elixir easier and Mix is certainly their backbone.</p>
<p>Mix is a build tool that provides tasks for creating, compiling, testing
(and soon deploying) Elixir projects. Mix is inspired by the
<a href="https://github.com/technomancy/leiningen">Leiningen</a> build tool for
Clojure and was written by one of its contributors.</p>
<p>In this chapter, you will learn how to create projects using <code>mix</code> and
install dependencies. In the following sections, we will also learn how
to create OTP applications and create custom tasks with Mix.</p>
<h3 id="bootstrapping">Bootstrapping</h3>
<p>In order to start your first project, simply use the <code>mix new</code> command
passing the path to your project. For now, we will create an project
called <code>my_project</code> in the current directory:</p>
<pre><code>$ mix new my_project
</code></pre>
<p>Mix will create a directory named <code>my_project</code> with few files in it:</p>
<pre><code>.gitignore
README.md
mix.exs
lib/my_project.ex
test/test_helper.exs
test/my_project_test.exs
</code></pre>
<p>Let&rsquo;s take a brief look at some of these.</p>
<blockquote>
<p>Note: Mix is an Elixir executable. This means that in order to run
<code>mix</code>, you need to have elixir&rsquo;s executable in your PATH. If not, you
can run it by passing the script as argument to elixir:</p>
<pre><code>$ bin/elixir bin/mix new ./my_project
</code></pre>
<p>Note that you can also execute any script in your PATH from Elixir via
the -S option:</p>
<pre><code>$ bin/elixir -S mix new ./my_project
</code></pre>
<p>When using -S, elixir finds the script wherever it is in your PATH and
executes it.</p>
</blockquote>
<h4 id="mixexs">mix.exs</h4>
<p>This is the file with your projects configuration. It looks like this:</p>
<pre><code>defmodule MyProject.Mixfile do
  use Mix.Project

  def project do
    [ app: :my_project,
      version: &quot;0.0.1&quot;,
      deps: deps ]
  end

  # Configuration for the OTP application
  def application do
    []
  end

  # Returns the list of dependencies in the format:
  # { :foobar, &quot;0.1&quot;, git: &quot;https://github.com/elixir-lang/foobar.git&quot; }
  defp deps do
    []
  end
end
</code></pre>
<p>Our <code>mix.exs</code> is quite straight-forward. It defines two functions:
<code>project</code>, which returns project configuration like the project name and
version, and <code>application</code>, which is used to generate an Erlang
application that is managed by the Erlang Runtime. In this chapter, we
will talk about the <code>project</code> function. We will go into detail about
what goes in the <code>application</code> function in the next chapter.</p>
<h4 id="libmy_projectex">lib/my_project.ex</h4>
<p>This file contains a simple module definition to lay out our code:</p>
<pre><code>defmodule MyProject do
end
</code></pre>
<h4 id="testmy_project_testexs">test/my_project_test.exs</h4>
<p>This file contains a stub test case for our project:</p>
<pre><code>Code.require_file &quot;test_helper.exs&quot;, __DIR__

defmodule MyProjectTest do
  use ExUnit.Case

  test &quot;the truth&quot; do
    assert true
  end
end
</code></pre>
<p>It is important to note a couple things:</p>
<p>â€‹1) Notice the file is an Elixir script file (<code>.exs</code>). This is
convenient because we don&rsquo;t need to compile test files before running
them;</p>
<p>â€‹2) The first line in our test is simply requiring the <code>test_helper</code>
file in the same directory as the current file. As we are going to see,
the <code>test/test_helper.exs</code> file is responsible for starting the test
framework;</p>
<p>â€‹3) We define a test module named <code>MyProjectTest</code>, using <code>ExUnit.Case</code>
to inject default behavior and define a simple test. You can learn more
about the test framework in the
<a href="/getting_started/ex_unit/1.html">ExUnit</a> chapter;</p>
<h4 id="testtest_helperexs">test/test_helper.exs</h4>
<p>The last file we are going to check is the <code>test_helper.exs</code>, which
simply sets up the test framework:</p>
<pre><code>ExUnit.start
</code></pre>
<p>And that is it, our project is created. We are ready to move on!</p>
<h3 id="exploring">Exploring</h3>
<p>Now that we created our new project, what can we do with it? In order to
check the commands available to us, just run the <code>help</code> task:</p>
<pre><code>$ mix help
</code></pre>
<p>It will print all the available tasks. You can get further information
by invoking <code>mix help TASK</code>.</p>
<p>Play around with the available tasks, like <code>mix compile</code> and <code>mix test</code>,
and execute them in your project to check how they work.</p>
<h3 id="compilation-1">Compilation</h3>
<p>Mix can compile our project for us. The default configurations uses
<code>lib/</code> for source files and <code>ebin/</code> for compiled beam files. You don&rsquo;t
even have to provide any compilation-specific setup but if you must,
some options are available. For instance, if you want to put your
compiled files in another directory besides <code>ebin</code>, simply set in
<code>:compile_path</code> in your <code>mix.exs</code> file:</p>
<pre><code>def project do
  [compile_path: &quot;ebin&quot;]
end
</code></pre>
<p>In general, Mix tries to be smart and compiles only when necessary.</p>
<p>Note that after you compile for the first time, Mix generates a
<code>my_project.app</code> file inside your <code>ebin</code> directory. This file defines an
Erlang application based on the contents of the <code>application</code> function
in your Mix project.</p>
<p>The <code>.app</code> file holds information about the application, what are its
dependencies, which modules it defines and so forth. The application is
automatically started by Mix every time you run some commands and we
will learn how to configure it in the next chapter.</p>
<h3 id="dependencies">Dependencies</h3>
<p>Mix is also able to manage dependencies. Dependencies should be listed
in the project settings, as follows:</p>
<pre><code>def project do
  [ app: :my_project,
    version: &quot;0.0.1&quot;,
    deps: deps ]
end

defp deps do
  [ { :some_project, &quot;0.3.0&quot;, github: &quot;some_project/other&quot; },
    { :another_project, &quot;1.0.2&quot;, git: &quot;https://example.com/another/repo.git&quot; } ]
end
</code></pre>
<p><em>Note:</em> Although not required, it is common to split dependencies into
their own function.</p>
<h4 id="source-code-management-scm">Source Code Management (SCM)</h4>
<p>In the example above, we have used <code>git</code> to specify our dependencies.
Mix is designed in a way it can support multiple SCM tools, shipping
with <code>:git</code> and <code>:path</code> support by default. The most common options are:</p>
<ul>
<li>
<p><code>:git</code> - the dependency is a git repository that is retrieved and
updated by Mix;</p>
</li>
<li>
<p><code>:path</code> - the dependency is simply a path in the filesystem;</p>
</li>
<li>
<p><code>:compile</code> - how to compile the dependency;</p>
</li>
<li>
<p><code>:app</code> - the path of the application expected to be defined by the
dependency;</p>
</li>
</ul>
<p>Each SCM may support custom options. <code>:git</code>, for example, supports the
following:</p>
<ul>
<li>
<p><code>:ref</code> - an optional reference (a commit) to checkout the git
repository;</p>
</li>
<li>
<p><code>:tag</code> - an optional tag to checkout the git repository;</p>
</li>
<li>
<p><code>:branch</code> - an optional branch to checkout the git repository;</p>
</li>
<li>
<p><code>:submodules</code> - when true, initializes submodules recursively in the
dependency;</p>
</li>
</ul>
<h4 id="compiling-dependencies">Compiling dependencies</h4>
<p>In order to compile a dependency, Mix looks into the repository for the
best way to proceed. If the dependency contains one of the files below,
it will proceed as follows:</p>
<ol>
<li>
<p><code>mix.exs</code> - compiles the dependency directly with Mix by invoking
the <code>compile</code> task;</p>
</li>
<li>
<p><code>rebar.config</code> or <code>rebar.config.script</code> - compiles using
<code>rebar compile deps_dir=DEPS</code>, where <code>DEPS</code> is the directory where
Mix will install the project dependencies by default;</p>
</li>
<li>
<p><code>Makefile</code> - simply invokes <code>make</code>;</p>
</li>
</ol>
<p>If the dependency does not contain any of the above, you can specify a
command directly with the <code>:compile</code> option:</p>
<pre><code>    compile: &quot;./configure &amp;&amp; make&quot;
</code></pre>
<p>If <code>:compile</code> is set to false, nothing is done.</p>
<h4 id="repeatability">Repeatability</h4>
<p>An important feature in any dependency management tool is repeatability.
For this reason when you first get your dependencies, Mix will create a
file called <code>mix.lock</code> that contains checked out references for each
dependency.</p>
<p>When another developer gets a copy of the same project, Mix will
checkout exactly the same references, ensuring other developers can
&ldquo;repeat&rdquo; the same setup.</p>
<p>Locks are automatically updated when <code>deps.update</code> is called and can be
removed with <code>deps.unlock</code>.</p>
<h4 id="dependencies-tasks">Dependencies tasks</h4>
<p>Elixir has many tasks to manage the project dependencies:</p>
<ul>
<li>
<p><code>mix deps</code> - List all dependencies and their status;</p>
</li>
<li>
<p><code>mix deps.get</code> - Get all unavailable dependencies;</p>
</li>
<li>
<p><code>mix deps.compile</code> - Compile dependencies;</p>
</li>
<li>
<p><code>mix deps.update</code> - Update dependencies;</p>
</li>
<li>
<p><code>mix deps.clean</code> - Remove dependencies files;</p>
</li>
<li>
<p><code>mix deps.unlock</code> - Unlock the given dependencies;</p>
</li>
</ul>
<p>Use <code>mix help</code> to get more information.</p>
<h4 id="dependencies-of-dependencies">Dependencies of dependencies</h4>
<p>If your dependency is another Mix or rebar project, Mix does the right
thing: it will automatically fetch and handle all dependencies of your
dependencies. However, if your project have two dependencies that share
the same dependency and the SCM information for the shared dependency
doesn&rsquo;t match between the parent dependencies, Mix will mark that
dependency as diverged and emit a warning. To solve this issue you can
declare the shared dependency in your project and Mix will use that SCM
information to fetch the dependency.</p>
<h3 id="environments">Environments</h3>
<p>Mix has the concept of environments that allows a developer to customize
compilation and other options based on an external setting. By default,
Mix understands three environments:</p>
<ul>
<li>
<p><code>dev</code> - the one in which mix tasks are run by default;</p>
</li>
<li>
<p><code>test</code> - used by <code>mix test</code>;</p>
</li>
<li>
<p><code>prod</code> - the environment in which dependencies are loaded and
compiled;</p>
</li>
</ul>
<p>By default, these environments behave the same and all configuration we
have seen so far will affect all three environments. Customization per
environment can be done using the <code>env:</code> option:</p>
<pre><code>def project do
  [ env: [
    prod: [compile_path: &quot;prod_ebin&quot;] ] ]
end
</code></pre>
<p>Mix will default to the <code>dev</code> environment (except for tests). The
environment can be changed via the <code>MIX_ENV</code> environment variable:</p>
<pre><code>$ MIX_ENV=prod mix compile
</code></pre>
<p>In the next chapters, we will learn more about building OTP applications
with Mix and how to create your own tasks.</p>
<h2 id="building-otp-apps-with-mix">Building OTP apps with Mix</h2>
<p>In the previous chapter, we have generated a project with Mix and
explored a bit how Mix works. In this chapter, we will learn how to
build an OTP application. In practice, we don&rsquo;t need Mix in order to
build such applications, however Mix provides some conveniences that we
are going to explore throughout this chapter.</p>
<h3 id="the-stacker-server">The Stacker server</h3>
<p>Our application is going to be a simple stack that allow us push and pop
items as we wish. Let&rsquo;s call it stacker:</p>
<pre><code>$ mix new stacker
</code></pre>
<p>Our application is going to have one stack which may be accessed by many
processes at the same time. To achieve that, we will create a server
that is responsible to manage the stack. Clients will send messages to
the server whenever they want to push or pop something from the stack.</p>
<p>Since creating such servers is a common pattern when building Erlang and
Elixir applications, we have a behavior in OTP that encapsulates common
server functionalities called <em>GenServer</em>. Let&rsquo;s create a file named
<code>lib/stacker/server.ex</code> with our first server:</p>
<pre><code>defmodule Stacker.Server do
  use GenServer.Behaviour

  def init(stack) do
    { :ok, stack }
  end

  def handle_call(:pop, _from, [h|stack]) do
    { :reply, h, stack }
  end

  def handle_cast({ :push, new }, stack) do
    { :noreply, [new|stack] }
  end
end
</code></pre>
<p>Our server defines three callbacks: <code>init/1</code>, <code>handle_call/3</code> and
<code>handle_cast/2</code>. We never call those functions directly, they are called
by OTP whenever we interact with the server. We will go into details
about these soon, let&rsquo;s just ensure it works as expected. To do so, run
<code>iex -S mix</code> on your command line to start iex with mix and type the
following:</p>
<pre><code># Let's start the server using Erlang's :gen_server module.
# It expects 3 arguments: the server module, the initial
# stack and some options (if desired):
iex&gt; { :ok, pid } = :gen_server.start_link(Stacker.Server, [], [])
{:ok,&lt;...&gt;}

# Now let's push something onto the stack
iex&gt; :gen_server.cast(pid, { :push, 13 })
:ok

# Now let's get it out from the stack
# Notice we are using *call* instead of *cast*
iex&gt; :gen_server.call(pid, :pop)
13
</code></pre>
<p>Excellent, our server works as expected! There are many things happening
behind the scenes, so let&rsquo;s discuss them one by one.</p>
<p>First, we started the server using <a href="http://www.erlang.org/doc/man/gen_server.html">the <code>:gen_server</code> module from
OTP</a>. Notice we have used
<code>start_link</code>, which starts the server and links our current process to
the server. In this scenario, if the server dies, it will send an exit
message to our process, making it crash too. We will see this in action
later. The <code>start_link</code> function returns the process identifier (<code>pid</code>)
of the newly spawned server.</p>
<p>Later, we have sent a <em>cast</em> message to the <code>pid</code>. The message was
<code>{ :push, 13 }</code>, written in the same format as we specified in the
<code>handle_cast/2</code> callback in <code>Stacker.Server</code>. Whenever we send a <code>cast</code>
message, the <code>handle_cast/2</code> callback will be invoked to handle the
message.</p>
<p>Then we finally read what was on the stack by sending a <em>call</em> message,
which will dispatch to the <code>handle_call/3</code> callback. So, what is the
difference between <em>cast</em> and <em>call</em> after all?</p>
<p><code>cast</code> messages are asynchronous: we simply send a message to the server
and don&rsquo;t expect a reply back. That&rsquo;s why our <code>handle_cast/2</code> callback
returns <code>{ :noreply, [new|stack] }</code>. The first item of the tuple states
nothing should be replied and the second contains our updated stack with
the new item.</p>
<p>On the other hand, <code>call</code> messages are synchronous. When we send a
<code>call</code> message, the client expects a response back. In this case, the
<code>handle_call/3</code> callback returns <code>{ :reply, h, stack }</code>, where the
second item is the term to be returned and the third is our new stack
without its head. Since <code>call</code>s are able to send messages back to the
client, it also receives the client information as argument (<code>_from</code>).</p>
<h4 id="learning-more-about-callbacks">Learning more about callbacks</h4>
<p>In the GenServer&rsquo;s case, there are 8 different values a callback such as
<code>handle_call</code> or <code>handle_cast</code> can return:</p>
<pre><code>{ :reply, reply, new_state }
{ :reply, reply, new_state, timeout }
{ :reply, reply, new_state, :hibernate }
{ :noreply, new_state }
{ :noreply, new_state, timeout }
{ :noreply, new_state, :hibernate }
{ :stop, reason, new_state }
{ :stop, reason, reply, new_state }
</code></pre>
<p>There are 6 callbacks required to be implemented in a GenServer. The
<code>GenServer.Behaviour</code> module defines all of them automatically but
allows us to customize the ones we need. The list of callbacks are:</p>
<ul>
<li>
<p><code>init(args)</code> - invoked when the server is started;</p>
</li>
<li>
<p><code>handle_call(msg, from, state)</code> - invoked to handle call messages;</p>
</li>
<li>
<p><code>handle_cast(msg, state)</code> - invoked to handle cast messages;</p>
</li>
<li>
<p><code>handle_info(msg, state)</code> - handle all other messages which are
normally received by processes;</p>
</li>
<li>
<p><code>terminate(reason, state)</code> - called when the server is about to
terminate, useful for cleaning up;</p>
</li>
<li>
<p><code>code_change(old_vsn, state, extra)</code> - called when the application
code is being upgraded live (hot code swap);</p>
</li>
</ul>
<h4 id="crashing-a-server">Crashing a server</h4>
<p>Of what use is a server if we cannot crash it?</p>
<p>It is actually quite easy to crash our server. Our <code>handle_call/3</code>
callback only works if there is something on the stack (remember <code>[h|t]</code>
won&rsquo;t match an empty list). So let&rsquo;s simply send a message when the
stack is empty:</p>
<pre><code># Start another server, but with an initial :hello item
iex&gt; { :ok, pid } = :gen_server.start_link(Stacker.Server, [:hello], [])
{:ok,&lt;...&gt;}

# Let's get our initial item:
iex&gt; :gen_server.call(pid, :pop)
:hello

# And now let's call pop again
iex&gt; :gen_server.call(pid, :pop)

=ERROR REPORT==== 6-Dec-2012::19:15:33 ===
...
** (exit) 
...
</code></pre>
<p>You can see there are two error reports. The first one is generated by
server, due to the crash. Since the server is linked to our process, it
also sent an exit message which was printed by <code>IEx</code> as <code>** (exit) ...</code>.</p>
<p>Since our servers may eventually crash, it is common to supervise them,
and that&rsquo;s what we are going to next. There is a bit more to <code>GenServer</code>
than what we have seen here. For more information, check
<a href="http://elixir-lang.org/docs/stable/GenServer.Behaviour.html"><code>GenServer.Behaviour</code>&rsquo;s
documentation</a>.</p>
<h3 id="supervising-our-servers">Supervising our servers</h3>
<p>When building applications in Erlang/Elixir, a common philosophy is to
&ldquo;let it crash&rdquo;. Resources are going to become unavailable, timeout in
between services are going to happen and other possible failures exist.
That&rsquo;s why it is important to recover and react to such failures. With
this in mind, we are going to write a supervisor for our server.</p>
<p>Create a file at <code>lib/stacker/supervisor.ex</code> with the following:</p>
<pre><code>defmodule Stacker.Supervisor do
  use Supervisor.Behaviour

  # A convenience to start the supervisor
  def start_link(stack) do
    :supervisor.start_link(__MODULE__, stack)
  end

  # The callback invoked when the supervisor starts
  def init(stack) do
    children = [ worker(Stacker.Server, [stack]) ]
    supervise children, strategy: :one_for_one
  end
end
</code></pre>
<p>In case of supervisors, the only callback that needs to be implemented
is <code>init(args)</code>. This callback needs to return a supervisor
specification, in this case returned by the helper function
<code>supervise/2</code>.</p>
<p>Our supervisor is very simple: it has to supervise one worker, in this
case, <code>Stacker.Server</code> and the worker will be started by receiving one
argument, which is the default stack. The defined worker is then going
to be supervised using the <code>:one_for_one</code> strategy, which restarts each
worker after it dies.</p>
<p>Given that our worker is specified by the <code>Stacker.Server</code> module
passing the <code>stack</code> as argument, the supervisor will by default invoke
the <code>Stacker.Server.start_link(stack)</code> function to start the worker, so
let&rsquo;s implement it:</p>
<pre><code>defmodule Stacker.Server do
  use GenServer.Behaviour

  def start_link(stack) do
    :gen_server.start_link({ :local, :stacker }, __MODULE__, stack, [])
  end

  def init(stack) do
    { :ok, stack }
  end

  def handle_call(:pop, _from, [h|stack]) do
    { :reply, h, stack }
  end

  def handle_cast({ :push, new }, stack) do
    { :noreply, [new|stack] }
  end
end
</code></pre>
<p>The <code>start_link</code> function is quite similar to how we were starting our
server previously, except that now we passed one extra argument:
<code>{ :local, :stacker }</code>. This argument registers the server on our local
nodes, allowing it to be invoked by the given name (in this case,
<code>:stacker</code>), instead of directly using the <code>pid</code>.</p>
<p>With our supervisor in hand, let&rsquo;s start the console by running
<code>iex -S mix</code> once again, which will recompile our files too:</p>
<pre><code># Now we will start the supervisor with a
# default stack containing :hello
iex&gt; Stacker.Supervisor.start_link([:hello])
{:ok,&lt;...&gt;}

# And we will access the server by name since
# we registered it
iex&gt; :gen_server.call(:stacker, :pop)
:hello
</code></pre>
<p>Notice the supervisor started the server for us and we were able to send
messages to it via the name <code>:stacker</code>. What happens if we crash our
server again?</p>
<pre><code>iex&gt; :gen_server.call(:stacker, :pop)

=ERROR REPORT==== 6-Dec-2012::19:15:33 ===
...
** (exit) 
...

iex&gt; :gen_server.call(:stacker, :pop)
:hello
</code></pre>
<p>It crashes exactly as before but it is restarted right away by the
supervisor with the default stack, allowing us to retrieve <code>:hello</code>
again. Excellent!</p>
<p>By default the supervisor allows a worker to restart at maximum 5 times
in a 5 seconds timespan. If the worker crashes more frequently than
that, the supervisor gives up on the worker and no longer restarts it.
Let&rsquo;s check it by sending 5 unknown messages one right after the other
(be fast!):</p>
<pre><code>iex&gt; :gen_server.call(:stacker, :unknown)
... 5 times ...

iex&gt; :gen_server.call(:stacker, :unknown)
** (exit) {:noproc,{:gen_server,:call,[:stacker,:unknown]}}
    gen_server.erl:180: :gen_server.call/2
</code></pre>
<p>The sixth message no longer generates an error report, since our server
was no longer started automatically. Elixir returns <code>:noproc</code> (which
stands for no process), meaning there isn&rsquo;t a process named <code>:stacker</code>.
The number of restarts allowed and its time interval can be customized
by passing options to the <code>supervise</code> function. Different restart
strategies, besides the <code>:one_for_one</code> used above, can be chosen for the
supervisor as well. For more information on the supported options,
<a href="http://elixir-lang.org/docs/stable/Supervisor.Behaviour.html">check the documentation for
<code>Supervisor.Behaviour</code></a>.</p>
<h3 id="who-supervises-the-supervisor">Who supervises the supervisor?</h3>
<p>We have built our supervisor but a pertinent question is: who
supervisors the supervisor? To answer this question, OTP contains the
concept of applications. Applications can be started and stopped as an
unit and, when doing so, they are often linked to a supervisor.</p>
<p>In the previous chapter, we have learned how Mix automatically generates
an <code>.app</code> file every time we compile our project based on the
information contained on the <code>application</code> function in our <code>mix.exs</code>
file.</p>
<p>The <code>.app</code> file is called <em>application specification</em> and it must
contain our application dependencies, the modules it defines, registered
names and many others. Some of this information is filled in
automatically by Mix but other data needs to be added manually.</p>
<p>In this particular case, our application has a supervisor and,
furthermore, it registers a server with name <code>:stacker</code>. That said, it
is useful to add to the <em>application specification</em> all registered names
in order to avoid conflicts. If it happens that two applications
register the same name, we will be able to find about this conflict
sooner. So, let&rsquo;s open the <code>mix.exs</code> file and edit the <code>application</code>
function to the following:</p>
<pre><code>def application do
  [ registered: [:stacker],
    mod: { Stacker, [:hello] } ]
end
</code></pre>
<p>In the <code>:registered</code> key we specify all names registered by our
application. The <code>:mod</code> key specifies that, as soon as the application
is started, it must invoke the <em>application module callback</em>. In this
case, the <em>application module callback</em> will be the <code>Stacker</code> module and
it will receive the default stack <code>[:hello]</code> as argument. The callback
must return the <code>pid</code> of the supervisor which is associated to this
application.</p>
<p>With this in mind, let&rsquo;s open up the <code>lib/stacker.ex</code> file and add the
following:</p>
<pre><code>defmodule Stacker do
  use Application.Behaviour

  def start(_type, stack) do
    Stacker.Supervisor.start_link(stack)
  end
end
</code></pre>
<p>The <code>Application.Behaviour</code> expects two callbacks, <code>start(type, args)</code>
and <code>stop(state)</code>. We are required to implement <code>start/2</code> though we have
decided to not bother about <code>stop(state)</code> for now.</p>
<p>After adding the application behavior above, all you need to do is to
start <code>iex -S mix</code> once again. Our files are going to be recompiled and
the supervisor (and consequently our server) will be automatically
started:</p>
<pre><code>iex&gt; :gen_server.call(:stacker, :pop)
:hello
</code></pre>
<p>Amazing, it works! As you may have noticed, the application <code>start/2</code>
callback receives a type argument, which we have ignored. The type
controls how the VM should behave when the supervisor, and consequently
our application, crashes. You can learn more about it by <a href="http://elixir-lang.org/docs/stable/Application.Behaviour.html">reading the
documentation for
<code>Application.Behaviour</code></a>.</p>
<h3 id="starting-applications">Starting applications</h3>
<p>Mix will always start the current application and all application
dependencies. Notice there is a difference between your project
dependencies (the ones defined under the <code>deps</code> key we have discussed in
the previous chapter) and the application dependencies.</p>
<p>The project dependencies may contain your test framework or a
compile-time only dependency. The application dependency is everything
you depend on at runtime. Any application dependency needs to be
explicitly added to the <code>application</code> function too:</p>
<pre><code>def application do
  [ registered: [:stacker],
    applications: [:some_dep],
    mod: { Stacker, [:hello] } ]
end
</code></pre>
<p>When running tasks on Mix, it will ensure the application and all
application dependencies are started. This can also be done via command
line with the flag <code>--app</code>:</p>
<pre><code>$ elixir -pa ebin --app my_project
</code></pre>
<p>You may also start each application individually via the command line
using <a href="http://www.erlang.org/doc/man/application.html">Erlang&rsquo;s :application
module</a>:</p>
<pre><code>:application.start(:my_project)
</code></pre>
<p>Besides <code>registered</code>, <code>applications</code> and <code>mod</code>, there are other keys
allowed in the application specification. You can learn more about them
<a href="http://learnyousomeerlang.com/building-otp-applications">in the applications chapter from Learn You Some
Erlang</a>.</p>
<p>Finally, notice that <code>mix new</code> supports a <code>--sup</code> option, which tells
Mix to generate a supervisor with an application module callback,
automating some of the work we have done here (try it!). With this note,
we finalize this chapter. We have learned how to create servers,
supervise them, and hook them into our application lifecycle. In the
next chapter, we will learn how to create custom tasks in Mix.</p>
<h2 id="creating-custom-mix-tasks">Creating custom Mix tasks</h2>
<p>In Mix, a task is simply an Elixir module inside the <code>Mix.Tasks</code>
namespace containing a <code>run/1</code> function. For example, the <code>compile</code> task
is a module named <code>Mix.Tasks.Compile</code>.</p>
<p>Let&rsquo;s create a simple task:</p>
<pre><code>defmodule Mix.Tasks.Hello do
  use Mix.Task

  @shortdoc &quot;This is short documentation, see&quot;

  @moduledoc &quot;&quot;&quot;
  A test task.
  &quot;&quot;&quot;
  def run(_) do
    IO.puts &quot;Hello, World!&quot;
  end
end
</code></pre>
<p>Save this module to a file named <code>hello.ex</code> then compile and run it as
follows:</p>
<pre><code>$ elixirc hello.ex
$ mix hello
Hello, World!
</code></pre>
<p>The module above defines a task named <code>hello</code>. The function <code>run/1</code>
takes a single argument that will be a list of binary strings which are
the arguments that were passed to the task on the command line.</p>
<p>When you invoke <code>mix hello</code>, this task will run and print
<code>Hello, World!</code>. Mix uses its first argument (<code>hello</code> in this case) to
lookup the task module and execute its <code>run</code> function.</p>
<p>You&rsquo;re probably wondering why we have a <code>@moduledoc</code> and <code>@shortdoc</code>.
Both are used by the <code>help</code> task for listing tasks and providing
documentation. The former is used when <code>mix help TASK</code> is invoked, the
latter in the general listing with <code>mix help</code>.</p>
<p>Besides those two, there is also <code>@hidden</code> attribute that, when set to
true, marks the task as hidden so it does not show up on <code>mix help</code>. Any
task without <code>@shortdoc</code> also won&rsquo;t show up.</p>
<h3 id="common-api">Common API</h3>
<p>When writing tasks, there are some common mix functionality we would
like to access. There is a gist:</p>
<ul>
<li>
<p><code>Mix.project</code> - Returns the project configuration under the function
<code>project</code>; Notice this function returns an empty configuration if no
<code>mix.exs</code> file exists in the current directory, allowing many Mix
functions to work even if a <code>mix.exs</code> project is not defined;</p>
</li>
<li>
<p><code>Mix.Project.current</code> - Access the module for the current project,
useful in case you want to access special functions in the project.
It raises an exception if no project is defined;</p>
</li>
<li>
<p><code>Mix.shell</code> - The shell is a simple abstraction for doing IO in Mix.
Such abstractions make it easy to test existing mix tasks. In the
future, the shell will provide conveniences for colored output and
getting user input;</p>
</li>
<li>
<p><code>Mix.Task.run(task, args)</code> - This is how you invoke a task from
another task in Mix; Notice that if the task was already invoked, it
works as no-op;</p>
</li>
</ul>
<p>There is more to the Mix API, so feel free to <a href="/docs/stable/Mix.html">check the
documentation</a>, with special attention to
<a href="/docs/stable/Mix.Task.html"><code>Mix.Task</code></a> and
<a href="/docs/stable/Mix.Project.html"><code>Mix.Project</code></a>.</p>
<h3 id="namespaced-tasks">Namespaced Tasks</h3>
<p>While tasks are simple, they can be used to accomplish complex things.
Since they are just Elixir code, anything you can do in normal Elixir
you can do in Mix tasks. You can distribute tasks however you want just
like normal libraries and thus they can be reused in many projects.</p>
<p>So, what do you do when you have a whole bunch of related tasks? If you
name them all like <code>foo</code>, <code>bar</code>, <code>baz</code>, etc, eventually you&rsquo;ll end up
with conflicts with other people&rsquo;s tasks. To prevent this, Mix allows
you to namespace tasks.</p>
<p>Let&rsquo;s assume you have a bunch of tasks for working with Riak.</p>
<pre><code>defmodule Mix.Tasks.Riak do
  defmodule Dostuff do
    ...
  end

  defmodule Dootherstuff do
    ...
  end
end
</code></pre>
<p>Now you&rsquo;ll have two different tasks under the modules
<code>Mix.Tasks.Riak.Dostuff</code> and <code>Mix.Tasks.Riak.Dootherstuff</code> respectively.
You can invoke these tasks like so: <code>mix riak.dostuff</code> and
<code>mix riak.dootherstuff</code>. Pretty cool, huh?</p>
<p>You should use this feature when you have a bunch of related tasks that
would be unwieldy if named completely independently of each other. If
you have a few unrelated tasks, go ahead and name them however you like.</p>
<h3 id="optionparser">OptionParser</h3>
<p>Although not a Mix feature, Elixir ships with an <code>OptionParser</code> which is
quite useful when creating mix tasks that accepts options. The
<code>OptionParser</code> receives a list of arguments and returns a tuple with
parsed options and the remaining arguments:</p>
<pre><code>OptionParser.parse([&quot;--debug&quot;])
#=&gt; { [debug: true], [] }

OptionParser.parse([&quot;--source&quot;, &quot;lib&quot;])
#=&gt; { [source: &quot;lib&quot;], [] }

OptionParser.parse([&quot;--source&quot;, &quot;lib&quot;, &quot;test/enum_test.exs&quot;, &quot;--verbose&quot;])
#=&gt; { [source: &quot;lib&quot;, verbose: true], [&quot;test/enum_test.exs&quot;] }
</code></pre>
<p>Check <a href="/docs/stable/OptionParser.html"><code>OptionParser</code></a> documentation for
more information.</p>
<h3 id="sharing-tasks">Sharing tasks</h3>
<p>After you create your own tasks, you may want to share them with other
developers or re-use them inside existing projects. In this section, we
will see different ways to share tasks in Mix.</p>
<h4 id="as-a-dependency">As a dependency</h4>
<p>Imagine you&rsquo;ve created a Mix project called <code>my_tasks</code> which provides
many tasks. By adding the <code>my_tasks</code> project as a dependency to any
other project, all the tasks in <code>my_tasks</code> will be available in the
parent project. It just works!</p>
<h4 id="as-an-archive">As an archive</h4>
<p>Mix tasks are useful not only inside projects, but also to create new
projects, automate complex tasks and to avoid repetitive work. For such
cases, you want a task always available in your workflow, regardless if
you are inside a project or not.</p>
<p>For such cases, Mix allows developers to install and uninstall archives
locally. You can generate and archive for a current project and install
it locally as:</p>
<pre><code>$ mix do archive, local.install
</code></pre>
<p>Archives can be installed from a path or any URL:</p>
<pre><code>$ mix local.install http://example.org/path/to/sample/archive.ez
</code></pre>
<p>After installing an archive, you can run all tasks contained in the
archive, list them via <code>mix local</code> or uninstall the package via
<code>mix local.uninstall archive.ez</code>.</p>
<h4 id="mix_path">MIX_PATH</h4>
<p>The last mechanism for sharing tasks is <code>MIX_PATH</code>. By setting up your
<code>MIX_PATH</code>, any task available in the <code>MIX_PATH</code> will be automatically
visible to Mix. Here is an example:</p>
<pre><code>$ export MIX_PATH=&quot;/full/path/to/my/project/ebin&quot;
</code></pre>
<p>This is useful for complex projects that must be installed at <code>/usr</code> or
<code>/opt</code> but still hook into Mix facilities.</p>
<p>With all those options in mind, you are ready to go out, create and
install your own tasks! Enjoy!</p>
<h2 id="introduction-to-exunit">Introduction to ExUnit</h2>
<p>ExUnit is a unit test framework that ships with Elixir.</p>
<p>Using ExUnit is quite easy, here is a file with the minimum required:</p>
<pre><code>ExUnit.start

defmodule MyTest do
  use ExUnit.Case

  test &quot;the truth&quot; do
    assert true
  end
end
</code></pre>
<p>In general, we just need to invoke <code>ExUnit.start</code>, define a test case
using <code>ExUnit.Case</code> and our batch of tests. Assuming we saved this file
as <code>assertion_test.exs</code>, we can run it directly:</p>
<pre><code>bin/elixir assertion_test.exs
</code></pre>
<p>In this chapter, we will discuss the most common features available in
ExUnit and how to customize it further.</p>
<h3 id="starting-exunit">Starting ExUnit</h3>
<p>ExUnit is usually started via <code>ExUnit.start</code>. This function accepts a
couple options, so <a href="/docs/stable/ExUnit.html">check its documentation</a>
for more details. For now, we will just detail the most common ones:</p>
<ul>
<li>
<p><code>:formatter</code> - When you run tests with ExUnit, all the IO is done by
<a href="https://github.com/elixir-lang/elixir/blob/master/lib/ex_unit/lib/ex_unit/formatter.ex">the
formatter</a>.
Developers can define their own formatters and this is the
configuration that tells ExUnit to use a custom formatter;</p>
</li>
<li>
<p><code>:max_cases</code> - As we are going to see soon, ExUnit allows you to
easily run tests concurrently. This is very useful to speed up your
tests that have no side affects. This option allows us to configure
the maximum number of cases ExUnit runs concurrently.</p>
</li>
</ul>
<h3 id="defining-a-test-case">Defining a test case</h3>
<p>After ExUnit is started, we can define our own test cases. This is done
by using <code>ExUnit.Case</code> in our module:</p>
<pre><code>use ExUnit.Case
</code></pre>
<p><code>ExUnit.Case</code> provides some features, so let&rsquo;s take a look at them.</p>
<h4 id="the-test-macro">The test macro</h4>
<p><code>ExUnit.Case</code> runs all functions whose name start with <code>test</code> and
expects one argument:</p>
<pre><code>def test_the_truth(_) do
  assert true
end
</code></pre>
<p>As a convenience to define such functions, <code>ExUnit.Case</code> provides a
<code>test</code> macro, which allows one to write:</p>
<pre><code>test &quot;the truth&quot; do
  assert true
end
</code></pre>
<p>This construct is considered more readable. The <code>test</code> macro accepts
either a binary or an atom as name.</p>
<h4 id="assertions">Assertions</h4>
<p>Another convenience provided by <code>ExUnit.Case</code> is to automatically import
a set of assertion macros and functions, available in
<a href="/docs/stable/ExUnit.Assertions.html"><code>ExUnit.Assertions</code></a>.</p>
<p>In the majority of tests, the only assertion macros you will need to use
are <code>assert</code> and <code>refute</code>:</p>
<pre><code>assert 1 + 1 == 2
refute 1 + 3 == 3
</code></pre>
<p>ExUnit automatically breaks those expressions apart and attempt to
provide detailed information in case the assertion fails. For example,
the failing assertion:</p>
<pre><code>assert 1 + 1 == 3
</code></pre>
<p>Will fail as:</p>
<pre><code>Expected 2 to be equal to (==) 3
</code></pre>
<p>However, some extra assertions are convenient to make testing easier for
some specific cases. A good example is the <code>assert_raise</code> macro:</p>
<pre><code>assert_raise ArithmeticError, &quot;bad argument in arithmetic expression&quot;, fn -&gt;
  1 + &quot;test&quot;
end
</code></pre>
<p>So don&rsquo;t forget to check <a href="/docs/stable/ExUnit.Assertions.html"><code>ExUnit.Assertions</code>'
documentation</a> for more examples.</p>
<h4 id="callbacks">Callbacks</h4>
<p><code>ExUnit.Case</code> defines four callbacks: <code>setup</code>, <code>teardown</code>, <code>setup_all</code>
and <code>teardown_all</code>:</p>
<pre><code>defmodule CallbacksTest do
  use ExUnit.Case, async: true

  setup do
    IO.puts &quot;This is a setup callback&quot;
    :ok
  end

  test &quot;the truth&quot; do
    assert true
  end
end
</code></pre>
<p>In the example above, the <code>setup</code> callback will be run before each test.
In case a <code>setup_all</code> callback is defined, it would run once before all
tests in that module.</p>
<p>A callback <em>must</em> return <code>:ok</code> or <code>{ :ok, data }</code>. When the latter is
returned, the <code>data</code> argument must be a keywords list containing
metadata about the test. This metadata can be accessed in any other
callback or in the test itself:</p>
<pre><code>defmodule CallbacksTest do
  use ExUnit.Case, async: true

  setup do
    IO.puts &quot;This is a setup callback&quot;
    { :ok, from_setup: :hello }
  end

  test &quot;the truth&quot;, meta do
    assert meta[:from_setup] == :hello
  end

  teardown meta do
    assert meta[:from_setup] == :hello
  end
end
</code></pre>
<p>Metadata is used when state need to be explicitly passed to tests.</p>
<h4 id="async">Async</h4>
<p>Finally, ExUnit also allows test cases to run concurrently. All you need
to do is pass the <code>:async</code> option set to true:</p>
<pre><code>use ExUnit.Case, async: true
</code></pre>
<p>This will run this test case concurrently with other test cases which
are async too. The tests inside a particular case are still run
sequentially.</p>
<h3 id="lots-to-do">Lots To Do</h3>
<p>ExUnit is still a work in progress. Feel free to visit <a href="https://github.com/elixir-lang/elixir/issues">our issues
tracker</a> to add issues for
anything you&rsquo;d like to see in ExUnit and feel free to contribute.</p>
<h1 id="crystal">Crystal</h1>
<p>The Crystal programming language.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="http://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger W.
Dijkstra</a> was
indertijd een hevig tegenstander van het gebruik van de
<a href="http://en.wikipedia.org/wiki/Goto"><code>goto</code></a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Dit soort constructies zou anno 2012 absoluut moeten vermeden
worden.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Procedure is synoniem van methode, functie of subroutine.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>


        

        

        
      </article>

      


      

    </div>
  </div>
</div>

      
    <div class="page-meta">
  
  
  
</div>


  
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
        </ul>
        <p class="credits copyright text-muted">
          

          &nbsp;&bull;&nbsp;&copy;
          
            1975
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://lrutten.github.io/">lrutten</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="https://gohugo.io">Hugo v0.85.0</a> powered &nbsp;&bull;&nbsp; Theme <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> adapted from <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://lrutten.github.io/js/main.js"></script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://lrutten.github.io/js/load-photoswipe.js"></script>









    
  </body>
</html>

