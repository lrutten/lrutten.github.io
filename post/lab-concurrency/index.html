<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Labo C&#43;&#43;11 concurrency</title>

  <meta name="author" content="" />
  
  

  <meta name="generator" content="Hugo 0.54.0" />

  <link rel="alternate" href="http://eaict.technologiecampusdiepenbeek.be/index.xml" type="application/rss+xml" title="eaict">

  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="http://eaict.technologiecampusdiepenbeek.be/css/bootstrap.min.css" />
  <link rel="stylesheet" href="http://eaict.technologiecampusdiepenbeek.be/css/main.css" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="http://eaict.technologiecampusdiepenbeek.be/css/pygment_highlights.css" />
  
  
  <meta property="og:title" content="Labo C&#43;&#43;11 concurrency" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="/post/lab-concurrency//" />
  <meta property="og:image" content="" />
  
</head>


  <body>
    <h1>een lange titel</h1>
    
    
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://eaict.technologiecampusdiepenbeek.be/">eaict</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
          <li>
          <a title="Start" href="/">Start</a>
  	      </li>
  	    
      
        
          <li>
          <a title="Over" href="/page/over/">Over</a>
  	      </li>
  	    
      
      </ul>
    </div>

	<div class="avatar-container">
	  <div class="avatar-img-border">
      
	  </div>
	</div>

  </div>
</nav>


    <div role="main" class="container main-content">

      
        





<header class="header-section ">

<div class="intro-header no-img">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-heading">
          <h1>Labo C&#43;&#43;11 concurrency</h1>
      
        
      <h2 class="post-subheading">C&#43;&#43;11 thread, async en andere</h2>
      
      
      
      
      <span class="post-meta">Gepost op 9-11-2016</span>
      
        </div>
      </div>
    </div>
  </div>
</div>
</header>




<div class="container">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
          <p>C++11 kent een aantal nieuwe technieken om concurrency in een programma in te bouwen.</p>

<p>Dit zijn een aantal voorbeelden gebaseerd op de volgende labotekst.</p>

<ul>
<li><a href="https://www.classes.cs.uchicago.edu/archive/2013/spring/12300-1/labs/lab6/">https://www.classes.cs.uchicago.edu/archive/2013/spring/12300-1/labs/lab6/</a></li>
</ul>

<h1 id="vb1-cpp-een-eenvoudige-thread"><code>vb1.cpp</code>, een eenvoudige thread</h1>

<p>In dit voorbeeld wordt een thread gestart. Met <code>join()</code> kan je op het einde van de thread wachten.
De naam van de uit te voeren functie wordt als een parameter aan de constructor van <code>std::thread</code> meegegeven.
In C en ook C++ doet de naam van de functie dienst als adres van de functie.</p>

<p>Broncode: <a href="vb1.cpp">vb1.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;

void func(int x)
{
   std::cout &lt;&lt; &quot;in thread &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;
}

int main()
{
   std::thread th(func, 100);
   th.join();

   std::cout &lt;&lt; &quot;thread afgelopen\n&quot;;
   return 0;
}
</code></pre>

<h1 id="vb2-cpp-gemeenschappelijk-geheugen-schrijven"><code>vb2.cpp</code>, gemeenschappelijk geheugen schrijven</h1>

<p>Hier worden meerdere threads gestart die elk een globale variabele wijzigen.
Dit is een gevaarlijk situatie omdat er race-effecten kunnen ontstaan waardoor
het eindresultaat fout kan zijn.</p>

<p>Al de threads worden in een <code>vector</code> opgeslagen zodat achteraf een <code>join()</code> op elke
thread kan uitgevoerd worden.</p>

<p>Broncode: <a href="vb2.cpp">vb2.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;

int accum = 0;

void square(int x)
{
   std::cout &lt;&lt; &quot;in thread &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;
   accum += x*x;
}

int main()
{
   std::vector&lt;std::thread&gt; ths;
   for (int i=1; i&lt;=20; i++)
   {
      ths.push_back(std::thread(square, i));
   }

   for (auto &amp;th: ths)
   {
      th.join();
      std::cout &lt;&lt; &quot;thread afgelopen\n&quot;;
   }

   std::cout &lt;&lt; &quot;accum = &quot; &lt;&lt; accum &lt;&lt; &quot;\n&quot;;
   return 0;
}
</code></pre>

<h1 id="vb3-cpp-thread-en-mutex"><code>vb3.cpp</code>, thread en mutex</h1>

<p>Dit is de vorige versie uitgebreid met een mutex.
Hierdoor wordt het race-effect vermeden. Elke thread doet eerst
een <code>lock()</code> voordat de globale variabele gewijzigd wordt.
Achteraf gebeurt dan een <code>unlock()</code>.</p>

<p>Broncode: <a href="vb3.cpp">vb3.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

int accum = 0;
std::mutex accum_mutex;

void square(int x)
{
   int temp = x*x;
   accum_mutex.lock();
   accum += temp;
   accum_mutex.unlock();
}

int main()
{
   std::vector&lt;std::thread&gt; ths;
   for (int i=1; i&lt;=20; i++)
   {
      ths.push_back(std::thread(square, i));
   }

   for (auto &amp;th: ths)
   {
      th.join();
      std::cout &lt;&lt; &quot;thread afgelopen\n&quot;;
   }

   std::cout &lt;&lt; &quot;accum = &quot; &lt;&lt; accum &lt;&lt; &quot;\n&quot;;
   return 0;
}
</code></pre>

<h1 id="vb4-cpp-thread-en-atomic"><code>vb4.cpp</code>, thread en atomic</h1>

<p>Deze oplossing werkt niet met een mutex maar wel met een
<em>atomic</em>. Ook hier is de toegang beveiligd met wederzijdse uitsluiting.</p>

<p>Broncode: <a href="vb4.cpp">vb4.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

std::atomic&lt;int&gt; accum(0);

void square(int x)
{
   std::cout &lt;&lt; &quot;in thread &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;
   accum += x*x;
}

int main()
{
   std::vector&lt;std::thread&gt; ths;
   for (int i=1; i&lt;=20; i++)
   {
      ths.push_back(std::thread(square, i));
   }

   for (auto &amp;th: ths)
   {
      th.join();
      std::cout &lt;&lt; &quot;thread afgelopen\n&quot;;
   }

   std::cout &lt;&lt; &quot;accum = &quot; &lt;&lt; accum &lt;&lt; &quot;\n&quot;;
   return 0;
}
</code></pre>

<h1 id="vb5-cpp-async"><code>vb5.cpp</code>, async</h1>

<p>Dit voorbeeld demonstreert het gebruik van <code>async()</code>. Hiermee kan je een
bewerking, die een resultaat moet geven als een thread starten.</p>

<p>In de <code>main()</code> staan twee oproepen:</p>

<ul>
<li>De eerste staat in commentaar, hier is het niet zeker of er wel een aparte thread gestart wordt.</li>
<li>De tweede oproep heeft als parameter een constante <code>launch::async</code> die aangeeft dat er meteen een thread moet gestart worden.</li>
</ul>

<p>Met <code>get()</code> kan je het resultaat van de berekening opvragen.</p>

<p>Broncode: <a href="vb5.cpp">vb5.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;chrono&gt;

int square(int x)
{
   std::this_thread::sleep_for(std::chrono::milliseconds(100));
   return x*x;
}

int main()
{
   //auto a = std::async(square, 10);
   auto a = std::async(std::launch::async, square, 10);
   int v = a.get();

   std::cout &lt;&lt; &quot;v = &quot; &lt;&lt; v &lt;&lt; &quot;\n&quot;;
   return 0;
}
</code></pre>

<h1 id="vb6-cpp-conditievariabele"><code>vb6.cpp</code>, conditievariabele</h1>

<p>Door een conditievariabele in te zetten kan een thread
wachten op een bepaalde voorwaarde. In het voorbeeld
wacht de reporter thread tot een waarde in <code>value</code> is ingesteld.</p>

<p>De assigner thread stelt de waarde in.</p>

<p>Door het gebruik van de conditievariabele krijg je wel polling maar deze
pollingtechniek reageert snel op een wijziging van de voorwaarde
zonder dat er veel CPU verbruik is.</p>

<p>Broncode: <a href="vb6.cpp">vb6.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;

std::condition_variable cond_var;
std::mutex m;

int main()
{
   int value = 10;
   bool notified = false;

   std::thread reporter([&amp;]()
   {
      std::unique_lock&lt;std::mutex&gt; lock(m);
      while (!notified)
      {
          cond_var.wait(lock);
      }
      std::cout &lt;&lt; &quot;value is &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
   });

   std::thread assigner([&amp;]()
   {
      value = 20;
      notified = true;
      cond_var.notify_one();
   });

   reporter.join();
   assigner.join();
   return 0;
}
</code></pre>

<h1 id="vb7-cpp-consumer-producer-probleem"><code>vb7.cpp</code>, consumer-producer probleem</h1>

<p>Dit is een klassiek probleem dat met een conditievariabele is opgelost.
De conditievariabele en mutex maken nu deel uit van de klasse <code>Goods</code>.
Ze zijn daar datamembers. Er is ook een datamember <code>q</code>, dit is de wachtrij.</p>

<p>Er zijn twee methoden:</p>

<ul>
<li><p><code>push()</code></p>

<p>Deze methode plaatst een element op de wachtrij. Er hoeft
niet gewacht te worden. Met <code>notify_one()</code> wordt de andere thread gewekt.</p></li>

<li><p><code>pop()</code></p>

<p>Deze methode wacht op een element. Als de wachtrij leeg is, moet er gewacht
worden. Dit gebeurt met <code>wait()</code>.</p></li>
</ul>

<p>Naast de conditievariabele is er bij dit mechanisme nog een mutex.
Deze mutex zit verpakt in een <code>lock_guard</code> variabele.</p>

<pre><code>{
   std::lock_guard&lt;std::mutex&gt; lock(m);
   q.push(x);
}
</code></pre>

<p>Deze variabele staat in een eigen <code>{}</code> block. Hierdoor lopen
automatisch de constructor en de destructor van de <code>lock_guard</code>.
Deze zorgen respectievelijk voor de <code>lock()</code> en <code>unlock</code> van de mutex.</p>

<p>In de <code>main()</code> functie worden de producer en consumer elk als een thread gestart.</p>

<p>Broncode: <a href="vb7.cpp">vb7.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;

class Goods
{
private:
   std::condition_variable cond_var;
   std::mutex              m;
   std::queue&lt;int&gt;         q;

public:
   Goods()
   {
   }
   void push(int x)
   {
      {
         std::lock_guard&lt;std::mutex&gt; lock(m);
         q.push(x);
      }
      cond_var.notify_one();
   }
   int pop()
   {
      std::unique_lock&lt;std::mutex&gt; lock(m);
      while (q.empty())
      {
         cond_var.wait(lock);
      }
      int v = q.front();
      q.pop();
      return v;
   }
};

int main()
{
   int n = 20;
   Goods goods;

   std::thread producer([&amp;]()
   {
      for (int i=0; i&lt;n; i++)
      {
         std::cout &lt;&lt; &quot;i push &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;
         goods.push(i);
      }
   });

   std::thread consumer([&amp;]()
   {
      for (int i=0; i&lt;n; i++)
      {
         int v = goods.pop();
         std::cout &lt;&lt; &quot;v pop &quot; &lt;&lt; v &lt;&lt; &quot;\n&quot;;
      }
   });

   producer.join();
   consumer.join();
   return 0;
}
</code></pre>

<h1 id="vb8-cpp-promise-future"><code>vb8.cpp</code> promise-future</h1>

<p>In dit voorbeeld worden <em>promise</em> en <em>future</em> gedemonstreerd.
Deze constructie kan je gebruiken om een resultaat van een asynchroon lopende
bewerking op te vragen. Het resultaat wordt na de berekening met <code>set_value()</code> in de promise geplaatst.
De promise is een globale variabele die als een parameter aan de lambdafunctie
wordt meegegeven.</p>

<p>Met <code>get_future()</code> wordt eerst een future opgehaald en in deze future kan met <code>get()</code>
het uiteindelijke resultaat opgevraagd worden.</p>

<p>Broncode: <a href="vb8.cpp">vb8.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;future&gt;


int main()
{
   std::promise&lt;int&gt; prms;

   auto th = std::thread(
      [](std::promise&lt;int&gt; &amp;prms, int x) -&gt; int 
      { 
         prms.set_value(2*x); 
      },
      std::ref(prms), 15);

   th.join();
   auto ftr = prms.get_future();
   int r = ftr.get();

   std::cout &lt;&lt; &quot;r &quot; &lt;&lt; r &lt;&lt; &quot;\n&quot;;

   return 0;
}

</code></pre>

<h1 id="vb9-cpp-async-en-future"><code>vb9.cpp</code> async en future</h1>

<p>In dit voorbeeld is de promise/future verborgen in een <em>async</em>.
Deze async geeft meteen een future terug.
Dit is de variabele <code>ftr</code>.
Met deze future kan je het resultaat ophalen.
Hiervoor moet je de <code>get()</code> methode gebruiken.</p>

<p>Broncode: <a href="vb9.cpp">vb9.cpp</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;future&gt;

int main()
{
   auto ftr = std::async(
      [](int x) -&gt; int 
      { 
         return 2*x; 
      },
      15);

   int r = ftr.get();
   std::cout &lt;&lt; &quot;r &quot; &lt;&lt; r &lt;&lt; &quot;\n&quot;;

   return 0;
}
</code></pre>

<h1 id="besluit">Besluit</h1>

<p>Met de nieuwe C++11 constructies wordt multithreading mogelijk in C++
in een stijl die aansluit met de recentere vernieuwingen zoals lambdafuncties.
Deze laatste zorgen ervoor dat ook het maken van threads op een eenvoudige en leesbare
manier kan geschreven worden in C++.</p>
      </article>

      <ul class="pager blog-pager">
        
        <li class="previous">
          <a href="http://eaict.technologiecampusdiepenbeek.be/post/eerste-wt-voorbeeld/" data-toggle="tooltip" data-placement="top" title="Een eerste Wt voorbeeld in C&#43;&#43;">&larr; Vorige post</a>
        </li>
        
        
        <li class="next">
          <a href="http://eaict.technologiecampusdiepenbeek.be/post/start-blog/" data-toggle="tooltip" data-placement="top" title="Start eaict blog">Volgende post &rarr;</a>
        </li>
        
      </ul>

      

    </div>
  </div>
</div>

      

    </div>

    <footer>
  <div class="container beautiful-jekyll-footer">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
		      
		      
		      
	    	  
          
          

    		  <li>
      			<a href="http://eaict.technologiecampusdiepenbeek.be/index.xml" title="RSS">
      			  <span class="fa-stack fa-lg">
        				<i class="fa fa-circle fa-stack-2x"></i>
        				<i class="fa fa-rss fa-stack-1x fa-inverse"></i>
      			  </span>
      			</a>
    		  </li>		

        </ul>
        <p class="copyright text-muted">
    		  
    		  &nbsp;&bull;&nbsp;
    		  2017
    		  
    		  
    		  &nbsp;&bull;&nbsp;
    		  <a href="http://eaict.technologiecampusdiepenbeek.be/">eaict</a>
    		  
  	    </p>
  	        
    		<p class="theme-by text-muted">
    		  Theme by
    		  <a href="http://deanattali.com/beautiful-jekyll/">beautiful-jekyll</a>
    		</p>
      </div>
    </div>
  </div>
</footer>

<script src="http://eaict.technologiecampusdiepenbeek.be/js/jquery-1.11.2.min.js"></script>
<script src="http://eaict.technologiecampusdiepenbeek.be/js/bootstrap.min.js"></script>
<script src="http://eaict.technologiecampusdiepenbeek.be/js/main.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-92842352-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>
</html>
